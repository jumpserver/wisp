// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: service.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_service_2eproto;
namespace message {
class AssetLoginTicketRequest;
struct AssetLoginTicketRequestDefaultTypeInternal;
extern AssetLoginTicketRequestDefaultTypeInternal _AssetLoginTicketRequest_default_instance_;
class AssetLoginTicketResponse;
struct AssetLoginTicketResponseDefaultTypeInternal;
extern AssetLoginTicketResponseDefaultTypeInternal _AssetLoginTicketResponse_default_instance_;
class CommandConfirmRequest;
struct CommandConfirmRequestDefaultTypeInternal;
extern CommandConfirmRequestDefaultTypeInternal _CommandConfirmRequest_default_instance_;
class CommandConfirmResponse;
struct CommandConfirmResponseDefaultTypeInternal;
extern CommandConfirmResponseDefaultTypeInternal _CommandConfirmResponse_default_instance_;
class CommandRequest;
struct CommandRequestDefaultTypeInternal;
extern CommandRequestDefaultTypeInternal _CommandRequest_default_instance_;
class CommandResponse;
struct CommandResponseDefaultTypeInternal;
extern CommandResponseDefaultTypeInternal _CommandResponse_default_instance_;
class CookiesRequest;
struct CookiesRequestDefaultTypeInternal;
extern CookiesRequestDefaultTypeInternal _CookiesRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class FaceMonitorCallbackRequest;
struct FaceMonitorCallbackRequestDefaultTypeInternal;
extern FaceMonitorCallbackRequestDefaultTypeInternal _FaceMonitorCallbackRequest_default_instance_;
class FaceMonitorCallbackResponse;
struct FaceMonitorCallbackResponseDefaultTypeInternal;
extern FaceMonitorCallbackResponseDefaultTypeInternal _FaceMonitorCallbackResponse_default_instance_;
class FaceRecognitionCallbackRequest;
struct FaceRecognitionCallbackRequestDefaultTypeInternal;
extern FaceRecognitionCallbackRequestDefaultTypeInternal _FaceRecognitionCallbackRequest_default_instance_;
class FaceRecognitionCallbackResponse;
struct FaceRecognitionCallbackResponseDefaultTypeInternal;
extern FaceRecognitionCallbackResponseDefaultTypeInternal _FaceRecognitionCallbackResponse_default_instance_;
class FinishedTaskRequest;
struct FinishedTaskRequestDefaultTypeInternal;
extern FinishedTaskRequestDefaultTypeInternal _FinishedTaskRequest_default_instance_;
class ForwardDeleteRequest;
struct ForwardDeleteRequestDefaultTypeInternal;
extern ForwardDeleteRequestDefaultTypeInternal _ForwardDeleteRequest_default_instance_;
class ForwardRequest;
struct ForwardRequestDefaultTypeInternal;
extern ForwardRequestDefaultTypeInternal _ForwardRequest_default_instance_;
class ForwardResponse;
struct ForwardResponseDefaultTypeInternal;
extern ForwardResponseDefaultTypeInternal _ForwardResponse_default_instance_;
class JoinFaceMonitorRequest;
struct JoinFaceMonitorRequestDefaultTypeInternal;
extern JoinFaceMonitorRequestDefaultTypeInternal _JoinFaceMonitorRequest_default_instance_;
class JoinFaceMonitorResponse;
struct JoinFaceMonitorResponseDefaultTypeInternal;
extern JoinFaceMonitorResponseDefaultTypeInternal _JoinFaceMonitorResponse_default_instance_;
class ListenPortResponse;
struct ListenPortResponseDefaultTypeInternal;
extern ListenPortResponseDefaultTypeInternal _ListenPortResponse_default_instance_;
class PortFailure;
struct PortFailureDefaultTypeInternal;
extern PortFailureDefaultTypeInternal _PortFailure_default_instance_;
class PortFailureRequest;
struct PortFailureRequestDefaultTypeInternal;
extern PortFailureRequestDefaultTypeInternal _PortFailureRequest_default_instance_;
class PortInfo;
struct PortInfoDefaultTypeInternal;
extern PortInfoDefaultTypeInternal _PortInfo_default_instance_;
class PortInfoRequest;
struct PortInfoRequestDefaultTypeInternal;
extern PortInfoRequestDefaultTypeInternal _PortInfoRequest_default_instance_;
class PortInfoResponse;
struct PortInfoResponseDefaultTypeInternal;
extern PortInfoResponseDefaultTypeInternal _PortInfoResponse_default_instance_;
class PublicSettingResponse;
struct PublicSettingResponseDefaultTypeInternal;
extern PublicSettingResponseDefaultTypeInternal _PublicSettingResponse_default_instance_;
class RemainReplayRequest;
struct RemainReplayRequestDefaultTypeInternal;
extern RemainReplayRequestDefaultTypeInternal _RemainReplayRequest_default_instance_;
class RemainReplayResponse;
struct RemainReplayResponseDefaultTypeInternal;
extern RemainReplayResponseDefaultTypeInternal _RemainReplayResponse_default_instance_;
class ReplayRequest;
struct ReplayRequestDefaultTypeInternal;
extern ReplayRequestDefaultTypeInternal _ReplayRequest_default_instance_;
class ReplayResponse;
struct ReplayResponseDefaultTypeInternal;
extern ReplayResponseDefaultTypeInternal _ReplayResponse_default_instance_;
class ReqInfo;
struct ReqInfoDefaultTypeInternal;
extern ReqInfoDefaultTypeInternal _ReqInfo_default_instance_;
class SessionCreateRequest;
struct SessionCreateRequestDefaultTypeInternal;
extern SessionCreateRequestDefaultTypeInternal _SessionCreateRequest_default_instance_;
class SessionCreateResponse;
struct SessionCreateResponseDefaultTypeInternal;
extern SessionCreateResponseDefaultTypeInternal _SessionCreateResponse_default_instance_;
class SessionFinishRequest;
struct SessionFinishRequestDefaultTypeInternal;
extern SessionFinishRequestDefaultTypeInternal _SessionFinishRequest_default_instance_;
class SessionFinishResp;
struct SessionFinishRespDefaultTypeInternal;
extern SessionFinishRespDefaultTypeInternal _SessionFinishResp_default_instance_;
class SessionLifecycleLogRequest;
struct SessionLifecycleLogRequestDefaultTypeInternal;
extern SessionLifecycleLogRequestDefaultTypeInternal _SessionLifecycleLogRequest_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class TaskResponse;
struct TaskResponseDefaultTypeInternal;
extern TaskResponseDefaultTypeInternal _TaskResponse_default_instance_;
class TicketInfo;
struct TicketInfoDefaultTypeInternal;
extern TicketInfoDefaultTypeInternal _TicketInfo_default_instance_;
class TicketRequest;
struct TicketRequestDefaultTypeInternal;
extern TicketRequestDefaultTypeInternal _TicketRequest_default_instance_;
class TicketState;
struct TicketStateDefaultTypeInternal;
extern TicketStateDefaultTypeInternal _TicketState_default_instance_;
class TicketStateResponse;
struct TicketStateResponseDefaultTypeInternal;
extern TicketStateResponseDefaultTypeInternal _TicketStateResponse_default_instance_;
class TokenRequest;
struct TokenRequestDefaultTypeInternal;
extern TokenRequestDefaultTypeInternal _TokenRequest_default_instance_;
class TokenResponse;
struct TokenResponseDefaultTypeInternal;
extern TokenResponseDefaultTypeInternal _TokenResponse_default_instance_;
class UserResponse;
struct UserResponseDefaultTypeInternal;
extern UserResponseDefaultTypeInternal _UserResponse_default_instance_;
}  // namespace message
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace message {
enum TicketState_State : int {
  TicketState_State_Open = 0,
  TicketState_State_Approved = 1,
  TicketState_State_Rejected = 2,
  TicketState_State_Closed = 3,
  TicketState_State_TicketState_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TicketState_State_TicketState_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TicketState_State_IsValid(int value);
extern const uint32_t TicketState_State_internal_data_[];
constexpr TicketState_State TicketState_State_State_MIN = static_cast<TicketState_State>(0);
constexpr TicketState_State TicketState_State_State_MAX = static_cast<TicketState_State>(3);
constexpr int TicketState_State_State_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TicketState_State_descriptor();
template <typename T>
const std::string& TicketState_State_Name(T value) {
  static_assert(std::is_same<T, TicketState_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return TicketState_State_Name(static_cast<TicketState_State>(value));
}
template <>
inline const std::string& TicketState_State_Name(TicketState_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TicketState_State_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TicketState_State_Parse(absl::string_view name, TicketState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TicketState_State>(
      TicketState_State_descriptor(), name, value);
}
enum SessionLifecycleLogRequest_EventType : int {
  SessionLifecycleLogRequest_EventType_AssetConnectSuccess = 0,
  SessionLifecycleLogRequest_EventType_AssetConnectFinished = 1,
  SessionLifecycleLogRequest_EventType_CreateShareLink = 2,
  SessionLifecycleLogRequest_EventType_UserJoinSession = 3,
  SessionLifecycleLogRequest_EventType_UserLeaveSession = 4,
  SessionLifecycleLogRequest_EventType_AdminJoinMonitor = 5,
  SessionLifecycleLogRequest_EventType_AdminExitMonitor = 6,
  SessionLifecycleLogRequest_EventType_ReplayConvertStart = 7,
  SessionLifecycleLogRequest_EventType_ReplayConvertSuccess = 8,
  SessionLifecycleLogRequest_EventType_ReplayConvertFailure = 9,
  SessionLifecycleLogRequest_EventType_ReplayUploadStart = 10,
  SessionLifecycleLogRequest_EventType_ReplayUploadSuccess = 11,
  SessionLifecycleLogRequest_EventType_ReplayUploadFailure = 12,
  SessionLifecycleLogRequest_EventType_SessionLifecycleLogRequest_EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SessionLifecycleLogRequest_EventType_SessionLifecycleLogRequest_EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SessionLifecycleLogRequest_EventType_IsValid(int value);
extern const uint32_t SessionLifecycleLogRequest_EventType_internal_data_[];
constexpr SessionLifecycleLogRequest_EventType SessionLifecycleLogRequest_EventType_EventType_MIN = static_cast<SessionLifecycleLogRequest_EventType>(0);
constexpr SessionLifecycleLogRequest_EventType SessionLifecycleLogRequest_EventType_EventType_MAX = static_cast<SessionLifecycleLogRequest_EventType>(12);
constexpr int SessionLifecycleLogRequest_EventType_EventType_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
SessionLifecycleLogRequest_EventType_descriptor();
template <typename T>
const std::string& SessionLifecycleLogRequest_EventType_Name(T value) {
  static_assert(std::is_same<T, SessionLifecycleLogRequest_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return SessionLifecycleLogRequest_EventType_Name(static_cast<SessionLifecycleLogRequest_EventType>(value));
}
template <>
inline const std::string& SessionLifecycleLogRequest_EventType_Name(SessionLifecycleLogRequest_EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SessionLifecycleLogRequest_EventType_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool SessionLifecycleLogRequest_EventType_Parse(absl::string_view name, SessionLifecycleLogRequest_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionLifecycleLogRequest_EventType>(
      SessionLifecycleLogRequest_EventType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TokenRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TokenRequest) */ {
 public:
  inline TokenRequest() : TokenRequest(nullptr) {}
  ~TokenRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TokenRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TokenRequest(const TokenRequest& from) : TokenRequest(nullptr, from) {}
  inline TokenRequest(TokenRequest&& from) noexcept
      : TokenRequest(nullptr, std::move(from)) {}
  inline TokenRequest& operator=(const TokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenRequest& operator=(TokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenRequest* internal_default_instance() {
    return reinterpret_cast<const TokenRequest*>(
        &_TokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TokenRequest& a, TokenRequest& b) { a.Swap(&b); }
  inline void Swap(TokenRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TokenRequest& from) { TokenRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TokenRequest"; }

 protected:
  explicit TokenRequest(::google::protobuf::Arena* arena);
  TokenRequest(::google::protobuf::Arena* arena, const TokenRequest& from);
  TokenRequest(::google::protobuf::Arena* arena, TokenRequest&& from) noexcept
      : TokenRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:message.TokenRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      34, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TokenRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TokenRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TicketState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TicketState) */ {
 public:
  inline TicketState() : TicketState(nullptr) {}
  ~TicketState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TicketState(
      ::google::protobuf::internal::ConstantInitialized);

  inline TicketState(const TicketState& from) : TicketState(nullptr, from) {}
  inline TicketState(TicketState&& from) noexcept
      : TicketState(nullptr, std::move(from)) {}
  inline TicketState& operator=(const TicketState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketState& operator=(TicketState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TicketState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TicketState* internal_default_instance() {
    return reinterpret_cast<const TicketState*>(
        &_TicketState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TicketState& a, TicketState& b) { a.Swap(&b); }
  inline void Swap(TicketState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TicketState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TicketState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TicketState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TicketState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TicketState& from) { TicketState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TicketState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TicketState"; }

 protected:
  explicit TicketState(::google::protobuf::Arena* arena);
  TicketState(::google::protobuf::Arena* arena, const TicketState& from);
  TicketState(::google::protobuf::Arena* arena, TicketState&& from) noexcept
      : TicketState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using State = TicketState_State;
  static constexpr State Open = TicketState_State_Open;
  static constexpr State Approved = TicketState_State_Approved;
  static constexpr State Rejected = TicketState_State_Rejected;
  static constexpr State Closed = TicketState_State_Closed;
  static inline bool State_IsValid(int value) {
    return TicketState_State_IsValid(value);
  }
  static constexpr State State_MIN = TicketState_State_State_MIN;
  static constexpr State State_MAX = TicketState_State_State_MAX;
  static constexpr int State_ARRAYSIZE = TicketState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return TicketState_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return TicketState_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return TicketState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kProcessorFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // string processor = 2;
  void clear_processor() ;
  const std::string& processor() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_processor(Arg_&& arg, Args_... args);
  std::string* mutable_processor();
  PROTOBUF_NODISCARD std::string* release_processor();
  void set_allocated_processor(std::string* value);

  private:
  const std::string& _internal_processor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processor(
      const std::string& value);
  std::string* _internal_mutable_processor();

  public:
  // .message.TicketState.State state = 1;
  void clear_state() ;
  ::message::TicketState_State state() const;
  void set_state(::message::TicketState_State value);

  private:
  ::message::TicketState_State _internal_state() const;
  void _internal_set_state(::message::TicketState_State value);

  public:
  // @@protoc_insertion_point(class_scope:message.TicketState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TicketState_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TicketState& from_msg);
    ::google::protobuf::internal::ArenaStringPtr processor_;
    int state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Status final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from) : Status(nullptr, from) {}
  inline Status(Status&& from) noexcept
      : Status(nullptr, std::move(from)) {}
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
        &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Status& a, Status& b) { a.Swap(&b); }
  inline void Swap(Status* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Status& from) { Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Status* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Status"; }

 protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  Status(::google::protobuf::Arena* arena, Status&& from) noexcept
      : Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // string err = 2;
  void clear_err() ;
  const std::string& err() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_err(Arg_&& arg, Args_... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* value);

  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(
      const std::string& value);
  std::string* _internal_mutable_err();

  public:
  // bool ok = 1;
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Status_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Status& from_msg);
    ::google::protobuf::internal::ArenaStringPtr err_;
    bool ok_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class SessionLifecycleLogRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.SessionLifecycleLogRequest) */ {
 public:
  inline SessionLifecycleLogRequest() : SessionLifecycleLogRequest(nullptr) {}
  ~SessionLifecycleLogRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionLifecycleLogRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionLifecycleLogRequest(const SessionLifecycleLogRequest& from) : SessionLifecycleLogRequest(nullptr, from) {}
  inline SessionLifecycleLogRequest(SessionLifecycleLogRequest&& from) noexcept
      : SessionLifecycleLogRequest(nullptr, std::move(from)) {}
  inline SessionLifecycleLogRequest& operator=(const SessionLifecycleLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionLifecycleLogRequest& operator=(SessionLifecycleLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionLifecycleLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionLifecycleLogRequest* internal_default_instance() {
    return reinterpret_cast<const SessionLifecycleLogRequest*>(
        &_SessionLifecycleLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(SessionLifecycleLogRequest& a, SessionLifecycleLogRequest& b) { a.Swap(&b); }
  inline void Swap(SessionLifecycleLogRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionLifecycleLogRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionLifecycleLogRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SessionLifecycleLogRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionLifecycleLogRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionLifecycleLogRequest& from) { SessionLifecycleLogRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionLifecycleLogRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.SessionLifecycleLogRequest"; }

 protected:
  explicit SessionLifecycleLogRequest(::google::protobuf::Arena* arena);
  SessionLifecycleLogRequest(::google::protobuf::Arena* arena, const SessionLifecycleLogRequest& from);
  SessionLifecycleLogRequest(::google::protobuf::Arena* arena, SessionLifecycleLogRequest&& from) noexcept
      : SessionLifecycleLogRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EventType = SessionLifecycleLogRequest_EventType;
  static constexpr EventType AssetConnectSuccess = SessionLifecycleLogRequest_EventType_AssetConnectSuccess;
  static constexpr EventType AssetConnectFinished = SessionLifecycleLogRequest_EventType_AssetConnectFinished;
  static constexpr EventType CreateShareLink = SessionLifecycleLogRequest_EventType_CreateShareLink;
  static constexpr EventType UserJoinSession = SessionLifecycleLogRequest_EventType_UserJoinSession;
  static constexpr EventType UserLeaveSession = SessionLifecycleLogRequest_EventType_UserLeaveSession;
  static constexpr EventType AdminJoinMonitor = SessionLifecycleLogRequest_EventType_AdminJoinMonitor;
  static constexpr EventType AdminExitMonitor = SessionLifecycleLogRequest_EventType_AdminExitMonitor;
  static constexpr EventType ReplayConvertStart = SessionLifecycleLogRequest_EventType_ReplayConvertStart;
  static constexpr EventType ReplayConvertSuccess = SessionLifecycleLogRequest_EventType_ReplayConvertSuccess;
  static constexpr EventType ReplayConvertFailure = SessionLifecycleLogRequest_EventType_ReplayConvertFailure;
  static constexpr EventType ReplayUploadStart = SessionLifecycleLogRequest_EventType_ReplayUploadStart;
  static constexpr EventType ReplayUploadSuccess = SessionLifecycleLogRequest_EventType_ReplayUploadSuccess;
  static constexpr EventType ReplayUploadFailure = SessionLifecycleLogRequest_EventType_ReplayUploadFailure;
  static inline bool EventType_IsValid(int value) {
    return SessionLifecycleLogRequest_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = SessionLifecycleLogRequest_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = SessionLifecycleLogRequest_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = SessionLifecycleLogRequest_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EventType_descriptor() {
    return SessionLifecycleLogRequest_EventType_descriptor();
  }
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return SessionLifecycleLogRequest_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return SessionLifecycleLogRequest_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kReasonFieldNumber = 3,
    kUserFieldNumber = 4,
    kEventFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string reason = 3;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string user = 4;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // .message.SessionLifecycleLogRequest.EventType event = 2;
  void clear_event() ;
  ::message::SessionLifecycleLogRequest_EventType event() const;
  void set_event(::message::SessionLifecycleLogRequest_EventType value);

  private:
  ::message::SessionLifecycleLogRequest_EventType _internal_event() const;
  void _internal_set_event(::message::SessionLifecycleLogRequest_EventType value);

  public:
  // @@protoc_insertion_point(class_scope:message.SessionLifecycleLogRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      63, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SessionLifecycleLogRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionLifecycleLogRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    int event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class SessionFinishRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.SessionFinishRequest) */ {
 public:
  inline SessionFinishRequest() : SessionFinishRequest(nullptr) {}
  ~SessionFinishRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionFinishRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionFinishRequest(const SessionFinishRequest& from) : SessionFinishRequest(nullptr, from) {}
  inline SessionFinishRequest(SessionFinishRequest&& from) noexcept
      : SessionFinishRequest(nullptr, std::move(from)) {}
  inline SessionFinishRequest& operator=(const SessionFinishRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionFinishRequest& operator=(SessionFinishRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionFinishRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionFinishRequest* internal_default_instance() {
    return reinterpret_cast<const SessionFinishRequest*>(
        &_SessionFinishRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SessionFinishRequest& a, SessionFinishRequest& b) { a.Swap(&b); }
  inline void Swap(SessionFinishRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionFinishRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionFinishRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SessionFinishRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionFinishRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionFinishRequest& from) { SessionFinishRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionFinishRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.SessionFinishRequest"; }

 protected:
  explicit SessionFinishRequest(::google::protobuf::Arena* arena);
  SessionFinishRequest(::google::protobuf::Arena* arena, const SessionFinishRequest& from);
  SessionFinishRequest(::google::protobuf::Arena* arena, SessionFinishRequest&& from) noexcept
      : SessionFinishRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kErrFieldNumber = 4,
    kDateEndFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string err = 4;
  void clear_err() ;
  const std::string& err() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_err(Arg_&& arg, Args_... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* value);

  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(
      const std::string& value);
  std::string* _internal_mutable_err();

  public:
  // int64 date_end = 3;
  void clear_date_end() ;
  ::int64_t date_end() const;
  void set_date_end(::int64_t value);

  private:
  ::int64_t _internal_date_end() const;
  void _internal_set_date_end(::int64_t value);

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.SessionFinishRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      42, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SessionFinishRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionFinishRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr err_;
    ::int64_t date_end_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ReqInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ReqInfo) */ {
 public:
  inline ReqInfo() : ReqInfo(nullptr) {}
  ~ReqInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReqInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReqInfo(const ReqInfo& from) : ReqInfo(nullptr, from) {}
  inline ReqInfo(ReqInfo&& from) noexcept
      : ReqInfo(nullptr, std::move(from)) {}
  inline ReqInfo& operator=(const ReqInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqInfo& operator=(ReqInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqInfo* internal_default_instance() {
    return reinterpret_cast<const ReqInfo*>(
        &_ReqInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(ReqInfo& a, ReqInfo& b) { a.Swap(&b); }
  inline void Swap(ReqInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReqInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReqInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReqInfo& from) { ReqInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReqInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ReqInfo"; }

 protected:
  explicit ReqInfo(::google::protobuf::Arena* arena);
  ReqInfo(::google::protobuf::Arena* arena, const ReqInfo& from);
  ReqInfo(::google::protobuf::Arena* arena, ReqInfo&& from) noexcept
      : ReqInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMethodFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string method = 1;
  void clear_method() ;
  const std::string& method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_method(Arg_&& arg, Args_... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* value);

  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(
      const std::string& value);
  std::string* _internal_mutable_method();

  public:
  // string url = 2;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // @@protoc_insertion_point(class_scope:message.ReqInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReqInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReqInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr method_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ReplayRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ReplayRequest) */ {
 public:
  inline ReplayRequest() : ReplayRequest(nullptr) {}
  ~ReplayRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplayRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplayRequest(const ReplayRequest& from) : ReplayRequest(nullptr, from) {}
  inline ReplayRequest(ReplayRequest&& from) noexcept
      : ReplayRequest(nullptr, std::move(from)) {}
  inline ReplayRequest& operator=(const ReplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplayRequest& operator=(ReplayRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplayRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplayRequest* internal_default_instance() {
    return reinterpret_cast<const ReplayRequest*>(
        &_ReplayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReplayRequest& a, ReplayRequest& b) { a.Swap(&b); }
  inline void Swap(ReplayRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplayRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplayRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReplayRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplayRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplayRequest& from) { ReplayRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReplayRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ReplayRequest"; }

 protected:
  explicit ReplayRequest(::google::protobuf::Arena* arena);
  ReplayRequest(::google::protobuf::Arena* arena, const ReplayRequest& from);
  ReplayRequest(::google::protobuf::Arena* arena, ReplayRequest&& from) noexcept
      : ReplayRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kReplayFilePathFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string replay_file_path = 2;
  void clear_replay_file_path() ;
  const std::string& replay_file_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replay_file_path(Arg_&& arg, Args_... args);
  std::string* mutable_replay_file_path();
  PROTOBUF_NODISCARD std::string* release_replay_file_path();
  void set_allocated_replay_file_path(std::string* value);

  private:
  const std::string& _internal_replay_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replay_file_path(
      const std::string& value);
  std::string* _internal_mutable_replay_file_path();

  public:
  // @@protoc_insertion_point(class_scope:message.ReplayRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReplayRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplayRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr replay_file_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class RemainReplayRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.RemainReplayRequest) */ {
 public:
  inline RemainReplayRequest() : RemainReplayRequest(nullptr) {}
  ~RemainReplayRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemainReplayRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemainReplayRequest(const RemainReplayRequest& from) : RemainReplayRequest(nullptr, from) {}
  inline RemainReplayRequest(RemainReplayRequest&& from) noexcept
      : RemainReplayRequest(nullptr, std::move(from)) {}
  inline RemainReplayRequest& operator=(const RemainReplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemainReplayRequest& operator=(RemainReplayRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemainReplayRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemainReplayRequest* internal_default_instance() {
    return reinterpret_cast<const RemainReplayRequest*>(
        &_RemainReplayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RemainReplayRequest& a, RemainReplayRequest& b) { a.Swap(&b); }
  inline void Swap(RemainReplayRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemainReplayRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemainReplayRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RemainReplayRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemainReplayRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemainReplayRequest& from) { RemainReplayRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemainReplayRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.RemainReplayRequest"; }

 protected:
  explicit RemainReplayRequest(::google::protobuf::Arena* arena);
  RemainReplayRequest(::google::protobuf::Arena* arena, const RemainReplayRequest& from);
  RemainReplayRequest(::google::protobuf::Arena* arena, RemainReplayRequest&& from) noexcept
      : RemainReplayRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReplayDirFieldNumber = 1,
  };
  // string replay_dir = 1;
  void clear_replay_dir() ;
  const std::string& replay_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replay_dir(Arg_&& arg, Args_... args);
  std::string* mutable_replay_dir();
  PROTOBUF_NODISCARD std::string* release_replay_dir();
  void set_allocated_replay_dir(std::string* value);

  private:
  const std::string& _internal_replay_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replay_dir(
      const std::string& value);
  std::string* _internal_mutable_replay_dir();

  public:
  // @@protoc_insertion_point(class_scope:message.RemainReplayRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RemainReplayRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemainReplayRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr replay_dir_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PortInfoRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PortInfoRequest) */ {
 public:
  inline PortInfoRequest() : PortInfoRequest(nullptr) {}
  ~PortInfoRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortInfoRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortInfoRequest(const PortInfoRequest& from) : PortInfoRequest(nullptr, from) {}
  inline PortInfoRequest(PortInfoRequest&& from) noexcept
      : PortInfoRequest(nullptr, std::move(from)) {}
  inline PortInfoRequest& operator=(const PortInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortInfoRequest& operator=(PortInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortInfoRequest* internal_default_instance() {
    return reinterpret_cast<const PortInfoRequest*>(
        &_PortInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(PortInfoRequest& a, PortInfoRequest& b) { a.Swap(&b); }
  inline void Swap(PortInfoRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortInfoRequest& from) { PortInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortInfoRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PortInfoRequest"; }

 protected:
  explicit PortInfoRequest(::google::protobuf::Arena* arena);
  PortInfoRequest(::google::protobuf::Arena* arena, const PortInfoRequest& from);
  PortInfoRequest(::google::protobuf::Arena* arena, PortInfoRequest&& from) noexcept
      : PortInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPortFieldNumber = 1,
  };
  // int32 port = 1;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.PortInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortInfoRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortInfoRequest& from_msg);
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PortFailure final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PortFailure) */ {
 public:
  inline PortFailure() : PortFailure(nullptr) {}
  ~PortFailure() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortFailure(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortFailure(const PortFailure& from) : PortFailure(nullptr, from) {}
  inline PortFailure(PortFailure&& from) noexcept
      : PortFailure(nullptr, std::move(from)) {}
  inline PortFailure& operator=(const PortFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortFailure& operator=(PortFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortFailure* internal_default_instance() {
    return reinterpret_cast<const PortFailure*>(
        &_PortFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(PortFailure& a, PortFailure& b) { a.Swap(&b); }
  inline void Swap(PortFailure* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortFailure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortFailure* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortFailure>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortFailure& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortFailure& from) { PortFailure::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortFailure* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PortFailure"; }

 protected:
  explicit PortFailure(::google::protobuf::Arena* arena);
  PortFailure(::google::protobuf::Arena* arena, const PortFailure& from);
  PortFailure(::google::protobuf::Arena* arena, PortFailure&& from) noexcept
      : PortFailure(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kPortFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // int32 port = 1;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.PortFailure)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortFailure_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortFailure& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class JoinFaceMonitorRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.JoinFaceMonitorRequest) */ {
 public:
  inline JoinFaceMonitorRequest() : JoinFaceMonitorRequest(nullptr) {}
  ~JoinFaceMonitorRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinFaceMonitorRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinFaceMonitorRequest(const JoinFaceMonitorRequest& from) : JoinFaceMonitorRequest(nullptr, from) {}
  inline JoinFaceMonitorRequest(JoinFaceMonitorRequest&& from) noexcept
      : JoinFaceMonitorRequest(nullptr, std::move(from)) {}
  inline JoinFaceMonitorRequest& operator=(const JoinFaceMonitorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinFaceMonitorRequest& operator=(JoinFaceMonitorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinFaceMonitorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinFaceMonitorRequest* internal_default_instance() {
    return reinterpret_cast<const JoinFaceMonitorRequest*>(
        &_JoinFaceMonitorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(JoinFaceMonitorRequest& a, JoinFaceMonitorRequest& b) { a.Swap(&b); }
  inline void Swap(JoinFaceMonitorRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinFaceMonitorRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinFaceMonitorRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JoinFaceMonitorRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinFaceMonitorRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinFaceMonitorRequest& from) { JoinFaceMonitorRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinFaceMonitorRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.JoinFaceMonitorRequest"; }

 protected:
  explicit JoinFaceMonitorRequest(::google::protobuf::Arena* arena);
  JoinFaceMonitorRequest(::google::protobuf::Arena* arena, const JoinFaceMonitorRequest& from);
  JoinFaceMonitorRequest(::google::protobuf::Arena* arena, JoinFaceMonitorRequest&& from) noexcept
      : JoinFaceMonitorRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFaceMonitorTokenFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // string face_monitor_token = 1;
  void clear_face_monitor_token() ;
  const std::string& face_monitor_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_face_monitor_token(Arg_&& arg, Args_... args);
  std::string* mutable_face_monitor_token();
  PROTOBUF_NODISCARD std::string* release_face_monitor_token();
  void set_allocated_face_monitor_token(std::string* value);

  private:
  const std::string& _internal_face_monitor_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_monitor_token(
      const std::string& value);
  std::string* _internal_mutable_face_monitor_token();

  public:
  // string session_id = 2;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:message.JoinFaceMonitorRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_JoinFaceMonitorRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinFaceMonitorRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr face_monitor_token_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ForwardDeleteRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ForwardDeleteRequest) */ {
 public:
  inline ForwardDeleteRequest() : ForwardDeleteRequest(nullptr) {}
  ~ForwardDeleteRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ForwardDeleteRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ForwardDeleteRequest(const ForwardDeleteRequest& from) : ForwardDeleteRequest(nullptr, from) {}
  inline ForwardDeleteRequest(ForwardDeleteRequest&& from) noexcept
      : ForwardDeleteRequest(nullptr, std::move(from)) {}
  inline ForwardDeleteRequest& operator=(const ForwardDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardDeleteRequest& operator=(ForwardDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const ForwardDeleteRequest*>(
        &_ForwardDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ForwardDeleteRequest& a, ForwardDeleteRequest& b) { a.Swap(&b); }
  inline void Swap(ForwardDeleteRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardDeleteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardDeleteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ForwardDeleteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForwardDeleteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ForwardDeleteRequest& from) { ForwardDeleteRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForwardDeleteRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ForwardDeleteRequest"; }

 protected:
  explicit ForwardDeleteRequest(::google::protobuf::Arena* arena);
  ForwardDeleteRequest(::google::protobuf::Arena* arena, const ForwardDeleteRequest& from);
  ForwardDeleteRequest(::google::protobuf::Arena* arena, ForwardDeleteRequest&& from) noexcept
      : ForwardDeleteRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:message.ForwardDeleteRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ForwardDeleteRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ForwardDeleteRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FinishedTaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.FinishedTaskRequest) */ {
 public:
  inline FinishedTaskRequest() : FinishedTaskRequest(nullptr) {}
  ~FinishedTaskRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinishedTaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FinishedTaskRequest(const FinishedTaskRequest& from) : FinishedTaskRequest(nullptr, from) {}
  inline FinishedTaskRequest(FinishedTaskRequest&& from) noexcept
      : FinishedTaskRequest(nullptr, std::move(from)) {}
  inline FinishedTaskRequest& operator=(const FinishedTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishedTaskRequest& operator=(FinishedTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishedTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishedTaskRequest* internal_default_instance() {
    return reinterpret_cast<const FinishedTaskRequest*>(
        &_FinishedTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(FinishedTaskRequest& a, FinishedTaskRequest& b) { a.Swap(&b); }
  inline void Swap(FinishedTaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishedTaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishedTaskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FinishedTaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinishedTaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinishedTaskRequest& from) { FinishedTaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FinishedTaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.FinishedTaskRequest"; }

 protected:
  explicit FinishedTaskRequest(::google::protobuf::Arena* arena);
  FinishedTaskRequest(::google::protobuf::Arena* arena, const FinishedTaskRequest& from);
  FinishedTaskRequest(::google::protobuf::Arena* arena, FinishedTaskRequest&& from) noexcept
      : FinishedTaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskIdFieldNumber = 1,
  };
  // string task_id = 1;
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // @@protoc_insertion_point(class_scope:message.FinishedTaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FinishedTaskRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FinishedTaskRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FaceRecognitionCallbackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.FaceRecognitionCallbackRequest) */ {
 public:
  inline FaceRecognitionCallbackRequest() : FaceRecognitionCallbackRequest(nullptr) {}
  ~FaceRecognitionCallbackRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FaceRecognitionCallbackRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FaceRecognitionCallbackRequest(const FaceRecognitionCallbackRequest& from) : FaceRecognitionCallbackRequest(nullptr, from) {}
  inline FaceRecognitionCallbackRequest(FaceRecognitionCallbackRequest&& from) noexcept
      : FaceRecognitionCallbackRequest(nullptr, std::move(from)) {}
  inline FaceRecognitionCallbackRequest& operator=(const FaceRecognitionCallbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecognitionCallbackRequest& operator=(FaceRecognitionCallbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecognitionCallbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecognitionCallbackRequest* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionCallbackRequest*>(
        &_FaceRecognitionCallbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(FaceRecognitionCallbackRequest& a, FaceRecognitionCallbackRequest& b) { a.Swap(&b); }
  inline void Swap(FaceRecognitionCallbackRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecognitionCallbackRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecognitionCallbackRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FaceRecognitionCallbackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FaceRecognitionCallbackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FaceRecognitionCallbackRequest& from) { FaceRecognitionCallbackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FaceRecognitionCallbackRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.FaceRecognitionCallbackRequest"; }

 protected:
  explicit FaceRecognitionCallbackRequest(::google::protobuf::Arena* arena);
  FaceRecognitionCallbackRequest(::google::protobuf::Arena* arena, const FaceRecognitionCallbackRequest& from);
  FaceRecognitionCallbackRequest(::google::protobuf::Arena* arena, FaceRecognitionCallbackRequest&& from) noexcept
      : FaceRecognitionCallbackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kFaceCodeFieldNumber = 4,
    kSuccessFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string face_code = 4;
  void clear_face_code() ;
  const std::string& face_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_face_code(Arg_&& arg, Args_... args);
  std::string* mutable_face_code();
  PROTOBUF_NODISCARD std::string* release_face_code();
  void set_allocated_face_code(std::string* value);

  private:
  const std::string& _internal_face_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_code(
      const std::string& value);
  std::string* _internal_mutable_face_code();

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.FaceRecognitionCallbackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      74, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FaceRecognitionCallbackRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FaceRecognitionCallbackRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr face_code_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FaceMonitorCallbackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.FaceMonitorCallbackRequest) */ {
 public:
  inline FaceMonitorCallbackRequest() : FaceMonitorCallbackRequest(nullptr) {}
  ~FaceMonitorCallbackRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FaceMonitorCallbackRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FaceMonitorCallbackRequest(const FaceMonitorCallbackRequest& from) : FaceMonitorCallbackRequest(nullptr, from) {}
  inline FaceMonitorCallbackRequest(FaceMonitorCallbackRequest&& from) noexcept
      : FaceMonitorCallbackRequest(nullptr, std::move(from)) {}
  inline FaceMonitorCallbackRequest& operator=(const FaceMonitorCallbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceMonitorCallbackRequest& operator=(FaceMonitorCallbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceMonitorCallbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceMonitorCallbackRequest* internal_default_instance() {
    return reinterpret_cast<const FaceMonitorCallbackRequest*>(
        &_FaceMonitorCallbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(FaceMonitorCallbackRequest& a, FaceMonitorCallbackRequest& b) { a.Swap(&b); }
  inline void Swap(FaceMonitorCallbackRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceMonitorCallbackRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceMonitorCallbackRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FaceMonitorCallbackRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FaceMonitorCallbackRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FaceMonitorCallbackRequest& from) { FaceMonitorCallbackRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FaceMonitorCallbackRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.FaceMonitorCallbackRequest"; }

 protected:
  explicit FaceMonitorCallbackRequest(::google::protobuf::Arena* arena);
  FaceMonitorCallbackRequest(::google::protobuf::Arena* arena, const FaceMonitorCallbackRequest& from);
  FaceMonitorCallbackRequest(::google::protobuf::Arena* arena, FaceMonitorCallbackRequest&& from) noexcept
      : FaceMonitorCallbackRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFaceCodesFieldNumber = 6,
    kTokenFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kActionFieldNumber = 5,
    kSuccessFieldNumber = 2,
    kIsFinishedFieldNumber = 4,
  };
  // repeated string face_codes = 6;
  int face_codes_size() const;
  private:
  int _internal_face_codes_size() const;

  public:
  void clear_face_codes() ;
  const std::string& face_codes(int index) const;
  std::string* mutable_face_codes(int index);
  void set_face_codes(int index, const std::string& value);
  void set_face_codes(int index, std::string&& value);
  void set_face_codes(int index, const char* value);
  void set_face_codes(int index, const char* value, std::size_t size);
  void set_face_codes(int index, absl::string_view value);
  std::string* add_face_codes();
  void add_face_codes(const std::string& value);
  void add_face_codes(std::string&& value);
  void add_face_codes(const char* value);
  void add_face_codes(const char* value, std::size_t size);
  void add_face_codes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& face_codes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_face_codes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_face_codes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_face_codes();

  public:
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string action = 5;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* value);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // bool is_finished = 4;
  void clear_is_finished() ;
  bool is_finished() const;
  void set_is_finished(bool value);

  private:
  bool _internal_is_finished() const;
  void _internal_set_is_finished(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.FaceMonitorCallbackRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      77, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FaceMonitorCallbackRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FaceMonitorCallbackRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> face_codes_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    bool success_;
    bool is_finished_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Empty final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:message.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(
      ::google::protobuf::internal::ConstantInitialized);

  inline Empty(const Empty& from) : Empty(nullptr, from) {}
  inline Empty(Empty&& from) noexcept
      : Empty(nullptr, std::move(from)) {}
  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
        &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(Empty& a, Empty& b) { a.Swap(&b); }
  inline void Swap(Empty* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Empty"; }

 protected:
  explicit Empty(::google::protobuf::Arena* arena);
  Empty(::google::protobuf::Arena* arena, const Empty& from);
  Empty(::google::protobuf::Arena* arena, Empty&& from) noexcept
      : Empty(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:message.Empty)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Empty_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Empty& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CommandRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandRequest) */ {
 public:
  inline CommandRequest() : CommandRequest(nullptr) {}
  ~CommandRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandRequest(const CommandRequest& from) : CommandRequest(nullptr, from) {}
  inline CommandRequest(CommandRequest&& from) noexcept
      : CommandRequest(nullptr, std::move(from)) {}
  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRequest& operator=(CommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandRequest* internal_default_instance() {
    return reinterpret_cast<const CommandRequest*>(
        &_CommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(CommandRequest& a, CommandRequest& b) { a.Swap(&b); }
  inline void Swap(CommandRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandRequest& from) { CommandRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandRequest"; }

 protected:
  explicit CommandRequest(::google::protobuf::Arena* arena);
  CommandRequest(::google::protobuf::Arena* arena, const CommandRequest& from);
  CommandRequest(::google::protobuf::Arena* arena, CommandRequest&& from) noexcept
      : CommandRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSidFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kInputFieldNumber = 3,
    kOutputFieldNumber = 4,
    kUserFieldNumber = 5,
    kAssetFieldNumber = 6,
    kAccountFieldNumber = 7,
    kCmdAclIdFieldNumber = 10,
    kCmdGroupIdFieldNumber = 11,
    kTimestampFieldNumber = 8,
    kRiskLevelFieldNumber = 9,
  };
  // string sid = 1;
  void clear_sid() ;
  const std::string& sid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sid(Arg_&& arg, Args_... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* value);

  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(
      const std::string& value);
  std::string* _internal_mutable_sid();

  public:
  // string org_id = 2;
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* value);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string input = 3;
  void clear_input() ;
  const std::string& input() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input(Arg_&& arg, Args_... args);
  std::string* mutable_input();
  PROTOBUF_NODISCARD std::string* release_input();
  void set_allocated_input(std::string* value);

  private:
  const std::string& _internal_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input(
      const std::string& value);
  std::string* _internal_mutable_input();

  public:
  // string output = 4;
  void clear_output() ;
  const std::string& output() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_output(Arg_&& arg, Args_... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* value);

  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(
      const std::string& value);
  std::string* _internal_mutable_output();

  public:
  // string user = 5;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string asset = 6;
  void clear_asset() ;
  const std::string& asset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asset(Arg_&& arg, Args_... args);
  std::string* mutable_asset();
  PROTOBUF_NODISCARD std::string* release_asset();
  void set_allocated_asset(std::string* value);

  private:
  const std::string& _internal_asset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset(
      const std::string& value);
  std::string* _internal_mutable_asset();

  public:
  // string account = 7;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // string cmd_acl_id = 10;
  void clear_cmd_acl_id() ;
  const std::string& cmd_acl_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd_acl_id(Arg_&& arg, Args_... args);
  std::string* mutable_cmd_acl_id();
  PROTOBUF_NODISCARD std::string* release_cmd_acl_id();
  void set_allocated_cmd_acl_id(std::string* value);

  private:
  const std::string& _internal_cmd_acl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_acl_id(
      const std::string& value);
  std::string* _internal_mutable_cmd_acl_id();

  public:
  // string cmd_group_id = 11;
  void clear_cmd_group_id() ;
  const std::string& cmd_group_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd_group_id(Arg_&& arg, Args_... args);
  std::string* mutable_cmd_group_id();
  PROTOBUF_NODISCARD std::string* release_cmd_group_id();
  void set_allocated_cmd_group_id(std::string* value);

  private:
  const std::string& _internal_cmd_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_group_id(
      const std::string& value);
  std::string* _internal_mutable_cmd_group_id();

  public:
  // int64 timestamp = 8;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // .message.RiskLevel risk_level = 9;
  void clear_risk_level() ;
  ::message::RiskLevel risk_level() const;
  void set_risk_level(::message::RiskLevel value);

  private:
  ::message::RiskLevel _internal_risk_level() const;
  void _internal_set_risk_level(::message::RiskLevel value);

  public:
  // @@protoc_insertion_point(class_scope:message.CommandRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      97, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr sid_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr input_;
    ::google::protobuf::internal::ArenaStringPtr output_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr asset_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr cmd_acl_id_;
    ::google::protobuf::internal::ArenaStringPtr cmd_group_id_;
    ::int64_t timestamp_;
    int risk_level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CommandConfirmRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandConfirmRequest) */ {
 public:
  inline CommandConfirmRequest() : CommandConfirmRequest(nullptr) {}
  ~CommandConfirmRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConfirmRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandConfirmRequest(const CommandConfirmRequest& from) : CommandConfirmRequest(nullptr, from) {}
  inline CommandConfirmRequest(CommandConfirmRequest&& from) noexcept
      : CommandConfirmRequest(nullptr, std::move(from)) {}
  inline CommandConfirmRequest& operator=(const CommandConfirmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConfirmRequest& operator=(CommandConfirmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandConfirmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConfirmRequest* internal_default_instance() {
    return reinterpret_cast<const CommandConfirmRequest*>(
        &_CommandConfirmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(CommandConfirmRequest& a, CommandConfirmRequest& b) { a.Swap(&b); }
  inline void Swap(CommandConfirmRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConfirmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConfirmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandConfirmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandConfirmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandConfirmRequest& from) { CommandConfirmRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConfirmRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandConfirmRequest"; }

 protected:
  explicit CommandConfirmRequest(::google::protobuf::Arena* arena);
  CommandConfirmRequest(::google::protobuf::Arena* arena, const CommandConfirmRequest& from);
  CommandConfirmRequest(::google::protobuf::Arena* arena, CommandConfirmRequest&& from) noexcept
      : CommandConfirmRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kCmdAclIdFieldNumber = 2,
    kCmdFieldNumber = 3,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string cmd_acl_id = 2;
  void clear_cmd_acl_id() ;
  const std::string& cmd_acl_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd_acl_id(Arg_&& arg, Args_... args);
  std::string* mutable_cmd_acl_id();
  PROTOBUF_NODISCARD std::string* release_cmd_acl_id();
  void set_allocated_cmd_acl_id(std::string* value);

  private:
  const std::string& _internal_cmd_acl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_acl_id(
      const std::string& value);
  std::string* _internal_mutable_cmd_acl_id();

  public:
  // string cmd = 3;
  void clear_cmd() ;
  const std::string& cmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* value);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // @@protoc_insertion_point(class_scope:message.CommandConfirmRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      61, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandConfirmRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandConfirmRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr cmd_acl_id_;
    ::google::protobuf::internal::ArenaStringPtr cmd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AssetLoginTicketRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.AssetLoginTicketRequest) */ {
 public:
  inline AssetLoginTicketRequest() : AssetLoginTicketRequest(nullptr) {}
  ~AssetLoginTicketRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssetLoginTicketRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssetLoginTicketRequest(const AssetLoginTicketRequest& from) : AssetLoginTicketRequest(nullptr, from) {}
  inline AssetLoginTicketRequest(AssetLoginTicketRequest&& from) noexcept
      : AssetLoginTicketRequest(nullptr, std::move(from)) {}
  inline AssetLoginTicketRequest& operator=(const AssetLoginTicketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetLoginTicketRequest& operator=(AssetLoginTicketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetLoginTicketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetLoginTicketRequest* internal_default_instance() {
    return reinterpret_cast<const AssetLoginTicketRequest*>(
        &_AssetLoginTicketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AssetLoginTicketRequest& a, AssetLoginTicketRequest& b) { a.Swap(&b); }
  inline void Swap(AssetLoginTicketRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetLoginTicketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetLoginTicketRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssetLoginTicketRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssetLoginTicketRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssetLoginTicketRequest& from) { AssetLoginTicketRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssetLoginTicketRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.AssetLoginTicketRequest"; }

 protected:
  explicit AssetLoginTicketRequest(::google::protobuf::Arena* arena);
  AssetLoginTicketRequest(::google::protobuf::Arena* arena, const AssetLoginTicketRequest& from);
  AssetLoginTicketRequest(::google::protobuf::Arena* arena, AssetLoginTicketRequest&& from) noexcept
      : AssetLoginTicketRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kAssetIdFieldNumber = 2,
    kAccountUsernameFieldNumber = 4,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string asset_id = 2;
  void clear_asset_id() ;
  const std::string& asset_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asset_id(Arg_&& arg, Args_... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* value);

  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(
      const std::string& value);
  std::string* _internal_mutable_asset_id();

  public:
  // string account_username = 4;
  void clear_account_username() ;
  const std::string& account_username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_username(Arg_&& arg, Args_... args);
  std::string* mutable_account_username();
  PROTOBUF_NODISCARD std::string* release_account_username();
  void set_allocated_account_username(std::string* value);

  private:
  const std::string& _internal_account_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_username(
      const std::string& value);
  std::string* _internal_mutable_account_username();

  public:
  // @@protoc_insertion_point(class_scope:message.AssetLoginTicketRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      71, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssetLoginTicketRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssetLoginTicketRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr asset_id_;
    ::google::protobuf::internal::ArenaStringPtr account_username_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class UserResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.UserResponse) */ {
 public:
  inline UserResponse() : UserResponse(nullptr) {}
  ~UserResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserResponse(const UserResponse& from) : UserResponse(nullptr, from) {}
  inline UserResponse(UserResponse&& from) noexcept
      : UserResponse(nullptr, std::move(from)) {}
  inline UserResponse& operator=(const UserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResponse& operator=(UserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResponse* internal_default_instance() {
    return reinterpret_cast<const UserResponse*>(
        &_UserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(UserResponse& a, UserResponse& b) { a.Swap(&b); }
  inline void Swap(UserResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserResponse& from) { UserResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.UserResponse"; }

 protected:
  explicit UserResponse(::google::protobuf::Arena* arena);
  UserResponse(::google::protobuf::Arena* arena, const UserResponse& from);
  UserResponse(::google::protobuf::Arena* arena, UserResponse&& from) noexcept
      : UserResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.User data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::message::User& data() const;
  PROTOBUF_NODISCARD ::message::User* release_data();
  ::message::User* mutable_data();
  void set_allocated_data(::message::User* value);
  void unsafe_arena_set_allocated_data(::message::User* value);
  ::message::User* unsafe_arena_release_data();

  private:
  const ::message::User& _internal_data() const;
  ::message::User* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.UserResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UserResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::User* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TicketStateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TicketStateResponse) */ {
 public:
  inline TicketStateResponse() : TicketStateResponse(nullptr) {}
  ~TicketStateResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TicketStateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TicketStateResponse(const TicketStateResponse& from) : TicketStateResponse(nullptr, from) {}
  inline TicketStateResponse(TicketStateResponse&& from) noexcept
      : TicketStateResponse(nullptr, std::move(from)) {}
  inline TicketStateResponse& operator=(const TicketStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketStateResponse& operator=(TicketStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TicketStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TicketStateResponse* internal_default_instance() {
    return reinterpret_cast<const TicketStateResponse*>(
        &_TicketStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(TicketStateResponse& a, TicketStateResponse& b) { a.Swap(&b); }
  inline void Swap(TicketStateResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TicketStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TicketStateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TicketStateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TicketStateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TicketStateResponse& from) { TicketStateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TicketStateResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TicketStateResponse"; }

 protected:
  explicit TicketStateResponse(::google::protobuf::Arena* arena);
  TicketStateResponse(::google::protobuf::Arena* arena, const TicketStateResponse& from);
  TicketStateResponse(::google::protobuf::Arena* arena, TicketStateResponse&& from) noexcept
      : TicketStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .message.TicketState Data = 1;
  bool has_data() const;
  void clear_data() ;
  const ::message::TicketState& data() const;
  PROTOBUF_NODISCARD ::message::TicketState* release_data();
  ::message::TicketState* mutable_data();
  void set_allocated_data(::message::TicketState* value);
  void unsafe_arena_set_allocated_data(::message::TicketState* value);
  ::message::TicketState* unsafe_arena_release_data();

  private:
  const ::message::TicketState& _internal_data() const;
  ::message::TicketState* _internal_mutable_data();

  public:
  // .message.Status status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.TicketStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TicketStateResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TicketStateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::TicketState* data_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TicketRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TicketRequest) */ {
 public:
  inline TicketRequest() : TicketRequest(nullptr) {}
  ~TicketRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TicketRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TicketRequest(const TicketRequest& from) : TicketRequest(nullptr, from) {}
  inline TicketRequest(TicketRequest&& from) noexcept
      : TicketRequest(nullptr, std::move(from)) {}
  inline TicketRequest& operator=(const TicketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketRequest& operator=(TicketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TicketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TicketRequest* internal_default_instance() {
    return reinterpret_cast<const TicketRequest*>(
        &_TicketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(TicketRequest& a, TicketRequest& b) { a.Swap(&b); }
  inline void Swap(TicketRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TicketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TicketRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TicketRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TicketRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TicketRequest& from) { TicketRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TicketRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TicketRequest"; }

 protected:
  explicit TicketRequest(::google::protobuf::Arena* arena);
  TicketRequest(::google::protobuf::Arena* arena, const TicketRequest& from);
  TicketRequest(::google::protobuf::Arena* arena, TicketRequest&& from) noexcept
      : TicketRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReqFieldNumber = 1,
  };
  // .message.ReqInfo req = 1;
  bool has_req() const;
  void clear_req() ;
  const ::message::ReqInfo& req() const;
  PROTOBUF_NODISCARD ::message::ReqInfo* release_req();
  ::message::ReqInfo* mutable_req();
  void set_allocated_req(::message::ReqInfo* value);
  void unsafe_arena_set_allocated_req(::message::ReqInfo* value);
  ::message::ReqInfo* unsafe_arena_release_req();

  private:
  const ::message::ReqInfo& _internal_req() const;
  ::message::ReqInfo* _internal_mutable_req();

  public:
  // @@protoc_insertion_point(class_scope:message.TicketRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TicketRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TicketRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::ReqInfo* req_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TicketInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TicketInfo) */ {
 public:
  inline TicketInfo() : TicketInfo(nullptr) {}
  ~TicketInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TicketInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TicketInfo(const TicketInfo& from) : TicketInfo(nullptr, from) {}
  inline TicketInfo(TicketInfo&& from) noexcept
      : TicketInfo(nullptr, std::move(from)) {}
  inline TicketInfo& operator=(const TicketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketInfo& operator=(TicketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TicketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TicketInfo* internal_default_instance() {
    return reinterpret_cast<const TicketInfo*>(
        &_TicketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(TicketInfo& a, TicketInfo& b) { a.Swap(&b); }
  inline void Swap(TicketInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TicketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TicketInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TicketInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TicketInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TicketInfo& from) { TicketInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TicketInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TicketInfo"; }

 protected:
  explicit TicketInfo(::google::protobuf::Arena* arena);
  TicketInfo(::google::protobuf::Arena* arena, const TicketInfo& from);
  TicketInfo(::google::protobuf::Arena* arena, TicketInfo&& from) noexcept
      : TicketInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReviewersFieldNumber = 4,
    kTicketDetailUrlFieldNumber = 3,
    kCheckReqFieldNumber = 1,
    kCancelReqFieldNumber = 2,
  };
  // repeated string reviewers = 4;
  int reviewers_size() const;
  private:
  int _internal_reviewers_size() const;

  public:
  void clear_reviewers() ;
  const std::string& reviewers(int index) const;
  std::string* mutable_reviewers(int index);
  void set_reviewers(int index, const std::string& value);
  void set_reviewers(int index, std::string&& value);
  void set_reviewers(int index, const char* value);
  void set_reviewers(int index, const char* value, std::size_t size);
  void set_reviewers(int index, absl::string_view value);
  std::string* add_reviewers();
  void add_reviewers(const std::string& value);
  void add_reviewers(std::string&& value);
  void add_reviewers(const char* value);
  void add_reviewers(const char* value, std::size_t size);
  void add_reviewers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& reviewers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_reviewers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_reviewers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_reviewers();

  public:
  // string ticket_detail_url = 3;
  void clear_ticket_detail_url() ;
  const std::string& ticket_detail_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticket_detail_url(Arg_&& arg, Args_... args);
  std::string* mutable_ticket_detail_url();
  PROTOBUF_NODISCARD std::string* release_ticket_detail_url();
  void set_allocated_ticket_detail_url(std::string* value);

  private:
  const std::string& _internal_ticket_detail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_detail_url(
      const std::string& value);
  std::string* _internal_mutable_ticket_detail_url();

  public:
  // .message.ReqInfo check_req = 1;
  bool has_check_req() const;
  void clear_check_req() ;
  const ::message::ReqInfo& check_req() const;
  PROTOBUF_NODISCARD ::message::ReqInfo* release_check_req();
  ::message::ReqInfo* mutable_check_req();
  void set_allocated_check_req(::message::ReqInfo* value);
  void unsafe_arena_set_allocated_check_req(::message::ReqInfo* value);
  ::message::ReqInfo* unsafe_arena_release_check_req();

  private:
  const ::message::ReqInfo& _internal_check_req() const;
  ::message::ReqInfo* _internal_mutable_check_req();

  public:
  // .message.ReqInfo cancel_req = 2;
  bool has_cancel_req() const;
  void clear_cancel_req() ;
  const ::message::ReqInfo& cancel_req() const;
  PROTOBUF_NODISCARD ::message::ReqInfo* release_cancel_req();
  ::message::ReqInfo* mutable_cancel_req();
  void set_allocated_cancel_req(::message::ReqInfo* value);
  void unsafe_arena_set_allocated_cancel_req(::message::ReqInfo* value);
  ::message::ReqInfo* unsafe_arena_release_cancel_req();

  private:
  const ::message::ReqInfo& _internal_cancel_req() const;
  ::message::ReqInfo* _internal_mutable_cancel_req();

  public:
  // @@protoc_insertion_point(class_scope:message.TicketInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TicketInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TicketInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> reviewers_;
    ::google::protobuf::internal::ArenaStringPtr ticket_detail_url_;
    ::message::ReqInfo* check_req_;
    ::message::ReqInfo* cancel_req_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatusResponse(const StatusResponse& from) : StatusResponse(nullptr, from) {}
  inline StatusResponse(StatusResponse&& from) noexcept
      : StatusResponse(nullptr, std::move(from)) {}
  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
        &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(StatusResponse& a, StatusResponse& b) { a.Swap(&b); }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatusResponse& from) { StatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.StatusResponse"; }

 protected:
  explicit StatusResponse(::google::protobuf::Arena* arena);
  StatusResponse(::google::protobuf::Arena* arena, const StatusResponse& from);
  StatusResponse(::google::protobuf::Arena* arena, StatusResponse&& from) noexcept
      : StatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.StatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StatusResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatusResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class SessionFinishResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.SessionFinishResp) */ {
 public:
  inline SessionFinishResp() : SessionFinishResp(nullptr) {}
  ~SessionFinishResp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionFinishResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionFinishResp(const SessionFinishResp& from) : SessionFinishResp(nullptr, from) {}
  inline SessionFinishResp(SessionFinishResp&& from) noexcept
      : SessionFinishResp(nullptr, std::move(from)) {}
  inline SessionFinishResp& operator=(const SessionFinishResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionFinishResp& operator=(SessionFinishResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionFinishResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionFinishResp* internal_default_instance() {
    return reinterpret_cast<const SessionFinishResp*>(
        &_SessionFinishResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SessionFinishResp& a, SessionFinishResp& b) { a.Swap(&b); }
  inline void Swap(SessionFinishResp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionFinishResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionFinishResp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SessionFinishResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionFinishResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionFinishResp& from) { SessionFinishResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionFinishResp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.SessionFinishResp"; }

 protected:
  explicit SessionFinishResp(::google::protobuf::Arena* arena);
  SessionFinishResp(::google::protobuf::Arena* arena, const SessionFinishResp& from);
  SessionFinishResp(::google::protobuf::Arena* arena, SessionFinishResp&& from) noexcept
      : SessionFinishResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.SessionFinishResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SessionFinishResp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionFinishResp& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class SessionCreateResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.SessionCreateResponse) */ {
 public:
  inline SessionCreateResponse() : SessionCreateResponse(nullptr) {}
  ~SessionCreateResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionCreateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionCreateResponse(const SessionCreateResponse& from) : SessionCreateResponse(nullptr, from) {}
  inline SessionCreateResponse(SessionCreateResponse&& from) noexcept
      : SessionCreateResponse(nullptr, std::move(from)) {}
  inline SessionCreateResponse& operator=(const SessionCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionCreateResponse& operator=(SessionCreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionCreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionCreateResponse* internal_default_instance() {
    return reinterpret_cast<const SessionCreateResponse*>(
        &_SessionCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SessionCreateResponse& a, SessionCreateResponse& b) { a.Swap(&b); }
  inline void Swap(SessionCreateResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionCreateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionCreateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SessionCreateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionCreateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionCreateResponse& from) { SessionCreateResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionCreateResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.SessionCreateResponse"; }

 protected:
  explicit SessionCreateResponse(::google::protobuf::Arena* arena);
  SessionCreateResponse(::google::protobuf::Arena* arena, const SessionCreateResponse& from);
  SessionCreateResponse(::google::protobuf::Arena* arena, SessionCreateResponse&& from) noexcept
      : SessionCreateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.Session data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::message::Session& data() const;
  PROTOBUF_NODISCARD ::message::Session* release_data();
  ::message::Session* mutable_data();
  void set_allocated_data(::message::Session* value);
  void unsafe_arena_set_allocated_data(::message::Session* value);
  ::message::Session* unsafe_arena_release_data();

  private:
  const ::message::Session& _internal_data() const;
  ::message::Session* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.SessionCreateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SessionCreateResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionCreateResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::Session* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class SessionCreateRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.SessionCreateRequest) */ {
 public:
  inline SessionCreateRequest() : SessionCreateRequest(nullptr) {}
  ~SessionCreateRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionCreateRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionCreateRequest(const SessionCreateRequest& from) : SessionCreateRequest(nullptr, from) {}
  inline SessionCreateRequest(SessionCreateRequest&& from) noexcept
      : SessionCreateRequest(nullptr, std::move(from)) {}
  inline SessionCreateRequest& operator=(const SessionCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionCreateRequest& operator=(SessionCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionCreateRequest* internal_default_instance() {
    return reinterpret_cast<const SessionCreateRequest*>(
        &_SessionCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SessionCreateRequest& a, SessionCreateRequest& b) { a.Swap(&b); }
  inline void Swap(SessionCreateRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionCreateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionCreateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SessionCreateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionCreateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionCreateRequest& from) { SessionCreateRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionCreateRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.SessionCreateRequest"; }

 protected:
  explicit SessionCreateRequest(::google::protobuf::Arena* arena);
  SessionCreateRequest(::google::protobuf::Arena* arena, const SessionCreateRequest& from);
  SessionCreateRequest(::google::protobuf::Arena* arena, SessionCreateRequest&& from) noexcept
      : SessionCreateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // .message.Session data = 1;
  bool has_data() const;
  void clear_data() ;
  const ::message::Session& data() const;
  PROTOBUF_NODISCARD ::message::Session* release_data();
  ::message::Session* mutable_data();
  void set_allocated_data(::message::Session* value);
  void unsafe_arena_set_allocated_data(::message::Session* value);
  ::message::Session* unsafe_arena_release_data();

  private:
  const ::message::Session& _internal_data() const;
  ::message::Session* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.SessionCreateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SessionCreateRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionCreateRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Session* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ReplayResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ReplayResponse) */ {
 public:
  inline ReplayResponse() : ReplayResponse(nullptr) {}
  ~ReplayResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplayResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplayResponse(const ReplayResponse& from) : ReplayResponse(nullptr, from) {}
  inline ReplayResponse(ReplayResponse&& from) noexcept
      : ReplayResponse(nullptr, std::move(from)) {}
  inline ReplayResponse& operator=(const ReplayResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplayResponse& operator=(ReplayResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplayResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplayResponse* internal_default_instance() {
    return reinterpret_cast<const ReplayResponse*>(
        &_ReplayResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ReplayResponse& a, ReplayResponse& b) { a.Swap(&b); }
  inline void Swap(ReplayResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplayResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplayResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReplayResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplayResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplayResponse& from) { ReplayResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReplayResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ReplayResponse"; }

 protected:
  explicit ReplayResponse(::google::protobuf::Arena* arena);
  ReplayResponse(::google::protobuf::Arena* arena, const ReplayResponse& from);
  ReplayResponse(::google::protobuf::Arena* arena, ReplayResponse&& from) noexcept
      : ReplayResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.ReplayResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReplayResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplayResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class RemainReplayResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.RemainReplayResponse) */ {
 public:
  inline RemainReplayResponse() : RemainReplayResponse(nullptr) {}
  ~RemainReplayResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemainReplayResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemainReplayResponse(const RemainReplayResponse& from) : RemainReplayResponse(nullptr, from) {}
  inline RemainReplayResponse(RemainReplayResponse&& from) noexcept
      : RemainReplayResponse(nullptr, std::move(from)) {}
  inline RemainReplayResponse& operator=(const RemainReplayResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemainReplayResponse& operator=(RemainReplayResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemainReplayResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemainReplayResponse* internal_default_instance() {
    return reinterpret_cast<const RemainReplayResponse*>(
        &_RemainReplayResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RemainReplayResponse& a, RemainReplayResponse& b) { a.Swap(&b); }
  inline void Swap(RemainReplayResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemainReplayResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemainReplayResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RemainReplayResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemainReplayResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemainReplayResponse& from) { RemainReplayResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemainReplayResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.RemainReplayResponse"; }

 protected:
  explicit RemainReplayResponse(::google::protobuf::Arena* arena);
  RemainReplayResponse(::google::protobuf::Arena* arena, const RemainReplayResponse& from);
  RemainReplayResponse(::google::protobuf::Arena* arena, RemainReplayResponse&& from) noexcept
      : RemainReplayResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFilesFieldNumber = 2,
    kFailureFilesFieldNumber = 3,
    kFailureErrsFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // repeated string success_files = 2;
  int success_files_size() const;
  private:
  int _internal_success_files_size() const;

  public:
  void clear_success_files() ;
  const std::string& success_files(int index) const;
  std::string* mutable_success_files(int index);
  void set_success_files(int index, const std::string& value);
  void set_success_files(int index, std::string&& value);
  void set_success_files(int index, const char* value);
  void set_success_files(int index, const char* value, std::size_t size);
  void set_success_files(int index, absl::string_view value);
  std::string* add_success_files();
  void add_success_files(const std::string& value);
  void add_success_files(std::string&& value);
  void add_success_files(const char* value);
  void add_success_files(const char* value, std::size_t size);
  void add_success_files(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& success_files() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_success_files();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_success_files() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_success_files();

  public:
  // repeated string failure_files = 3;
  int failure_files_size() const;
  private:
  int _internal_failure_files_size() const;

  public:
  void clear_failure_files() ;
  const std::string& failure_files(int index) const;
  std::string* mutable_failure_files(int index);
  void set_failure_files(int index, const std::string& value);
  void set_failure_files(int index, std::string&& value);
  void set_failure_files(int index, const char* value);
  void set_failure_files(int index, const char* value, std::size_t size);
  void set_failure_files(int index, absl::string_view value);
  std::string* add_failure_files();
  void add_failure_files(const std::string& value);
  void add_failure_files(std::string&& value);
  void add_failure_files(const char* value);
  void add_failure_files(const char* value, std::size_t size);
  void add_failure_files(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& failure_files() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_failure_files();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_failure_files() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_failure_files();

  public:
  // repeated string failure_errs = 4;
  int failure_errs_size() const;
  private:
  int _internal_failure_errs_size() const;

  public:
  void clear_failure_errs() ;
  const std::string& failure_errs(int index) const;
  std::string* mutable_failure_errs(int index);
  void set_failure_errs(int index, const std::string& value);
  void set_failure_errs(int index, std::string&& value);
  void set_failure_errs(int index, const char* value);
  void set_failure_errs(int index, const char* value, std::size_t size);
  void set_failure_errs(int index, absl::string_view value);
  std::string* add_failure_errs();
  void add_failure_errs(const std::string& value);
  void add_failure_errs(std::string&& value);
  void add_failure_errs(const char* value);
  void add_failure_errs(const char* value, std::size_t size);
  void add_failure_errs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& failure_errs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_failure_errs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_failure_errs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_failure_errs();

  public:
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.RemainReplayResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      75, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RemainReplayResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemainReplayResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> success_files_;
    ::google::protobuf::RepeatedPtrField<std::string> failure_files_;
    ::google::protobuf::RepeatedPtrField<std::string> failure_errs_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PublicSettingResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PublicSettingResponse) */ {
 public:
  inline PublicSettingResponse() : PublicSettingResponse(nullptr) {}
  ~PublicSettingResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PublicSettingResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PublicSettingResponse(const PublicSettingResponse& from) : PublicSettingResponse(nullptr, from) {}
  inline PublicSettingResponse(PublicSettingResponse&& from) noexcept
      : PublicSettingResponse(nullptr, std::move(from)) {}
  inline PublicSettingResponse& operator=(const PublicSettingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicSettingResponse& operator=(PublicSettingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicSettingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicSettingResponse* internal_default_instance() {
    return reinterpret_cast<const PublicSettingResponse*>(
        &_PublicSettingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(PublicSettingResponse& a, PublicSettingResponse& b) { a.Swap(&b); }
  inline void Swap(PublicSettingResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicSettingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicSettingResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PublicSettingResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicSettingResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PublicSettingResponse& from) { PublicSettingResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicSettingResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PublicSettingResponse"; }

 protected:
  explicit PublicSettingResponse(::google::protobuf::Arena* arena);
  PublicSettingResponse(::google::protobuf::Arena* arena, const PublicSettingResponse& from);
  PublicSettingResponse(::google::protobuf::Arena* arena, PublicSettingResponse&& from) noexcept
      : PublicSettingResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.PublicSetting data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::message::PublicSetting& data() const;
  PROTOBUF_NODISCARD ::message::PublicSetting* release_data();
  ::message::PublicSetting* mutable_data();
  void set_allocated_data(::message::PublicSetting* value);
  void unsafe_arena_set_allocated_data(::message::PublicSetting* value);
  ::message::PublicSetting* unsafe_arena_release_data();

  private:
  const ::message::PublicSetting& _internal_data() const;
  ::message::PublicSetting* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.PublicSettingResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PublicSettingResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PublicSettingResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::PublicSetting* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PortFailureRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PortFailureRequest) */ {
 public:
  inline PortFailureRequest() : PortFailureRequest(nullptr) {}
  ~PortFailureRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortFailureRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortFailureRequest(const PortFailureRequest& from) : PortFailureRequest(nullptr, from) {}
  inline PortFailureRequest(PortFailureRequest&& from) noexcept
      : PortFailureRequest(nullptr, std::move(from)) {}
  inline PortFailureRequest& operator=(const PortFailureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortFailureRequest& operator=(PortFailureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortFailureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortFailureRequest* internal_default_instance() {
    return reinterpret_cast<const PortFailureRequest*>(
        &_PortFailureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(PortFailureRequest& a, PortFailureRequest& b) { a.Swap(&b); }
  inline void Swap(PortFailureRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortFailureRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortFailureRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortFailureRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortFailureRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortFailureRequest& from) { PortFailureRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortFailureRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PortFailureRequest"; }

 protected:
  explicit PortFailureRequest(::google::protobuf::Arena* arena);
  PortFailureRequest(::google::protobuf::Arena* arena, const PortFailureRequest& from);
  PortFailureRequest(::google::protobuf::Arena* arena, PortFailureRequest&& from) noexcept
      : PortFailureRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .message.PortFailure data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::message::PortFailure* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField<::message::PortFailure>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::PortFailure>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::message::PortFailure>* _internal_mutable_data();
  public:
  const ::message::PortFailure& data(int index) const;
  ::message::PortFailure* add_data();
  const ::google::protobuf::RepeatedPtrField<::message::PortFailure>& data() const;
  // @@protoc_insertion_point(class_scope:message.PortFailureRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortFailureRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortFailureRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::message::PortFailure > data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ListenPortResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ListenPortResponse) */ {
 public:
  inline ListenPortResponse() : ListenPortResponse(nullptr) {}
  ~ListenPortResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListenPortResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListenPortResponse(const ListenPortResponse& from) : ListenPortResponse(nullptr, from) {}
  inline ListenPortResponse(ListenPortResponse&& from) noexcept
      : ListenPortResponse(nullptr, std::move(from)) {}
  inline ListenPortResponse& operator=(const ListenPortResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenPortResponse& operator=(ListenPortResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenPortResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenPortResponse* internal_default_instance() {
    return reinterpret_cast<const ListenPortResponse*>(
        &_ListenPortResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ListenPortResponse& a, ListenPortResponse& b) { a.Swap(&b); }
  inline void Swap(ListenPortResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenPortResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenPortResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ListenPortResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListenPortResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListenPortResponse& from) { ListenPortResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListenPortResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ListenPortResponse"; }

 protected:
  explicit ListenPortResponse(::google::protobuf::Arena* arena);
  ListenPortResponse(::google::protobuf::Arena* arena, const ListenPortResponse& from);
  ListenPortResponse(::google::protobuf::Arena* arena, ListenPortResponse&& from) noexcept
      : ListenPortResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPortsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated int32 ports = 2;
  int ports_size() const;
  private:
  int _internal_ports_size() const;

  public:
  void clear_ports() ;
  ::int32_t ports(int index) const;
  void set_ports(int index, ::int32_t value);
  void add_ports(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& ports() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_ports();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_ports() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_ports();

  public:
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.ListenPortResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ListenPortResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListenPortResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> ports_;
    mutable ::google::protobuf::internal::CachedSize _ports_cached_byte_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class JoinFaceMonitorResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.JoinFaceMonitorResponse) */ {
 public:
  inline JoinFaceMonitorResponse() : JoinFaceMonitorResponse(nullptr) {}
  ~JoinFaceMonitorResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinFaceMonitorResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinFaceMonitorResponse(const JoinFaceMonitorResponse& from) : JoinFaceMonitorResponse(nullptr, from) {}
  inline JoinFaceMonitorResponse(JoinFaceMonitorResponse&& from) noexcept
      : JoinFaceMonitorResponse(nullptr, std::move(from)) {}
  inline JoinFaceMonitorResponse& operator=(const JoinFaceMonitorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinFaceMonitorResponse& operator=(JoinFaceMonitorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinFaceMonitorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinFaceMonitorResponse* internal_default_instance() {
    return reinterpret_cast<const JoinFaceMonitorResponse*>(
        &_JoinFaceMonitorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(JoinFaceMonitorResponse& a, JoinFaceMonitorResponse& b) { a.Swap(&b); }
  inline void Swap(JoinFaceMonitorResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinFaceMonitorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinFaceMonitorResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JoinFaceMonitorResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinFaceMonitorResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinFaceMonitorResponse& from) { JoinFaceMonitorResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinFaceMonitorResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.JoinFaceMonitorResponse"; }

 protected:
  explicit JoinFaceMonitorResponse(::google::protobuf::Arena* arena);
  JoinFaceMonitorResponse(::google::protobuf::Arena* arena, const JoinFaceMonitorResponse& from);
  JoinFaceMonitorResponse(::google::protobuf::Arena* arena, JoinFaceMonitorResponse&& from) noexcept
      : JoinFaceMonitorResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.JoinFaceMonitorResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_JoinFaceMonitorResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinFaceMonitorResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ForwardResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ForwardResponse) */ {
 public:
  inline ForwardResponse() : ForwardResponse(nullptr) {}
  ~ForwardResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ForwardResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ForwardResponse(const ForwardResponse& from) : ForwardResponse(nullptr, from) {}
  inline ForwardResponse(ForwardResponse&& from) noexcept
      : ForwardResponse(nullptr, std::move(from)) {}
  inline ForwardResponse& operator=(const ForwardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardResponse& operator=(ForwardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardResponse* internal_default_instance() {
    return reinterpret_cast<const ForwardResponse*>(
        &_ForwardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(ForwardResponse& a, ForwardResponse& b) { a.Swap(&b); }
  inline void Swap(ForwardResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ForwardResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForwardResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ForwardResponse& from) { ForwardResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForwardResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ForwardResponse"; }

 protected:
  explicit ForwardResponse(::google::protobuf::Arena* arena);
  ForwardResponse(::google::protobuf::Arena* arena, const ForwardResponse& from);
  ForwardResponse(::google::protobuf::Arena* arena, ForwardResponse&& from) noexcept
      : ForwardResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 2,
    kHostFieldNumber = 3,
    kStatusFieldNumber = 1,
    kPortFieldNumber = 4,
  };
  // string id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string host = 3;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // int32 port = 4;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.ForwardResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ForwardResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ForwardResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::message::Status* status_;
    ::int32_t port_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ForwardRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ForwardRequest) */ {
 public:
  inline ForwardRequest() : ForwardRequest(nullptr) {}
  ~ForwardRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ForwardRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ForwardRequest(const ForwardRequest& from) : ForwardRequest(nullptr, from) {}
  inline ForwardRequest(ForwardRequest&& from) noexcept
      : ForwardRequest(nullptr, std::move(from)) {}
  inline ForwardRequest& operator=(const ForwardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardRequest& operator=(ForwardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardRequest* internal_default_instance() {
    return reinterpret_cast<const ForwardRequest*>(
        &_ForwardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(ForwardRequest& a, ForwardRequest& b) { a.Swap(&b); }
  inline void Swap(ForwardRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ForwardRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ForwardRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ForwardRequest& from) { ForwardRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ForwardRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ForwardRequest"; }

 protected:
  explicit ForwardRequest(::google::protobuf::Arena* arena);
  ForwardRequest(::google::protobuf::Arena* arena, const ForwardRequest& from);
  ForwardRequest(::google::protobuf::Arena* arena, ForwardRequest&& from) noexcept
      : ForwardRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGatewaysFieldNumber = 3,
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // repeated .message.Gateway gateways = 3;
  int gateways_size() const;
  private:
  int _internal_gateways_size() const;

  public:
  void clear_gateways() ;
  ::message::Gateway* mutable_gateways(int index);
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* mutable_gateways();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& _internal_gateways() const;
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* _internal_mutable_gateways();
  public:
  const ::message::Gateway& gateways(int index) const;
  ::message::Gateway* add_gateways();
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& gateways() const;
  // string host = 1;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // int32 port = 2;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.ForwardRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      35, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ForwardRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ForwardRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::message::Gateway > gateways_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FaceRecognitionCallbackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.FaceRecognitionCallbackResponse) */ {
 public:
  inline FaceRecognitionCallbackResponse() : FaceRecognitionCallbackResponse(nullptr) {}
  ~FaceRecognitionCallbackResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FaceRecognitionCallbackResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FaceRecognitionCallbackResponse(const FaceRecognitionCallbackResponse& from) : FaceRecognitionCallbackResponse(nullptr, from) {}
  inline FaceRecognitionCallbackResponse(FaceRecognitionCallbackResponse&& from) noexcept
      : FaceRecognitionCallbackResponse(nullptr, std::move(from)) {}
  inline FaceRecognitionCallbackResponse& operator=(const FaceRecognitionCallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecognitionCallbackResponse& operator=(FaceRecognitionCallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecognitionCallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecognitionCallbackResponse* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionCallbackResponse*>(
        &_FaceRecognitionCallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(FaceRecognitionCallbackResponse& a, FaceRecognitionCallbackResponse& b) { a.Swap(&b); }
  inline void Swap(FaceRecognitionCallbackResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecognitionCallbackResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecognitionCallbackResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FaceRecognitionCallbackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FaceRecognitionCallbackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FaceRecognitionCallbackResponse& from) { FaceRecognitionCallbackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FaceRecognitionCallbackResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.FaceRecognitionCallbackResponse"; }

 protected:
  explicit FaceRecognitionCallbackResponse(::google::protobuf::Arena* arena);
  FaceRecognitionCallbackResponse(::google::protobuf::Arena* arena, const FaceRecognitionCallbackResponse& from);
  FaceRecognitionCallbackResponse(::google::protobuf::Arena* arena, FaceRecognitionCallbackResponse&& from) noexcept
      : FaceRecognitionCallbackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.FaceRecognitionCallbackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FaceRecognitionCallbackResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FaceRecognitionCallbackResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FaceMonitorCallbackResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.FaceMonitorCallbackResponse) */ {
 public:
  inline FaceMonitorCallbackResponse() : FaceMonitorCallbackResponse(nullptr) {}
  ~FaceMonitorCallbackResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FaceMonitorCallbackResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FaceMonitorCallbackResponse(const FaceMonitorCallbackResponse& from) : FaceMonitorCallbackResponse(nullptr, from) {}
  inline FaceMonitorCallbackResponse(FaceMonitorCallbackResponse&& from) noexcept
      : FaceMonitorCallbackResponse(nullptr, std::move(from)) {}
  inline FaceMonitorCallbackResponse& operator=(const FaceMonitorCallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceMonitorCallbackResponse& operator=(FaceMonitorCallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceMonitorCallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceMonitorCallbackResponse* internal_default_instance() {
    return reinterpret_cast<const FaceMonitorCallbackResponse*>(
        &_FaceMonitorCallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(FaceMonitorCallbackResponse& a, FaceMonitorCallbackResponse& b) { a.Swap(&b); }
  inline void Swap(FaceMonitorCallbackResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceMonitorCallbackResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceMonitorCallbackResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FaceMonitorCallbackResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FaceMonitorCallbackResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FaceMonitorCallbackResponse& from) { FaceMonitorCallbackResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FaceMonitorCallbackResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.FaceMonitorCallbackResponse"; }

 protected:
  explicit FaceMonitorCallbackResponse(::google::protobuf::Arena* arena);
  FaceMonitorCallbackResponse(::google::protobuf::Arena* arena, const FaceMonitorCallbackResponse& from);
  FaceMonitorCallbackResponse(::google::protobuf::Arena* arena, FaceMonitorCallbackResponse&& from) noexcept
      : FaceMonitorCallbackResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.FaceMonitorCallbackResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FaceMonitorCallbackResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FaceMonitorCallbackResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CookiesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CookiesRequest) */ {
 public:
  inline CookiesRequest() : CookiesRequest(nullptr) {}
  ~CookiesRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CookiesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CookiesRequest(const CookiesRequest& from) : CookiesRequest(nullptr, from) {}
  inline CookiesRequest(CookiesRequest&& from) noexcept
      : CookiesRequest(nullptr, std::move(from)) {}
  inline CookiesRequest& operator=(const CookiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CookiesRequest& operator=(CookiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CookiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CookiesRequest* internal_default_instance() {
    return reinterpret_cast<const CookiesRequest*>(
        &_CookiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(CookiesRequest& a, CookiesRequest& b) { a.Swap(&b); }
  inline void Swap(CookiesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CookiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CookiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CookiesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CookiesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CookiesRequest& from) { CookiesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CookiesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CookiesRequest"; }

 protected:
  explicit CookiesRequest(::google::protobuf::Arena* arena);
  CookiesRequest(::google::protobuf::Arena* arena, const CookiesRequest& from);
  CookiesRequest(::google::protobuf::Arena* arena, CookiesRequest&& from) noexcept
      : CookiesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCookiesFieldNumber = 1,
  };
  // repeated .message.Cookie cookies = 1;
  int cookies_size() const;
  private:
  int _internal_cookies_size() const;

  public:
  void clear_cookies() ;
  ::message::Cookie* mutable_cookies(int index);
  ::google::protobuf::RepeatedPtrField<::message::Cookie>* mutable_cookies();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::Cookie>& _internal_cookies() const;
  ::google::protobuf::RepeatedPtrField<::message::Cookie>* _internal_mutable_cookies();
  public:
  const ::message::Cookie& cookies(int index) const;
  ::message::Cookie* add_cookies();
  const ::google::protobuf::RepeatedPtrField<::message::Cookie>& cookies() const;
  // @@protoc_insertion_point(class_scope:message.CookiesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CookiesRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CookiesRequest& from_msg);
    ::google::protobuf::RepeatedPtrField< ::message::Cookie > cookies_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CommandResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandResponse) */ {
 public:
  inline CommandResponse() : CommandResponse(nullptr) {}
  ~CommandResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandResponse(const CommandResponse& from) : CommandResponse(nullptr, from) {}
  inline CommandResponse(CommandResponse&& from) noexcept
      : CommandResponse(nullptr, std::move(from)) {}
  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResponse& operator=(CommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandResponse* internal_default_instance() {
    return reinterpret_cast<const CommandResponse*>(
        &_CommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CommandResponse& a, CommandResponse& b) { a.Swap(&b); }
  inline void Swap(CommandResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandResponse& from) { CommandResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandResponse"; }

 protected:
  explicit CommandResponse(::google::protobuf::Arena* arena);
  CommandResponse(::google::protobuf::Arena* arena, const CommandResponse& from);
  CommandResponse(::google::protobuf::Arena* arena, CommandResponse&& from) noexcept
      : CommandResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:message.CommandResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TaskResponse) */ {
 public:
  inline TaskResponse() : TaskResponse(nullptr) {}
  ~TaskResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskResponse(const TaskResponse& from) : TaskResponse(nullptr, from) {}
  inline TaskResponse(TaskResponse&& from) noexcept
      : TaskResponse(nullptr, std::move(from)) {}
  inline TaskResponse& operator=(const TaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResponse& operator=(TaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResponse* internal_default_instance() {
    return reinterpret_cast<const TaskResponse*>(
        &_TaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(TaskResponse& a, TaskResponse& b) { a.Swap(&b); }
  inline void Swap(TaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskResponse& from) { TaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TaskResponse"; }

 protected:
  explicit TaskResponse(::google::protobuf::Arena* arena);
  TaskResponse(::google::protobuf::Arena* arena, const TaskResponse& from);
  TaskResponse(::google::protobuf::Arena* arena, TaskResponse&& from) noexcept
      : TaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskFieldNumber = 1,
  };
  // .message.TerminalTask task = 1;
  bool has_task() const;
  void clear_task() ;
  const ::message::TerminalTask& task() const;
  PROTOBUF_NODISCARD ::message::TerminalTask* release_task();
  ::message::TerminalTask* mutable_task();
  void set_allocated_task(::message::TerminalTask* value);
  void unsafe_arena_set_allocated_task(::message::TerminalTask* value);
  ::message::TerminalTask* unsafe_arena_release_task();

  private:
  const ::message::TerminalTask& _internal_task() const;
  ::message::TerminalTask* _internal_mutable_task();

  public:
  // @@protoc_insertion_point(class_scope:message.TaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TaskResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::TerminalTask* task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PortInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PortInfo) */ {
 public:
  inline PortInfo() : PortInfo(nullptr) {}
  ~PortInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortInfo(const PortInfo& from) : PortInfo(nullptr, from) {}
  inline PortInfo(PortInfo&& from) noexcept
      : PortInfo(nullptr, std::move(from)) {}
  inline PortInfo& operator=(const PortInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortInfo& operator=(PortInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortInfo* internal_default_instance() {
    return reinterpret_cast<const PortInfo*>(
        &_PortInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(PortInfo& a, PortInfo& b) { a.Swap(&b); }
  inline void Swap(PortInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortInfo& from) { PortInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PortInfo"; }

 protected:
  explicit PortInfo(::google::protobuf::Arena* arena);
  PortInfo(::google::protobuf::Arena* arena, const PortInfo& from);
  PortInfo(::google::protobuf::Arena* arena, PortInfo&& from) noexcept
      : PortInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGatewaysFieldNumber = 2,
    kAssetFieldNumber = 1,
  };
  // repeated .message.Gateway gateways = 2;
  int gateways_size() const;
  private:
  int _internal_gateways_size() const;

  public:
  void clear_gateways() ;
  ::message::Gateway* mutable_gateways(int index);
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* mutable_gateways();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& _internal_gateways() const;
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* _internal_mutable_gateways();
  public:
  const ::message::Gateway& gateways(int index) const;
  ::message::Gateway* add_gateways();
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& gateways() const;
  // .message.Asset asset = 1;
  bool has_asset() const;
  void clear_asset() ;
  const ::message::Asset& asset() const;
  PROTOBUF_NODISCARD ::message::Asset* release_asset();
  ::message::Asset* mutable_asset();
  void set_allocated_asset(::message::Asset* value);
  void unsafe_arena_set_allocated_asset(::message::Asset* value);
  ::message::Asset* unsafe_arena_release_asset();

  private:
  const ::message::Asset& _internal_asset() const;
  ::message::Asset* _internal_mutable_asset();

  public:
  // @@protoc_insertion_point(class_scope:message.PortInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::message::Gateway > gateways_;
    ::message::Asset* asset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class CommandConfirmResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandConfirmResponse) */ {
 public:
  inline CommandConfirmResponse() : CommandConfirmResponse(nullptr) {}
  ~CommandConfirmResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConfirmResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandConfirmResponse(const CommandConfirmResponse& from) : CommandConfirmResponse(nullptr, from) {}
  inline CommandConfirmResponse(CommandConfirmResponse&& from) noexcept
      : CommandConfirmResponse(nullptr, std::move(from)) {}
  inline CommandConfirmResponse& operator=(const CommandConfirmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConfirmResponse& operator=(CommandConfirmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandConfirmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConfirmResponse* internal_default_instance() {
    return reinterpret_cast<const CommandConfirmResponse*>(
        &_CommandConfirmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(CommandConfirmResponse& a, CommandConfirmResponse& b) { a.Swap(&b); }
  inline void Swap(CommandConfirmResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConfirmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConfirmResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandConfirmResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandConfirmResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandConfirmResponse& from) { CommandConfirmResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConfirmResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandConfirmResponse"; }

 protected:
  explicit CommandConfirmResponse(::google::protobuf::Arena* arena);
  CommandConfirmResponse(::google::protobuf::Arena* arena, const CommandConfirmResponse& from);
  CommandConfirmResponse(::google::protobuf::Arena* arena, CommandConfirmResponse&& from) noexcept
      : CommandConfirmResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.TicketInfo info = 2;
  bool has_info() const;
  void clear_info() ;
  const ::message::TicketInfo& info() const;
  PROTOBUF_NODISCARD ::message::TicketInfo* release_info();
  ::message::TicketInfo* mutable_info();
  void set_allocated_info(::message::TicketInfo* value);
  void unsafe_arena_set_allocated_info(::message::TicketInfo* value);
  ::message::TicketInfo* unsafe_arena_release_info();

  private:
  const ::message::TicketInfo& _internal_info() const;
  ::message::TicketInfo* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:message.CommandConfirmResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandConfirmResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandConfirmResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::TicketInfo* info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class AssetLoginTicketResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.AssetLoginTicketResponse) */ {
 public:
  inline AssetLoginTicketResponse() : AssetLoginTicketResponse(nullptr) {}
  ~AssetLoginTicketResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssetLoginTicketResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssetLoginTicketResponse(const AssetLoginTicketResponse& from) : AssetLoginTicketResponse(nullptr, from) {}
  inline AssetLoginTicketResponse(AssetLoginTicketResponse&& from) noexcept
      : AssetLoginTicketResponse(nullptr, std::move(from)) {}
  inline AssetLoginTicketResponse& operator=(const AssetLoginTicketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetLoginTicketResponse& operator=(AssetLoginTicketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetLoginTicketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetLoginTicketResponse* internal_default_instance() {
    return reinterpret_cast<const AssetLoginTicketResponse*>(
        &_AssetLoginTicketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AssetLoginTicketResponse& a, AssetLoginTicketResponse& b) { a.Swap(&b); }
  inline void Swap(AssetLoginTicketResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetLoginTicketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetLoginTicketResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssetLoginTicketResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssetLoginTicketResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssetLoginTicketResponse& from) { AssetLoginTicketResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssetLoginTicketResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.AssetLoginTicketResponse"; }

 protected:
  explicit AssetLoginTicketResponse(::google::protobuf::Arena* arena);
  AssetLoginTicketResponse(::google::protobuf::Arena* arena, const AssetLoginTicketResponse& from);
  AssetLoginTicketResponse(::google::protobuf::Arena* arena, AssetLoginTicketResponse&& from) noexcept
      : AssetLoginTicketResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTicketIdFieldNumber = 4,
    kStatusFieldNumber = 1,
    kTicketInfoFieldNumber = 2,
    kNeedConfirmFieldNumber = 3,
  };
  // string ticket_id = 4;
  void clear_ticket_id() ;
  const std::string& ticket_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticket_id(Arg_&& arg, Args_... args);
  std::string* mutable_ticket_id();
  PROTOBUF_NODISCARD std::string* release_ticket_id();
  void set_allocated_ticket_id(std::string* value);

  private:
  const std::string& _internal_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_id(
      const std::string& value);
  std::string* _internal_mutable_ticket_id();

  public:
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.TicketInfo ticket_info = 2;
  bool has_ticket_info() const;
  void clear_ticket_info() ;
  const ::message::TicketInfo& ticket_info() const;
  PROTOBUF_NODISCARD ::message::TicketInfo* release_ticket_info();
  ::message::TicketInfo* mutable_ticket_info();
  void set_allocated_ticket_info(::message::TicketInfo* value);
  void unsafe_arena_set_allocated_ticket_info(::message::TicketInfo* value);
  ::message::TicketInfo* unsafe_arena_release_ticket_info();

  private:
  const ::message::TicketInfo& _internal_ticket_info() const;
  ::message::TicketInfo* _internal_mutable_ticket_info();

  public:
  // bool need_confirm = 3;
  void clear_need_confirm() ;
  bool need_confirm() const;
  void set_need_confirm(bool value);

  private:
  bool _internal_need_confirm() const;
  void _internal_set_need_confirm(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.AssetLoginTicketResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      50, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssetLoginTicketResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssetLoginTicketResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ticket_id_;
    ::message::Status* status_;
    ::message::TicketInfo* ticket_info_;
    bool need_confirm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class PortInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PortInfoResponse) */ {
 public:
  inline PortInfoResponse() : PortInfoResponse(nullptr) {}
  ~PortInfoResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortInfoResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PortInfoResponse(const PortInfoResponse& from) : PortInfoResponse(nullptr, from) {}
  inline PortInfoResponse(PortInfoResponse&& from) noexcept
      : PortInfoResponse(nullptr, std::move(from)) {}
  inline PortInfoResponse& operator=(const PortInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortInfoResponse& operator=(PortInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortInfoResponse* internal_default_instance() {
    return reinterpret_cast<const PortInfoResponse*>(
        &_PortInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(PortInfoResponse& a, PortInfoResponse& b) { a.Swap(&b); }
  inline void Swap(PortInfoResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PortInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortInfoResponse& from) { PortInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortInfoResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PortInfoResponse"; }

 protected:
  explicit PortInfoResponse(::google::protobuf::Arena* arena);
  PortInfoResponse(::google::protobuf::Arena* arena, const PortInfoResponse& from);
  PortInfoResponse(::google::protobuf::Arena* arena, PortInfoResponse&& from) noexcept
      : PortInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.PortInfo data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::message::PortInfo& data() const;
  PROTOBUF_NODISCARD ::message::PortInfo* release_data();
  ::message::PortInfo* mutable_data();
  void set_allocated_data(::message::PortInfo* value);
  void unsafe_arena_set_allocated_data(::message::PortInfo* value);
  ::message::PortInfo* unsafe_arena_release_data();

  private:
  const ::message::PortInfo& _internal_data() const;
  ::message::PortInfo* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.PortInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PortInfoResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PortInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::PortInfo* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TokenResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TokenResponse) */ {
 public:
  inline TokenResponse() : TokenResponse(nullptr) {}
  ~TokenResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TokenResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TokenResponse(const TokenResponse& from) : TokenResponse(nullptr, from) {}
  inline TokenResponse(TokenResponse&& from) noexcept
      : TokenResponse(nullptr, std::move(from)) {}
  inline TokenResponse& operator=(const TokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenResponse& operator=(TokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenResponse* internal_default_instance() {
    return reinterpret_cast<const TokenResponse*>(
        &_TokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(TokenResponse& a, TokenResponse& b) { a.Swap(&b); }
  inline void Swap(TokenResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TokenResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TokenResponse& from) { TokenResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TokenResponse"; }

 protected:
  explicit TokenResponse(::google::protobuf::Arena* arena);
  TokenResponse(::google::protobuf::Arena* arena, const TokenResponse& from);
  TokenResponse(::google::protobuf::Arena* arena, TokenResponse&& from) noexcept
      : TokenResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .message.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::message::Status& status() const;
  PROTOBUF_NODISCARD ::message::Status* release_status();
  ::message::Status* mutable_status();
  void set_allocated_status(::message::Status* value);
  void unsafe_arena_set_allocated_status(::message::Status* value);
  ::message::Status* unsafe_arena_release_status();

  private:
  const ::message::Status& _internal_status() const;
  ::message::Status* _internal_mutable_status();

  public:
  // .message.TokenAuthInfo data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::message::TokenAuthInfo& data() const;
  PROTOBUF_NODISCARD ::message::TokenAuthInfo* release_data();
  ::message::TokenAuthInfo* mutable_data();
  void set_allocated_data(::message::TokenAuthInfo* value);
  void unsafe_arena_set_allocated_data(::message::TokenAuthInfo* value);
  ::message::TokenAuthInfo* unsafe_arena_release_data();

  private:
  const ::message::TokenAuthInfo& _internal_data() const;
  ::message::TokenAuthInfo* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:message.TokenResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TokenResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TokenResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::message::Status* status_;
    ::message::TokenAuthInfo* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// JoinFaceMonitorRequest

// string face_monitor_token = 1;
inline void JoinFaceMonitorRequest::clear_face_monitor_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_monitor_token_.ClearToEmpty();
}
inline const std::string& JoinFaceMonitorRequest::face_monitor_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.JoinFaceMonitorRequest.face_monitor_token)
  return _internal_face_monitor_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JoinFaceMonitorRequest::set_face_monitor_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_monitor_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.JoinFaceMonitorRequest.face_monitor_token)
}
inline std::string* JoinFaceMonitorRequest::mutable_face_monitor_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_face_monitor_token();
  // @@protoc_insertion_point(field_mutable:message.JoinFaceMonitorRequest.face_monitor_token)
  return _s;
}
inline const std::string& JoinFaceMonitorRequest::_internal_face_monitor_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.face_monitor_token_.Get();
}
inline void JoinFaceMonitorRequest::_internal_set_face_monitor_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_monitor_token_.Set(value, GetArena());
}
inline std::string* JoinFaceMonitorRequest::_internal_mutable_face_monitor_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.face_monitor_token_.Mutable( GetArena());
}
inline std::string* JoinFaceMonitorRequest::release_face_monitor_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.JoinFaceMonitorRequest.face_monitor_token)
  return _impl_.face_monitor_token_.Release();
}
inline void JoinFaceMonitorRequest::set_allocated_face_monitor_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_monitor_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.face_monitor_token_.IsDefault()) {
          _impl_.face_monitor_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.JoinFaceMonitorRequest.face_monitor_token)
}

// string session_id = 2;
inline void JoinFaceMonitorRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& JoinFaceMonitorRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.JoinFaceMonitorRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JoinFaceMonitorRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.JoinFaceMonitorRequest.session_id)
}
inline std::string* JoinFaceMonitorRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:message.JoinFaceMonitorRequest.session_id)
  return _s;
}
inline const std::string& JoinFaceMonitorRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void JoinFaceMonitorRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* JoinFaceMonitorRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* JoinFaceMonitorRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.JoinFaceMonitorRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void JoinFaceMonitorRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.JoinFaceMonitorRequest.session_id)
}

// -------------------------------------------------------------------

// JoinFaceMonitorResponse

// .message.Status status = 1;
inline bool JoinFaceMonitorResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void JoinFaceMonitorResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& JoinFaceMonitorResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& JoinFaceMonitorResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.JoinFaceMonitorResponse.status)
  return _internal_status();
}
inline void JoinFaceMonitorResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.JoinFaceMonitorResponse.status)
}
inline ::message::Status* JoinFaceMonitorResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* JoinFaceMonitorResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.JoinFaceMonitorResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* JoinFaceMonitorResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* JoinFaceMonitorResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.JoinFaceMonitorResponse.status)
  return _msg;
}
inline void JoinFaceMonitorResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.JoinFaceMonitorResponse.status)
}

// -------------------------------------------------------------------

// FaceMonitorCallbackRequest

// string token = 1;
inline void FaceMonitorCallbackRequest::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& FaceMonitorCallbackRequest::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceMonitorCallbackRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.token)
}
inline std::string* FaceMonitorCallbackRequest::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:message.FaceMonitorCallbackRequest.token)
  return _s;
}
inline const std::string& FaceMonitorCallbackRequest::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void FaceMonitorCallbackRequest::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* FaceMonitorCallbackRequest::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* FaceMonitorCallbackRequest::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceMonitorCallbackRequest.token)
  return _impl_.token_.Release();
}
inline void FaceMonitorCallbackRequest::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceMonitorCallbackRequest.token)
}

// bool success = 2;
inline void FaceMonitorCallbackRequest::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool FaceMonitorCallbackRequest::success() const {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.success)
  return _internal_success();
}
inline void FaceMonitorCallbackRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.success)
}
inline bool FaceMonitorCallbackRequest::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void FaceMonitorCallbackRequest::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error_message = 3;
inline void FaceMonitorCallbackRequest::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& FaceMonitorCallbackRequest::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceMonitorCallbackRequest::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.error_message)
}
inline std::string* FaceMonitorCallbackRequest::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:message.FaceMonitorCallbackRequest.error_message)
  return _s;
}
inline const std::string& FaceMonitorCallbackRequest::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void FaceMonitorCallbackRequest::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* FaceMonitorCallbackRequest::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* FaceMonitorCallbackRequest::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceMonitorCallbackRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void FaceMonitorCallbackRequest::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceMonitorCallbackRequest.error_message)
}

// bool is_finished = 4;
inline void FaceMonitorCallbackRequest::clear_is_finished() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_finished_ = false;
}
inline bool FaceMonitorCallbackRequest::is_finished() const {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.is_finished)
  return _internal_is_finished();
}
inline void FaceMonitorCallbackRequest::set_is_finished(bool value) {
  _internal_set_is_finished(value);
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.is_finished)
}
inline bool FaceMonitorCallbackRequest::_internal_is_finished() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_finished_;
}
inline void FaceMonitorCallbackRequest::_internal_set_is_finished(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_finished_ = value;
}

// string action = 5;
inline void FaceMonitorCallbackRequest::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
}
inline const std::string& FaceMonitorCallbackRequest::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceMonitorCallbackRequest::set_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.action)
}
inline std::string* FaceMonitorCallbackRequest::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:message.FaceMonitorCallbackRequest.action)
  return _s;
}
inline const std::string& FaceMonitorCallbackRequest::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void FaceMonitorCallbackRequest::_internal_set_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(value, GetArena());
}
inline std::string* FaceMonitorCallbackRequest::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_.Mutable( GetArena());
}
inline std::string* FaceMonitorCallbackRequest::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceMonitorCallbackRequest.action)
  return _impl_.action_.Release();
}
inline void FaceMonitorCallbackRequest::set_allocated_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_.IsDefault()) {
          _impl_.action_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceMonitorCallbackRequest.action)
}

// repeated string face_codes = 6;
inline int FaceMonitorCallbackRequest::_internal_face_codes_size() const {
  return _internal_face_codes().size();
}
inline int FaceMonitorCallbackRequest::face_codes_size() const {
  return _internal_face_codes_size();
}
inline void FaceMonitorCallbackRequest::clear_face_codes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_codes_.Clear();
}
inline std::string* FaceMonitorCallbackRequest::add_face_codes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_face_codes()->Add();
  // @@protoc_insertion_point(field_add_mutable:message.FaceMonitorCallbackRequest.face_codes)
  return _s;
}
inline const std::string& FaceMonitorCallbackRequest::face_codes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackRequest.face_codes)
  return _internal_face_codes().Get(index);
}
inline std::string* FaceMonitorCallbackRequest::mutable_face_codes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.FaceMonitorCallbackRequest.face_codes)
  return _internal_mutable_face_codes()->Mutable(index);
}
inline void FaceMonitorCallbackRequest::set_face_codes(int index, const std::string& value) {
  _internal_mutable_face_codes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::set_face_codes(int index, std::string&& value) {
  _internal_mutable_face_codes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::set_face_codes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_face_codes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::set_face_codes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_face_codes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::set_face_codes(int index, absl::string_view value) {
  _internal_mutable_face_codes()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::add_face_codes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_face_codes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::add_face_codes(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_face_codes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::add_face_codes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_face_codes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::add_face_codes(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_face_codes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message.FaceMonitorCallbackRequest.face_codes)
}
inline void FaceMonitorCallbackRequest::add_face_codes(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_face_codes()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:message.FaceMonitorCallbackRequest.face_codes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FaceMonitorCallbackRequest::face_codes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.FaceMonitorCallbackRequest.face_codes)
  return _internal_face_codes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FaceMonitorCallbackRequest::mutable_face_codes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.FaceMonitorCallbackRequest.face_codes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_face_codes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FaceMonitorCallbackRequest::_internal_face_codes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.face_codes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FaceMonitorCallbackRequest::_internal_mutable_face_codes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.face_codes_;
}

// -------------------------------------------------------------------

// FaceMonitorCallbackResponse

// .message.Status status = 1;
inline bool FaceMonitorCallbackResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void FaceMonitorCallbackResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& FaceMonitorCallbackResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& FaceMonitorCallbackResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceMonitorCallbackResponse.status)
  return _internal_status();
}
inline void FaceMonitorCallbackResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.FaceMonitorCallbackResponse.status)
}
inline ::message::Status* FaceMonitorCallbackResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* FaceMonitorCallbackResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceMonitorCallbackResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* FaceMonitorCallbackResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* FaceMonitorCallbackResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.FaceMonitorCallbackResponse.status)
  return _msg;
}
inline void FaceMonitorCallbackResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.FaceMonitorCallbackResponse.status)
}

// -------------------------------------------------------------------

// FaceRecognitionCallbackRequest

// string token = 1;
inline void FaceRecognitionCallbackRequest::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& FaceRecognitionCallbackRequest::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceRecognitionCallbackRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceRecognitionCallbackRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceRecognitionCallbackRequest.token)
}
inline std::string* FaceRecognitionCallbackRequest::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:message.FaceRecognitionCallbackRequest.token)
  return _s;
}
inline const std::string& FaceRecognitionCallbackRequest::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void FaceRecognitionCallbackRequest::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceRecognitionCallbackRequest.token)
  return _impl_.token_.Release();
}
inline void FaceRecognitionCallbackRequest::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceRecognitionCallbackRequest.token)
}

// bool success = 2;
inline void FaceRecognitionCallbackRequest::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool FaceRecognitionCallbackRequest::success() const {
  // @@protoc_insertion_point(field_get:message.FaceRecognitionCallbackRequest.success)
  return _internal_success();
}
inline void FaceRecognitionCallbackRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:message.FaceRecognitionCallbackRequest.success)
}
inline bool FaceRecognitionCallbackRequest::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void FaceRecognitionCallbackRequest::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string error_message = 3;
inline void FaceRecognitionCallbackRequest::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& FaceRecognitionCallbackRequest::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceRecognitionCallbackRequest.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceRecognitionCallbackRequest::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceRecognitionCallbackRequest.error_message)
}
inline std::string* FaceRecognitionCallbackRequest::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:message.FaceRecognitionCallbackRequest.error_message)
  return _s;
}
inline const std::string& FaceRecognitionCallbackRequest::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void FaceRecognitionCallbackRequest::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceRecognitionCallbackRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void FaceRecognitionCallbackRequest::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceRecognitionCallbackRequest.error_message)
}

// string face_code = 4;
inline void FaceRecognitionCallbackRequest::clear_face_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_code_.ClearToEmpty();
}
inline const std::string& FaceRecognitionCallbackRequest::face_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceRecognitionCallbackRequest.face_code)
  return _internal_face_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FaceRecognitionCallbackRequest::set_face_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FaceRecognitionCallbackRequest.face_code)
}
inline std::string* FaceRecognitionCallbackRequest::mutable_face_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_face_code();
  // @@protoc_insertion_point(field_mutable:message.FaceRecognitionCallbackRequest.face_code)
  return _s;
}
inline const std::string& FaceRecognitionCallbackRequest::_internal_face_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.face_code_.Get();
}
inline void FaceRecognitionCallbackRequest::_internal_set_face_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_code_.Set(value, GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::_internal_mutable_face_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.face_code_.Mutable( GetArena());
}
inline std::string* FaceRecognitionCallbackRequest::release_face_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceRecognitionCallbackRequest.face_code)
  return _impl_.face_code_.Release();
}
inline void FaceRecognitionCallbackRequest::set_allocated_face_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.face_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.face_code_.IsDefault()) {
          _impl_.face_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FaceRecognitionCallbackRequest.face_code)
}

// -------------------------------------------------------------------

// FaceRecognitionCallbackResponse

// .message.Status status = 1;
inline bool FaceRecognitionCallbackResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void FaceRecognitionCallbackResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& FaceRecognitionCallbackResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& FaceRecognitionCallbackResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FaceRecognitionCallbackResponse.status)
  return _internal_status();
}
inline void FaceRecognitionCallbackResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.FaceRecognitionCallbackResponse.status)
}
inline ::message::Status* FaceRecognitionCallbackResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* FaceRecognitionCallbackResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FaceRecognitionCallbackResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* FaceRecognitionCallbackResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* FaceRecognitionCallbackResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.FaceRecognitionCallbackResponse.status)
  return _msg;
}
inline void FaceRecognitionCallbackResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.FaceRecognitionCallbackResponse.status)
}

// -------------------------------------------------------------------

// AssetLoginTicketRequest

// string user_id = 1;
inline void AssetLoginTicketRequest::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AssetLoginTicketRequest::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketRequest.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssetLoginTicketRequest::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.AssetLoginTicketRequest.user_id)
}
inline std::string* AssetLoginTicketRequest::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketRequest.user_id)
  return _s;
}
inline const std::string& AssetLoginTicketRequest::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void AssetLoginTicketRequest::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* AssetLoginTicketRequest::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* AssetLoginTicketRequest::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketRequest.user_id)
  return _impl_.user_id_.Release();
}
inline void AssetLoginTicketRequest::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketRequest.user_id)
}

// string asset_id = 2;
inline void AssetLoginTicketRequest::clear_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& AssetLoginTicketRequest::asset_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketRequest.asset_id)
  return _internal_asset_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssetLoginTicketRequest::set_asset_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.AssetLoginTicketRequest.asset_id)
}
inline std::string* AssetLoginTicketRequest::mutable_asset_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketRequest.asset_id)
  return _s;
}
inline const std::string& AssetLoginTicketRequest::_internal_asset_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_id_.Get();
}
inline void AssetLoginTicketRequest::_internal_set_asset_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.Set(value, GetArena());
}
inline std::string* AssetLoginTicketRequest::_internal_mutable_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.asset_id_.Mutable( GetArena());
}
inline std::string* AssetLoginTicketRequest::release_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketRequest.asset_id)
  return _impl_.asset_id_.Release();
}
inline void AssetLoginTicketRequest::set_allocated_asset_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.asset_id_.IsDefault()) {
          _impl_.asset_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketRequest.asset_id)
}

// string account_username = 4;
inline void AssetLoginTicketRequest::clear_account_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_username_.ClearToEmpty();
}
inline const std::string& AssetLoginTicketRequest::account_username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketRequest.account_username)
  return _internal_account_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssetLoginTicketRequest::set_account_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.AssetLoginTicketRequest.account_username)
}
inline std::string* AssetLoginTicketRequest::mutable_account_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_username();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketRequest.account_username)
  return _s;
}
inline const std::string& AssetLoginTicketRequest::_internal_account_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_username_.Get();
}
inline void AssetLoginTicketRequest::_internal_set_account_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_username_.Set(value, GetArena());
}
inline std::string* AssetLoginTicketRequest::_internal_mutable_account_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_username_.Mutable( GetArena());
}
inline std::string* AssetLoginTicketRequest::release_account_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketRequest.account_username)
  return _impl_.account_username_.Release();
}
inline void AssetLoginTicketRequest::set_allocated_account_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_username_.IsDefault()) {
          _impl_.account_username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketRequest.account_username)
}

// -------------------------------------------------------------------

// AssetLoginTicketResponse

// .message.Status status = 1;
inline bool AssetLoginTicketResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void AssetLoginTicketResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& AssetLoginTicketResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& AssetLoginTicketResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketResponse.status)
  return _internal_status();
}
inline void AssetLoginTicketResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.AssetLoginTicketResponse.status)
}
inline ::message::Status* AssetLoginTicketResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* AssetLoginTicketResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* AssetLoginTicketResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* AssetLoginTicketResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketResponse.status)
  return _msg;
}
inline void AssetLoginTicketResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketResponse.status)
}

// .message.TicketInfo ticket_info = 2;
inline bool AssetLoginTicketResponse::has_ticket_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ticket_info_ != nullptr);
  return value;
}
inline void AssetLoginTicketResponse::clear_ticket_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ticket_info_ != nullptr) _impl_.ticket_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::TicketInfo& AssetLoginTicketResponse::_internal_ticket_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TicketInfo* p = _impl_.ticket_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TicketInfo&>(::message::_TicketInfo_default_instance_);
}
inline const ::message::TicketInfo& AssetLoginTicketResponse::ticket_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketResponse.ticket_info)
  return _internal_ticket_info();
}
inline void AssetLoginTicketResponse::unsafe_arena_set_allocated_ticket_info(::message::TicketInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ticket_info_);
  }
  _impl_.ticket_info_ = reinterpret_cast<::message::TicketInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.AssetLoginTicketResponse.ticket_info)
}
inline ::message::TicketInfo* AssetLoginTicketResponse::release_ticket_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TicketInfo* released = _impl_.ticket_info_;
  _impl_.ticket_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TicketInfo* AssetLoginTicketResponse::unsafe_arena_release_ticket_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketResponse.ticket_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TicketInfo* temp = _impl_.ticket_info_;
  _impl_.ticket_info_ = nullptr;
  return temp;
}
inline ::message::TicketInfo* AssetLoginTicketResponse::_internal_mutable_ticket_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ticket_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TicketInfo>(GetArena());
    _impl_.ticket_info_ = reinterpret_cast<::message::TicketInfo*>(p);
  }
  return _impl_.ticket_info_;
}
inline ::message::TicketInfo* AssetLoginTicketResponse::mutable_ticket_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::TicketInfo* _msg = _internal_mutable_ticket_info();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketResponse.ticket_info)
  return _msg;
}
inline void AssetLoginTicketResponse::set_allocated_ticket_info(::message::TicketInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ticket_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ticket_info_ = reinterpret_cast<::message::TicketInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketResponse.ticket_info)
}

// bool need_confirm = 3;
inline void AssetLoginTicketResponse::clear_need_confirm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.need_confirm_ = false;
}
inline bool AssetLoginTicketResponse::need_confirm() const {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketResponse.need_confirm)
  return _internal_need_confirm();
}
inline void AssetLoginTicketResponse::set_need_confirm(bool value) {
  _internal_set_need_confirm(value);
  // @@protoc_insertion_point(field_set:message.AssetLoginTicketResponse.need_confirm)
}
inline bool AssetLoginTicketResponse::_internal_need_confirm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.need_confirm_;
}
inline void AssetLoginTicketResponse::_internal_set_need_confirm(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.need_confirm_ = value;
}

// string ticket_id = 4;
inline void AssetLoginTicketResponse::clear_ticket_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_id_.ClearToEmpty();
}
inline const std::string& AssetLoginTicketResponse::ticket_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.AssetLoginTicketResponse.ticket_id)
  return _internal_ticket_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssetLoginTicketResponse::set_ticket_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.AssetLoginTicketResponse.ticket_id)
}
inline std::string* AssetLoginTicketResponse::mutable_ticket_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ticket_id();
  // @@protoc_insertion_point(field_mutable:message.AssetLoginTicketResponse.ticket_id)
  return _s;
}
inline const std::string& AssetLoginTicketResponse::_internal_ticket_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ticket_id_.Get();
}
inline void AssetLoginTicketResponse::_internal_set_ticket_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_id_.Set(value, GetArena());
}
inline std::string* AssetLoginTicketResponse::_internal_mutable_ticket_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ticket_id_.Mutable( GetArena());
}
inline std::string* AssetLoginTicketResponse::release_ticket_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.AssetLoginTicketResponse.ticket_id)
  return _impl_.ticket_id_.Release();
}
inline void AssetLoginTicketResponse::set_allocated_ticket_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticket_id_.IsDefault()) {
          _impl_.ticket_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.AssetLoginTicketResponse.ticket_id)
}

// -------------------------------------------------------------------

// Status

// bool ok = 1;
inline void Status::clear_ok() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ok_ = false;
}
inline bool Status::ok() const {
  // @@protoc_insertion_point(field_get:message.Status.ok)
  return _internal_ok();
}
inline void Status::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:message.Status.ok)
}
inline bool Status::_internal_ok() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ok_;
}
inline void Status::_internal_set_ok(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ok_ = value;
}

// string err = 2;
inline void Status::clear_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.ClearToEmpty();
}
inline const std::string& Status::err() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Status.err)
  return _internal_err();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_err(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Status.err)
}
inline std::string* Status::mutable_err() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:message.Status.err)
  return _s;
}
inline const std::string& Status::_internal_err() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.err_.Get();
}
inline void Status::_internal_set_err(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.err_.Mutable( GetArena());
}
inline std::string* Status::release_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Status.err)
  return _impl_.err_.Release();
}
inline void Status::set_allocated_err(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.err_.IsDefault()) {
          _impl_.err_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Status.err)
}

// -------------------------------------------------------------------

// TokenRequest

// string token = 1;
inline void TokenRequest::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& TokenRequest::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenRequest.token)
}
inline std::string* TokenRequest::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:message.TokenRequest.token)
  return _s;
}
inline const std::string& TokenRequest::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void TokenRequest::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* TokenRequest::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* TokenRequest::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenRequest.token)
  return _impl_.token_.Release();
}
inline void TokenRequest::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenRequest.token)
}

// -------------------------------------------------------------------

// TokenResponse

// .message.Status status = 1;
inline bool TokenResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void TokenResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& TokenResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& TokenResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenResponse.status)
  return _internal_status();
}
inline void TokenResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenResponse.status)
}
inline ::message::Status* TokenResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* TokenResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* TokenResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* TokenResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.TokenResponse.status)
  return _msg;
}
inline void TokenResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenResponse.status)
}

// .message.TokenAuthInfo data = 2;
inline bool TokenResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::message::TokenAuthInfo& TokenResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TokenAuthInfo* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TokenAuthInfo&>(::message::_TokenAuthInfo_default_instance_);
}
inline const ::message::TokenAuthInfo& TokenResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenResponse.data)
  return _internal_data();
}
inline void TokenResponse::unsafe_arena_set_allocated_data(::message::TokenAuthInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::TokenAuthInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenResponse.data)
}
inline ::message::TokenAuthInfo* TokenResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TokenAuthInfo* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TokenAuthInfo* TokenResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TokenAuthInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::TokenAuthInfo* TokenResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TokenAuthInfo>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::TokenAuthInfo*>(p);
  }
  return _impl_.data_;
}
inline ::message::TokenAuthInfo* TokenResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::TokenAuthInfo* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.TokenResponse.data)
  return _msg;
}
inline void TokenResponse::set_allocated_data(::message::TokenAuthInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::message::TokenAuthInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenResponse.data)
}

// -------------------------------------------------------------------

// SessionCreateRequest

// .message.Session data = 1;
inline bool SessionCreateRequest::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::message::Session& SessionCreateRequest::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Session* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Session&>(::message::_Session_default_instance_);
}
inline const ::message::Session& SessionCreateRequest::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionCreateRequest.data)
  return _internal_data();
}
inline void SessionCreateRequest::unsafe_arena_set_allocated_data(::message::Session* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::Session*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.SessionCreateRequest.data)
}
inline ::message::Session* SessionCreateRequest::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Session* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Session* SessionCreateRequest::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionCreateRequest.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Session* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::Session* SessionCreateRequest::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Session>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::Session*>(p);
  }
  return _impl_.data_;
}
inline ::message::Session* SessionCreateRequest::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Session* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.SessionCreateRequest.data)
  return _msg;
}
inline void SessionCreateRequest::set_allocated_data(::message::Session* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::message::Session*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.SessionCreateRequest.data)
}

// -------------------------------------------------------------------

// SessionCreateResponse

// .message.Status status = 1;
inline bool SessionCreateResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void SessionCreateResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& SessionCreateResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& SessionCreateResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionCreateResponse.status)
  return _internal_status();
}
inline void SessionCreateResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.SessionCreateResponse.status)
}
inline ::message::Status* SessionCreateResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* SessionCreateResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionCreateResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* SessionCreateResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* SessionCreateResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.SessionCreateResponse.status)
  return _msg;
}
inline void SessionCreateResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.SessionCreateResponse.status)
}

// .message.Session data = 2;
inline bool SessionCreateResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::message::Session& SessionCreateResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Session* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Session&>(::message::_Session_default_instance_);
}
inline const ::message::Session& SessionCreateResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionCreateResponse.data)
  return _internal_data();
}
inline void SessionCreateResponse::unsafe_arena_set_allocated_data(::message::Session* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::Session*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.SessionCreateResponse.data)
}
inline ::message::Session* SessionCreateResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::Session* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Session* SessionCreateResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionCreateResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::Session* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::Session* SessionCreateResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Session>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::Session*>(p);
  }
  return _impl_.data_;
}
inline ::message::Session* SessionCreateResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::Session* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.SessionCreateResponse.data)
  return _msg;
}
inline void SessionCreateResponse::set_allocated_data(::message::Session* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::message::Session*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.SessionCreateResponse.data)
}

// -------------------------------------------------------------------

// SessionFinishRequest

// string id = 1;
inline void SessionFinishRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SessionFinishRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionFinishRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionFinishRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SessionFinishRequest.id)
}
inline std::string* SessionFinishRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.SessionFinishRequest.id)
  return _s;
}
inline const std::string& SessionFinishRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void SessionFinishRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* SessionFinishRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* SessionFinishRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionFinishRequest.id)
  return _impl_.id_.Release();
}
inline void SessionFinishRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SessionFinishRequest.id)
}

// bool success = 2;
inline void SessionFinishRequest::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool SessionFinishRequest::success() const {
  // @@protoc_insertion_point(field_get:message.SessionFinishRequest.success)
  return _internal_success();
}
inline void SessionFinishRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:message.SessionFinishRequest.success)
}
inline bool SessionFinishRequest::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void SessionFinishRequest::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// int64 date_end = 3;
inline void SessionFinishRequest::clear_date_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_end_ = ::int64_t{0};
}
inline ::int64_t SessionFinishRequest::date_end() const {
  // @@protoc_insertion_point(field_get:message.SessionFinishRequest.date_end)
  return _internal_date_end();
}
inline void SessionFinishRequest::set_date_end(::int64_t value) {
  _internal_set_date_end(value);
  // @@protoc_insertion_point(field_set:message.SessionFinishRequest.date_end)
}
inline ::int64_t SessionFinishRequest::_internal_date_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.date_end_;
}
inline void SessionFinishRequest::_internal_set_date_end(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_end_ = value;
}

// string err = 4;
inline void SessionFinishRequest::clear_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.ClearToEmpty();
}
inline const std::string& SessionFinishRequest::err() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionFinishRequest.err)
  return _internal_err();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionFinishRequest::set_err(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SessionFinishRequest.err)
}
inline std::string* SessionFinishRequest::mutable_err() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:message.SessionFinishRequest.err)
  return _s;
}
inline const std::string& SessionFinishRequest::_internal_err() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.err_.Get();
}
inline void SessionFinishRequest::_internal_set_err(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.Set(value, GetArena());
}
inline std::string* SessionFinishRequest::_internal_mutable_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.err_.Mutable( GetArena());
}
inline std::string* SessionFinishRequest::release_err() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionFinishRequest.err)
  return _impl_.err_.Release();
}
inline void SessionFinishRequest::set_allocated_err(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.err_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.err_.IsDefault()) {
          _impl_.err_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SessionFinishRequest.err)
}

// -------------------------------------------------------------------

// SessionFinishResp

// .message.Status status = 1;
inline bool SessionFinishResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void SessionFinishResp::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& SessionFinishResp::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& SessionFinishResp::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionFinishResp.status)
  return _internal_status();
}
inline void SessionFinishResp::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.SessionFinishResp.status)
}
inline ::message::Status* SessionFinishResp::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* SessionFinishResp::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionFinishResp.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* SessionFinishResp::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* SessionFinishResp::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.SessionFinishResp.status)
  return _msg;
}
inline void SessionFinishResp::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.SessionFinishResp.status)
}

// -------------------------------------------------------------------

// ReplayRequest

// string session_id = 1;
inline void ReplayRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& ReplayRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ReplayRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplayRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ReplayRequest.session_id)
}
inline std::string* ReplayRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:message.ReplayRequest.session_id)
  return _s;
}
inline const std::string& ReplayRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void ReplayRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* ReplayRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* ReplayRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ReplayRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void ReplayRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ReplayRequest.session_id)
}

// string replay_file_path = 2;
inline void ReplayRequest::clear_replay_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_file_path_.ClearToEmpty();
}
inline const std::string& ReplayRequest::replay_file_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ReplayRequest.replay_file_path)
  return _internal_replay_file_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplayRequest::set_replay_file_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_file_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ReplayRequest.replay_file_path)
}
inline std::string* ReplayRequest::mutable_replay_file_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_replay_file_path();
  // @@protoc_insertion_point(field_mutable:message.ReplayRequest.replay_file_path)
  return _s;
}
inline const std::string& ReplayRequest::_internal_replay_file_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replay_file_path_.Get();
}
inline void ReplayRequest::_internal_set_replay_file_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_file_path_.Set(value, GetArena());
}
inline std::string* ReplayRequest::_internal_mutable_replay_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.replay_file_path_.Mutable( GetArena());
}
inline std::string* ReplayRequest::release_replay_file_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ReplayRequest.replay_file_path)
  return _impl_.replay_file_path_.Release();
}
inline void ReplayRequest::set_allocated_replay_file_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_file_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.replay_file_path_.IsDefault()) {
          _impl_.replay_file_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ReplayRequest.replay_file_path)
}

// -------------------------------------------------------------------

// ReplayResponse

// .message.Status status = 1;
inline bool ReplayResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ReplayResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& ReplayResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& ReplayResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ReplayResponse.status)
  return _internal_status();
}
inline void ReplayResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.ReplayResponse.status)
}
inline ::message::Status* ReplayResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* ReplayResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ReplayResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* ReplayResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* ReplayResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.ReplayResponse.status)
  return _msg;
}
inline void ReplayResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.ReplayResponse.status)
}

// -------------------------------------------------------------------

// CommandRequest

// string sid = 1;
inline void CommandRequest::clear_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& CommandRequest::sid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.sid)
  return _internal_sid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_sid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.sid)
}
inline std::string* CommandRequest::mutable_sid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.sid)
  return _s;
}
inline const std::string& CommandRequest::_internal_sid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sid_.Get();
}
inline void CommandRequest::_internal_set_sid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sid_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_sid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.sid)
  return _impl_.sid_.Release();
}
inline void CommandRequest::set_allocated_sid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sid_.IsDefault()) {
          _impl_.sid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.sid)
}

// string org_id = 2;
inline void CommandRequest::clear_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& CommandRequest::org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.org_id)
}
inline std::string* CommandRequest::mutable_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.org_id)
  return _s;
}
inline const std::string& CommandRequest::_internal_org_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_id_.Get();
}
inline void CommandRequest::_internal_set_org_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_id_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.org_id)
  return _impl_.org_id_.Release();
}
inline void CommandRequest::set_allocated_org_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.org_id)
}

// string input = 3;
inline void CommandRequest::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_.ClearToEmpty();
}
inline const std::string& CommandRequest::input() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.input)
  return _internal_input();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_input(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.input)
}
inline std::string* CommandRequest::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.input)
  return _s;
}
inline const std::string& CommandRequest::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_.Get();
}
inline void CommandRequest::_internal_set_input(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.input)
  return _impl_.input_.Release();
}
inline void CommandRequest::set_allocated_input(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.input_.IsDefault()) {
          _impl_.input_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.input)
}

// string output = 4;
inline void CommandRequest::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_.ClearToEmpty();
}
inline const std::string& CommandRequest::output() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.output)
  return _internal_output();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_output(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.output)
}
inline std::string* CommandRequest::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.output)
  return _s;
}
inline const std::string& CommandRequest::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_.Get();
}
inline void CommandRequest::_internal_set_output(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.output_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.output)
  return _impl_.output_.Release();
}
inline void CommandRequest::set_allocated_output(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.output_.IsDefault()) {
          _impl_.output_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.output)
}

// string user = 5;
inline void CommandRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& CommandRequest::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.user)
}
inline std::string* CommandRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.user)
  return _s;
}
inline const std::string& CommandRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void CommandRequest::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.user)
  return _impl_.user_.Release();
}
inline void CommandRequest::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.user)
}

// string asset = 6;
inline void CommandRequest::clear_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.ClearToEmpty();
}
inline const std::string& CommandRequest::asset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.asset)
  return _internal_asset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_asset(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.asset)
}
inline std::string* CommandRequest::mutable_asset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.asset)
  return _s;
}
inline const std::string& CommandRequest::_internal_asset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_.Get();
}
inline void CommandRequest::_internal_set_asset(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.asset_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.asset)
  return _impl_.asset_.Release();
}
inline void CommandRequest::set_allocated_asset(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.asset_.IsDefault()) {
          _impl_.asset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.asset)
}

// string account = 7;
inline void CommandRequest::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& CommandRequest::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.account)
}
inline std::string* CommandRequest::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.account)
  return _s;
}
inline const std::string& CommandRequest::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void CommandRequest::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.account)
  return _impl_.account_.Release();
}
inline void CommandRequest::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.account)
}

// int64 timestamp = 8;
inline void CommandRequest::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t CommandRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:message.CommandRequest.timestamp)
  return _internal_timestamp();
}
inline void CommandRequest::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:message.CommandRequest.timestamp)
}
inline ::int64_t CommandRequest::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void CommandRequest::_internal_set_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .message.RiskLevel risk_level = 9;
inline void CommandRequest::clear_risk_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.risk_level_ = 0;
}
inline ::message::RiskLevel CommandRequest::risk_level() const {
  // @@protoc_insertion_point(field_get:message.CommandRequest.risk_level)
  return _internal_risk_level();
}
inline void CommandRequest::set_risk_level(::message::RiskLevel value) {
  _internal_set_risk_level(value);
  // @@protoc_insertion_point(field_set:message.CommandRequest.risk_level)
}
inline ::message::RiskLevel CommandRequest::_internal_risk_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::RiskLevel>(_impl_.risk_level_);
}
inline void CommandRequest::_internal_set_risk_level(::message::RiskLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.risk_level_ = value;
}

// string cmd_acl_id = 10;
inline void CommandRequest::clear_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.ClearToEmpty();
}
inline const std::string& CommandRequest::cmd_acl_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.cmd_acl_id)
  return _internal_cmd_acl_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_cmd_acl_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.cmd_acl_id)
}
inline std::string* CommandRequest::mutable_cmd_acl_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd_acl_id();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.cmd_acl_id)
  return _s;
}
inline const std::string& CommandRequest::_internal_cmd_acl_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_acl_id_.Get();
}
inline void CommandRequest::_internal_set_cmd_acl_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cmd_acl_id_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.cmd_acl_id)
  return _impl_.cmd_acl_id_.Release();
}
inline void CommandRequest::set_allocated_cmd_acl_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_acl_id_.IsDefault()) {
          _impl_.cmd_acl_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.cmd_acl_id)
}

// string cmd_group_id = 11;
inline void CommandRequest::clear_cmd_group_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_group_id_.ClearToEmpty();
}
inline const std::string& CommandRequest::cmd_group_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandRequest.cmd_group_id)
  return _internal_cmd_group_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_cmd_group_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_group_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandRequest.cmd_group_id)
}
inline std::string* CommandRequest::mutable_cmd_group_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd_group_id();
  // @@protoc_insertion_point(field_mutable:message.CommandRequest.cmd_group_id)
  return _s;
}
inline const std::string& CommandRequest::_internal_cmd_group_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_group_id_.Get();
}
inline void CommandRequest::_internal_set_cmd_group_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_group_id_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_cmd_group_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cmd_group_id_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_cmd_group_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandRequest.cmd_group_id)
  return _impl_.cmd_group_id_.Release();
}
inline void CommandRequest::set_allocated_cmd_group_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_group_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_group_id_.IsDefault()) {
          _impl_.cmd_group_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandRequest.cmd_group_id)
}

// -------------------------------------------------------------------

// CommandResponse

// .message.Status status = 1;
inline bool CommandResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void CommandResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& CommandResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& CommandResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandResponse.status)
  return _internal_status();
}
inline void CommandResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.CommandResponse.status)
}
inline ::message::Status* CommandResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* CommandResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* CommandResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* CommandResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.CommandResponse.status)
  return _msg;
}
inline void CommandResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.CommandResponse.status)
}

// -------------------------------------------------------------------

// FinishedTaskRequest

// string task_id = 1;
inline void FinishedTaskRequest::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& FinishedTaskRequest::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.FinishedTaskRequest.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FinishedTaskRequest::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.FinishedTaskRequest.task_id)
}
inline std::string* FinishedTaskRequest::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:message.FinishedTaskRequest.task_id)
  return _s;
}
inline const std::string& FinishedTaskRequest::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void FinishedTaskRequest::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* FinishedTaskRequest::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* FinishedTaskRequest::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.FinishedTaskRequest.task_id)
  return _impl_.task_id_.Release();
}
inline void FinishedTaskRequest::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_id_.IsDefault()) {
          _impl_.task_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.FinishedTaskRequest.task_id)
}

// -------------------------------------------------------------------

// TaskResponse

// .message.TerminalTask task = 1;
inline bool TaskResponse::has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.task_ != nullptr);
  return value;
}
inline const ::message::TerminalTask& TaskResponse::_internal_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TerminalTask* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TerminalTask&>(::message::_TerminalTask_default_instance_);
}
inline const ::message::TerminalTask& TaskResponse::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TaskResponse.task)
  return _internal_task();
}
inline void TaskResponse::unsafe_arena_set_allocated_task(::message::TerminalTask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = reinterpret_cast<::message::TerminalTask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TaskResponse.task)
}
inline ::message::TerminalTask* TaskResponse::release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TerminalTask* released = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TerminalTask* TaskResponse::unsafe_arena_release_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TaskResponse.task)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TerminalTask* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::message::TerminalTask* TaskResponse::_internal_mutable_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.task_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TerminalTask>(GetArena());
    _impl_.task_ = reinterpret_cast<::message::TerminalTask*>(p);
  }
  return _impl_.task_;
}
inline ::message::TerminalTask* TaskResponse::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::TerminalTask* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:message.TaskResponse.task)
  return _msg;
}
inline void TaskResponse::set_allocated_task(::message::TerminalTask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.task_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.task_ = reinterpret_cast<::message::TerminalTask*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TaskResponse.task)
}

// -------------------------------------------------------------------

// RemainReplayRequest

// string replay_dir = 1;
inline void RemainReplayRequest::clear_replay_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_dir_.ClearToEmpty();
}
inline const std::string& RemainReplayRequest::replay_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.RemainReplayRequest.replay_dir)
  return _internal_replay_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemainReplayRequest::set_replay_dir(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.RemainReplayRequest.replay_dir)
}
inline std::string* RemainReplayRequest::mutable_replay_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_replay_dir();
  // @@protoc_insertion_point(field_mutable:message.RemainReplayRequest.replay_dir)
  return _s;
}
inline const std::string& RemainReplayRequest::_internal_replay_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replay_dir_.Get();
}
inline void RemainReplayRequest::_internal_set_replay_dir(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_dir_.Set(value, GetArena());
}
inline std::string* RemainReplayRequest::_internal_mutable_replay_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.replay_dir_.Mutable( GetArena());
}
inline std::string* RemainReplayRequest::release_replay_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.RemainReplayRequest.replay_dir)
  return _impl_.replay_dir_.Release();
}
inline void RemainReplayRequest::set_allocated_replay_dir(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replay_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.replay_dir_.IsDefault()) {
          _impl_.replay_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.RemainReplayRequest.replay_dir)
}

// -------------------------------------------------------------------

// RemainReplayResponse

// .message.Status status = 1;
inline bool RemainReplayResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void RemainReplayResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& RemainReplayResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& RemainReplayResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.RemainReplayResponse.status)
  return _internal_status();
}
inline void RemainReplayResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.RemainReplayResponse.status)
}
inline ::message::Status* RemainReplayResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* RemainReplayResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.RemainReplayResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* RemainReplayResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* RemainReplayResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.RemainReplayResponse.status)
  return _msg;
}
inline void RemainReplayResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.RemainReplayResponse.status)
}

// repeated string success_files = 2;
inline int RemainReplayResponse::_internal_success_files_size() const {
  return _internal_success_files().size();
}
inline int RemainReplayResponse::success_files_size() const {
  return _internal_success_files_size();
}
inline void RemainReplayResponse::clear_success_files() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_files_.Clear();
}
inline std::string* RemainReplayResponse::add_success_files()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_success_files()->Add();
  // @@protoc_insertion_point(field_add_mutable:message.RemainReplayResponse.success_files)
  return _s;
}
inline const std::string& RemainReplayResponse::success_files(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.RemainReplayResponse.success_files)
  return _internal_success_files().Get(index);
}
inline std::string* RemainReplayResponse::mutable_success_files(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.RemainReplayResponse.success_files)
  return _internal_mutable_success_files()->Mutable(index);
}
inline void RemainReplayResponse::set_success_files(int index, const std::string& value) {
  _internal_mutable_success_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::set_success_files(int index, std::string&& value) {
  _internal_mutable_success_files()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::set_success_files(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_success_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::set_success_files(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_success_files()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::set_success_files(int index, absl::string_view value) {
  _internal_mutable_success_files()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::add_success_files(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_success_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::add_success_files(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_success_files()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::add_success_files(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_success_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::add_success_files(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_success_files()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message.RemainReplayResponse.success_files)
}
inline void RemainReplayResponse::add_success_files(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_success_files()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:message.RemainReplayResponse.success_files)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::success_files() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.RemainReplayResponse.success_files)
  return _internal_success_files();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::mutable_success_files() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.RemainReplayResponse.success_files)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_success_files();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::_internal_success_files() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_files_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::_internal_mutable_success_files() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.success_files_;
}

// repeated string failure_files = 3;
inline int RemainReplayResponse::_internal_failure_files_size() const {
  return _internal_failure_files().size();
}
inline int RemainReplayResponse::failure_files_size() const {
  return _internal_failure_files_size();
}
inline void RemainReplayResponse::clear_failure_files() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_files_.Clear();
}
inline std::string* RemainReplayResponse::add_failure_files()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_failure_files()->Add();
  // @@protoc_insertion_point(field_add_mutable:message.RemainReplayResponse.failure_files)
  return _s;
}
inline const std::string& RemainReplayResponse::failure_files(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.RemainReplayResponse.failure_files)
  return _internal_failure_files().Get(index);
}
inline std::string* RemainReplayResponse::mutable_failure_files(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.RemainReplayResponse.failure_files)
  return _internal_mutable_failure_files()->Mutable(index);
}
inline void RemainReplayResponse::set_failure_files(int index, const std::string& value) {
  _internal_mutable_failure_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::set_failure_files(int index, std::string&& value) {
  _internal_mutable_failure_files()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::set_failure_files(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_failure_files()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::set_failure_files(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_failure_files()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::set_failure_files(int index, absl::string_view value) {
  _internal_mutable_failure_files()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::add_failure_files(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::add_failure_files(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_files()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::add_failure_files(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_files()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::add_failure_files(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_files()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message.RemainReplayResponse.failure_files)
}
inline void RemainReplayResponse::add_failure_files(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_files()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:message.RemainReplayResponse.failure_files)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::failure_files() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.RemainReplayResponse.failure_files)
  return _internal_failure_files();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::mutable_failure_files() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.RemainReplayResponse.failure_files)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_failure_files();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::_internal_failure_files() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_files_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::_internal_mutable_failure_files() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.failure_files_;
}

// repeated string failure_errs = 4;
inline int RemainReplayResponse::_internal_failure_errs_size() const {
  return _internal_failure_errs().size();
}
inline int RemainReplayResponse::failure_errs_size() const {
  return _internal_failure_errs_size();
}
inline void RemainReplayResponse::clear_failure_errs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_errs_.Clear();
}
inline std::string* RemainReplayResponse::add_failure_errs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_failure_errs()->Add();
  // @@protoc_insertion_point(field_add_mutable:message.RemainReplayResponse.failure_errs)
  return _s;
}
inline const std::string& RemainReplayResponse::failure_errs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.RemainReplayResponse.failure_errs)
  return _internal_failure_errs().Get(index);
}
inline std::string* RemainReplayResponse::mutable_failure_errs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.RemainReplayResponse.failure_errs)
  return _internal_mutable_failure_errs()->Mutable(index);
}
inline void RemainReplayResponse::set_failure_errs(int index, const std::string& value) {
  _internal_mutable_failure_errs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::set_failure_errs(int index, std::string&& value) {
  _internal_mutable_failure_errs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::set_failure_errs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_failure_errs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::set_failure_errs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_failure_errs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::set_failure_errs(int index, absl::string_view value) {
  _internal_mutable_failure_errs()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::add_failure_errs(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_errs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::add_failure_errs(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_errs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::add_failure_errs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_errs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::add_failure_errs(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_errs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message.RemainReplayResponse.failure_errs)
}
inline void RemainReplayResponse::add_failure_errs(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_failure_errs()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:message.RemainReplayResponse.failure_errs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::failure_errs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.RemainReplayResponse.failure_errs)
  return _internal_failure_errs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::mutable_failure_errs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.RemainReplayResponse.failure_errs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_failure_errs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RemainReplayResponse::_internal_failure_errs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_errs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RemainReplayResponse::_internal_mutable_failure_errs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.failure_errs_;
}

// -------------------------------------------------------------------

// StatusResponse

// .message.Status status = 1;
inline bool StatusResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void StatusResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& StatusResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& StatusResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.StatusResponse.status)
}
inline ::message::Status* StatusResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* StatusResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.StatusResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* StatusResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* StatusResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.StatusResponse.status)
  return _msg;
}
inline void StatusResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.StatusResponse.status)
}

// -------------------------------------------------------------------

// CommandConfirmRequest

// string session_id = 1;
inline void CommandConfirmRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& CommandConfirmRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandConfirmRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConfirmRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandConfirmRequest.session_id)
}
inline std::string* CommandConfirmRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:message.CommandConfirmRequest.session_id)
  return _s;
}
inline const std::string& CommandConfirmRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void CommandConfirmRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* CommandConfirmRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* CommandConfirmRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandConfirmRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void CommandConfirmRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandConfirmRequest.session_id)
}

// string cmd_acl_id = 2;
inline void CommandConfirmRequest::clear_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.ClearToEmpty();
}
inline const std::string& CommandConfirmRequest::cmd_acl_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandConfirmRequest.cmd_acl_id)
  return _internal_cmd_acl_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConfirmRequest::set_cmd_acl_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandConfirmRequest.cmd_acl_id)
}
inline std::string* CommandConfirmRequest::mutable_cmd_acl_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd_acl_id();
  // @@protoc_insertion_point(field_mutable:message.CommandConfirmRequest.cmd_acl_id)
  return _s;
}
inline const std::string& CommandConfirmRequest::_internal_cmd_acl_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_acl_id_.Get();
}
inline void CommandConfirmRequest::_internal_set_cmd_acl_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.Set(value, GetArena());
}
inline std::string* CommandConfirmRequest::_internal_mutable_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cmd_acl_id_.Mutable( GetArena());
}
inline std::string* CommandConfirmRequest::release_cmd_acl_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandConfirmRequest.cmd_acl_id)
  return _impl_.cmd_acl_id_.Release();
}
inline void CommandConfirmRequest::set_allocated_cmd_acl_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_acl_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_acl_id_.IsDefault()) {
          _impl_.cmd_acl_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandConfirmRequest.cmd_acl_id)
}

// string cmd = 3;
inline void CommandConfirmRequest::clear_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.ClearToEmpty();
}
inline const std::string& CommandConfirmRequest::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandConfirmRequest.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConfirmRequest::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandConfirmRequest.cmd)
}
inline std::string* CommandConfirmRequest::mutable_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:message.CommandConfirmRequest.cmd)
  return _s;
}
inline const std::string& CommandConfirmRequest::_internal_cmd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_.Get();
}
inline void CommandConfirmRequest::_internal_set_cmd(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.Set(value, GetArena());
}
inline std::string* CommandConfirmRequest::_internal_mutable_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cmd_.Mutable( GetArena());
}
inline std::string* CommandConfirmRequest::release_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandConfirmRequest.cmd)
  return _impl_.cmd_.Release();
}
inline void CommandConfirmRequest::set_allocated_cmd(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandConfirmRequest.cmd)
}

// -------------------------------------------------------------------

// ReqInfo

// string method = 1;
inline void ReqInfo::clear_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.ClearToEmpty();
}
inline const std::string& ReqInfo::method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ReqInfo.method)
  return _internal_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqInfo::set_method(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ReqInfo.method)
}
inline std::string* ReqInfo::mutable_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:message.ReqInfo.method)
  return _s;
}
inline const std::string& ReqInfo::_internal_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.method_.Get();
}
inline void ReqInfo::_internal_set_method(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.Set(value, GetArena());
}
inline std::string* ReqInfo::_internal_mutable_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.method_.Mutable( GetArena());
}
inline std::string* ReqInfo::release_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ReqInfo.method)
  return _impl_.method_.Release();
}
inline void ReqInfo::set_allocated_method(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.method_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.method_.IsDefault()) {
          _impl_.method_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ReqInfo.method)
}

// string url = 2;
inline void ReqInfo::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ReqInfo::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ReqInfo.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReqInfo::set_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ReqInfo.url)
}
inline std::string* ReqInfo::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:message.ReqInfo.url)
  return _s;
}
inline const std::string& ReqInfo::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void ReqInfo::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.Set(value, GetArena());
}
inline std::string* ReqInfo::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* ReqInfo::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ReqInfo.url)
  return _impl_.url_.Release();
}
inline void ReqInfo::set_allocated_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ReqInfo.url)
}

// -------------------------------------------------------------------

// CommandConfirmResponse

// .message.Status status = 1;
inline bool CommandConfirmResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void CommandConfirmResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& CommandConfirmResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& CommandConfirmResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandConfirmResponse.status)
  return _internal_status();
}
inline void CommandConfirmResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.CommandConfirmResponse.status)
}
inline ::message::Status* CommandConfirmResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* CommandConfirmResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandConfirmResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* CommandConfirmResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* CommandConfirmResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.CommandConfirmResponse.status)
  return _msg;
}
inline void CommandConfirmResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.CommandConfirmResponse.status)
}

// .message.TicketInfo info = 2;
inline bool CommandConfirmResponse::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void CommandConfirmResponse::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::TicketInfo& CommandConfirmResponse::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TicketInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TicketInfo&>(::message::_TicketInfo_default_instance_);
}
inline const ::message::TicketInfo& CommandConfirmResponse::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandConfirmResponse.info)
  return _internal_info();
}
inline void CommandConfirmResponse::unsafe_arena_set_allocated_info(::message::TicketInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::message::TicketInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.CommandConfirmResponse.info)
}
inline ::message::TicketInfo* CommandConfirmResponse::release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TicketInfo* released = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TicketInfo* CommandConfirmResponse::unsafe_arena_release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandConfirmResponse.info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::TicketInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::message::TicketInfo* CommandConfirmResponse::_internal_mutable_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TicketInfo>(GetArena());
    _impl_.info_ = reinterpret_cast<::message::TicketInfo*>(p);
  }
  return _impl_.info_;
}
inline ::message::TicketInfo* CommandConfirmResponse::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::TicketInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:message.CommandConfirmResponse.info)
  return _msg;
}
inline void CommandConfirmResponse::set_allocated_info(::message::TicketInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.info_ = reinterpret_cast<::message::TicketInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.CommandConfirmResponse.info)
}

// -------------------------------------------------------------------

// TicketInfo

// .message.ReqInfo check_req = 1;
inline bool TicketInfo::has_check_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.check_req_ != nullptr);
  return value;
}
inline void TicketInfo::clear_check_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_req_ != nullptr) _impl_.check_req_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::ReqInfo& TicketInfo::_internal_check_req() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::ReqInfo* p = _impl_.check_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ReqInfo&>(::message::_ReqInfo_default_instance_);
}
inline const ::message::ReqInfo& TicketInfo::check_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketInfo.check_req)
  return _internal_check_req();
}
inline void TicketInfo::unsafe_arena_set_allocated_check_req(::message::ReqInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.check_req_);
  }
  _impl_.check_req_ = reinterpret_cast<::message::ReqInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TicketInfo.check_req)
}
inline ::message::ReqInfo* TicketInfo::release_check_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::ReqInfo* released = _impl_.check_req_;
  _impl_.check_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::ReqInfo* TicketInfo::unsafe_arena_release_check_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketInfo.check_req)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::ReqInfo* temp = _impl_.check_req_;
  _impl_.check_req_ = nullptr;
  return temp;
}
inline ::message::ReqInfo* TicketInfo::_internal_mutable_check_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.check_req_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::ReqInfo>(GetArena());
    _impl_.check_req_ = reinterpret_cast<::message::ReqInfo*>(p);
  }
  return _impl_.check_req_;
}
inline ::message::ReqInfo* TicketInfo::mutable_check_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::ReqInfo* _msg = _internal_mutable_check_req();
  // @@protoc_insertion_point(field_mutable:message.TicketInfo.check_req)
  return _msg;
}
inline void TicketInfo::set_allocated_check_req(::message::ReqInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.check_req_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.check_req_ = reinterpret_cast<::message::ReqInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TicketInfo.check_req)
}

// .message.ReqInfo cancel_req = 2;
inline bool TicketInfo::has_cancel_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cancel_req_ != nullptr);
  return value;
}
inline void TicketInfo::clear_cancel_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cancel_req_ != nullptr) _impl_.cancel_req_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::ReqInfo& TicketInfo::_internal_cancel_req() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::ReqInfo* p = _impl_.cancel_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ReqInfo&>(::message::_ReqInfo_default_instance_);
}
inline const ::message::ReqInfo& TicketInfo::cancel_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketInfo.cancel_req)
  return _internal_cancel_req();
}
inline void TicketInfo::unsafe_arena_set_allocated_cancel_req(::message::ReqInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cancel_req_);
  }
  _impl_.cancel_req_ = reinterpret_cast<::message::ReqInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TicketInfo.cancel_req)
}
inline ::message::ReqInfo* TicketInfo::release_cancel_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::ReqInfo* released = _impl_.cancel_req_;
  _impl_.cancel_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::ReqInfo* TicketInfo::unsafe_arena_release_cancel_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketInfo.cancel_req)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::ReqInfo* temp = _impl_.cancel_req_;
  _impl_.cancel_req_ = nullptr;
  return temp;
}
inline ::message::ReqInfo* TicketInfo::_internal_mutable_cancel_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cancel_req_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::ReqInfo>(GetArena());
    _impl_.cancel_req_ = reinterpret_cast<::message::ReqInfo*>(p);
  }
  return _impl_.cancel_req_;
}
inline ::message::ReqInfo* TicketInfo::mutable_cancel_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::ReqInfo* _msg = _internal_mutable_cancel_req();
  // @@protoc_insertion_point(field_mutable:message.TicketInfo.cancel_req)
  return _msg;
}
inline void TicketInfo::set_allocated_cancel_req(::message::ReqInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.cancel_req_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.cancel_req_ = reinterpret_cast<::message::ReqInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TicketInfo.cancel_req)
}

// string ticket_detail_url = 3;
inline void TicketInfo::clear_ticket_detail_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_detail_url_.ClearToEmpty();
}
inline const std::string& TicketInfo::ticket_detail_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketInfo.ticket_detail_url)
  return _internal_ticket_detail_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TicketInfo::set_ticket_detail_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_detail_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TicketInfo.ticket_detail_url)
}
inline std::string* TicketInfo::mutable_ticket_detail_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ticket_detail_url();
  // @@protoc_insertion_point(field_mutable:message.TicketInfo.ticket_detail_url)
  return _s;
}
inline const std::string& TicketInfo::_internal_ticket_detail_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ticket_detail_url_.Get();
}
inline void TicketInfo::_internal_set_ticket_detail_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_detail_url_.Set(value, GetArena());
}
inline std::string* TicketInfo::_internal_mutable_ticket_detail_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ticket_detail_url_.Mutable( GetArena());
}
inline std::string* TicketInfo::release_ticket_detail_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketInfo.ticket_detail_url)
  return _impl_.ticket_detail_url_.Release();
}
inline void TicketInfo::set_allocated_ticket_detail_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_detail_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticket_detail_url_.IsDefault()) {
          _impl_.ticket_detail_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TicketInfo.ticket_detail_url)
}

// repeated string reviewers = 4;
inline int TicketInfo::_internal_reviewers_size() const {
  return _internal_reviewers().size();
}
inline int TicketInfo::reviewers_size() const {
  return _internal_reviewers_size();
}
inline void TicketInfo::clear_reviewers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reviewers_.Clear();
}
inline std::string* TicketInfo::add_reviewers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_reviewers()->Add();
  // @@protoc_insertion_point(field_add_mutable:message.TicketInfo.reviewers)
  return _s;
}
inline const std::string& TicketInfo::reviewers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketInfo.reviewers)
  return _internal_reviewers().Get(index);
}
inline std::string* TicketInfo::mutable_reviewers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.TicketInfo.reviewers)
  return _internal_mutable_reviewers()->Mutable(index);
}
inline void TicketInfo::set_reviewers(int index, const std::string& value) {
  _internal_mutable_reviewers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:message.TicketInfo.reviewers)
}
inline void TicketInfo::set_reviewers(int index, std::string&& value) {
  _internal_mutable_reviewers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:message.TicketInfo.reviewers)
}
inline void TicketInfo::set_reviewers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_reviewers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message.TicketInfo.reviewers)
}
inline void TicketInfo::set_reviewers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_reviewers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.TicketInfo.reviewers)
}
inline void TicketInfo::set_reviewers(int index, absl::string_view value) {
  _internal_mutable_reviewers()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:message.TicketInfo.reviewers)
}
inline void TicketInfo::add_reviewers(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_reviewers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:message.TicketInfo.reviewers)
}
inline void TicketInfo::add_reviewers(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_reviewers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:message.TicketInfo.reviewers)
}
inline void TicketInfo::add_reviewers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_reviewers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message.TicketInfo.reviewers)
}
inline void TicketInfo::add_reviewers(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_reviewers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message.TicketInfo.reviewers)
}
inline void TicketInfo::add_reviewers(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_reviewers()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:message.TicketInfo.reviewers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TicketInfo::reviewers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.TicketInfo.reviewers)
  return _internal_reviewers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TicketInfo::mutable_reviewers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.TicketInfo.reviewers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_reviewers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TicketInfo::_internal_reviewers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reviewers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TicketInfo::_internal_mutable_reviewers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.reviewers_;
}

// -------------------------------------------------------------------

// TicketRequest

// .message.ReqInfo req = 1;
inline bool TicketRequest::has_req() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.req_ != nullptr);
  return value;
}
inline void TicketRequest::clear_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.req_ != nullptr) _impl_.req_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::ReqInfo& TicketRequest::_internal_req() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::ReqInfo* p = _impl_.req_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ReqInfo&>(::message::_ReqInfo_default_instance_);
}
inline const ::message::ReqInfo& TicketRequest::req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketRequest.req)
  return _internal_req();
}
inline void TicketRequest::unsafe_arena_set_allocated_req(::message::ReqInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.req_);
  }
  _impl_.req_ = reinterpret_cast<::message::ReqInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TicketRequest.req)
}
inline ::message::ReqInfo* TicketRequest::release_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::ReqInfo* released = _impl_.req_;
  _impl_.req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::ReqInfo* TicketRequest::unsafe_arena_release_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketRequest.req)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::ReqInfo* temp = _impl_.req_;
  _impl_.req_ = nullptr;
  return temp;
}
inline ::message::ReqInfo* TicketRequest::_internal_mutable_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.req_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::ReqInfo>(GetArena());
    _impl_.req_ = reinterpret_cast<::message::ReqInfo*>(p);
  }
  return _impl_.req_;
}
inline ::message::ReqInfo* TicketRequest::mutable_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::ReqInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:message.TicketRequest.req)
  return _msg;
}
inline void TicketRequest::set_allocated_req(::message::ReqInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.req_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.req_ = reinterpret_cast<::message::ReqInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TicketRequest.req)
}

// -------------------------------------------------------------------

// TicketStateResponse

// .message.TicketState Data = 1;
inline bool TicketStateResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void TicketStateResponse::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::TicketState& TicketStateResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TicketState* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TicketState&>(::message::_TicketState_default_instance_);
}
inline const ::message::TicketState& TicketStateResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketStateResponse.Data)
  return _internal_data();
}
inline void TicketStateResponse::unsafe_arena_set_allocated_data(::message::TicketState* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::TicketState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TicketStateResponse.Data)
}
inline ::message::TicketState* TicketStateResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TicketState* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TicketState* TicketStateResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketStateResponse.Data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TicketState* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::TicketState* TicketStateResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TicketState>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::TicketState*>(p);
  }
  return _impl_.data_;
}
inline ::message::TicketState* TicketStateResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::TicketState* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.TicketStateResponse.Data)
  return _msg;
}
inline void TicketStateResponse::set_allocated_data(::message::TicketState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::message::TicketState*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TicketStateResponse.Data)
}

// .message.Status status = 2;
inline bool TicketStateResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void TicketStateResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::Status& TicketStateResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& TicketStateResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketStateResponse.status)
  return _internal_status();
}
inline void TicketStateResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TicketStateResponse.status)
}
inline ::message::Status* TicketStateResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* TicketStateResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketStateResponse.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* TicketStateResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* TicketStateResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.TicketStateResponse.status)
  return _msg;
}
inline void TicketStateResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TicketStateResponse.status)
}

// -------------------------------------------------------------------

// TicketState

// .message.TicketState.State state = 1;
inline void TicketState::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::message::TicketState_State TicketState::state() const {
  // @@protoc_insertion_point(field_get:message.TicketState.state)
  return _internal_state();
}
inline void TicketState::set_state(::message::TicketState_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:message.TicketState.state)
}
inline ::message::TicketState_State TicketState::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::TicketState_State>(_impl_.state_);
}
inline void TicketState::_internal_set_state(::message::TicketState_State value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// string processor = 2;
inline void TicketState::clear_processor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processor_.ClearToEmpty();
}
inline const std::string& TicketState::processor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TicketState.processor)
  return _internal_processor();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TicketState::set_processor(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processor_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TicketState.processor)
}
inline std::string* TicketState::mutable_processor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_processor();
  // @@protoc_insertion_point(field_mutable:message.TicketState.processor)
  return _s;
}
inline const std::string& TicketState::_internal_processor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.processor_.Get();
}
inline void TicketState::_internal_set_processor(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processor_.Set(value, GetArena());
}
inline std::string* TicketState::_internal_mutable_processor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.processor_.Mutable( GetArena());
}
inline std::string* TicketState::release_processor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TicketState.processor)
  return _impl_.processor_.Release();
}
inline void TicketState::set_allocated_processor(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processor_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.processor_.IsDefault()) {
          _impl_.processor_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TicketState.processor)
}

// -------------------------------------------------------------------

// ForwardRequest

// string host = 1;
inline void ForwardRequest::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ForwardRequest::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardRequest.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForwardRequest::set_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ForwardRequest.host)
}
inline std::string* ForwardRequest::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:message.ForwardRequest.host)
  return _s;
}
inline const std::string& ForwardRequest::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void ForwardRequest::_internal_set_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ForwardRequest::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ForwardRequest::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ForwardRequest.host)
  return _impl_.host_.Release();
}
inline void ForwardRequest::set_allocated_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ForwardRequest.host)
}

// int32 port = 2;
inline void ForwardRequest::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t ForwardRequest::port() const {
  // @@protoc_insertion_point(field_get:message.ForwardRequest.port)
  return _internal_port();
}
inline void ForwardRequest::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.ForwardRequest.port)
}
inline ::int32_t ForwardRequest::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void ForwardRequest::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// repeated .message.Gateway gateways = 3;
inline int ForwardRequest::_internal_gateways_size() const {
  return _internal_gateways().size();
}
inline int ForwardRequest::gateways_size() const {
  return _internal_gateways_size();
}
inline ::message::Gateway* ForwardRequest::mutable_gateways(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.ForwardRequest.gateways)
  return _internal_mutable_gateways()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>* ForwardRequest::mutable_gateways()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.ForwardRequest.gateways)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_gateways();
}
inline const ::message::Gateway& ForwardRequest::gateways(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardRequest.gateways)
  return _internal_gateways().Get(index);
}
inline ::message::Gateway* ForwardRequest::add_gateways() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::Gateway* _add = _internal_mutable_gateways()->Add();
  // @@protoc_insertion_point(field_add:message.ForwardRequest.gateways)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>& ForwardRequest::gateways() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.ForwardRequest.gateways)
  return _internal_gateways();
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>&
ForwardRequest::_internal_gateways() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gateways_;
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>*
ForwardRequest::_internal_mutable_gateways() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.gateways_;
}

// -------------------------------------------------------------------

// ForwardDeleteRequest

// string id = 1;
inline void ForwardDeleteRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ForwardDeleteRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardDeleteRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForwardDeleteRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ForwardDeleteRequest.id)
}
inline std::string* ForwardDeleteRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.ForwardDeleteRequest.id)
  return _s;
}
inline const std::string& ForwardDeleteRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ForwardDeleteRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ForwardDeleteRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ForwardDeleteRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ForwardDeleteRequest.id)
  return _impl_.id_.Release();
}
inline void ForwardDeleteRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ForwardDeleteRequest.id)
}

// -------------------------------------------------------------------

// ForwardResponse

// .message.Status status = 1;
inline bool ForwardResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ForwardResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& ForwardResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& ForwardResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardResponse.status)
  return _internal_status();
}
inline void ForwardResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.ForwardResponse.status)
}
inline ::message::Status* ForwardResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* ForwardResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ForwardResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* ForwardResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* ForwardResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.ForwardResponse.status)
  return _msg;
}
inline void ForwardResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.ForwardResponse.status)
}

// string id = 2;
inline void ForwardResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ForwardResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForwardResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ForwardResponse.id)
}
inline std::string* ForwardResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.ForwardResponse.id)
  return _s;
}
inline const std::string& ForwardResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ForwardResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ForwardResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ForwardResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ForwardResponse.id)
  return _impl_.id_.Release();
}
inline void ForwardResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ForwardResponse.id)
}

// string host = 3;
inline void ForwardResponse::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& ForwardResponse::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ForwardResponse.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ForwardResponse::set_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.ForwardResponse.host)
}
inline std::string* ForwardResponse::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:message.ForwardResponse.host)
  return _s;
}
inline const std::string& ForwardResponse::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void ForwardResponse::_internal_set_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(value, GetArena());
}
inline std::string* ForwardResponse::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* ForwardResponse::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ForwardResponse.host)
  return _impl_.host_.Release();
}
inline void ForwardResponse::set_allocated_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ForwardResponse.host)
}

// int32 port = 4;
inline void ForwardResponse::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t ForwardResponse::port() const {
  // @@protoc_insertion_point(field_get:message.ForwardResponse.port)
  return _internal_port();
}
inline void ForwardResponse::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.ForwardResponse.port)
}
inline ::int32_t ForwardResponse::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void ForwardResponse::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// PublicSettingResponse

// .message.Status status = 1;
inline bool PublicSettingResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void PublicSettingResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& PublicSettingResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& PublicSettingResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSettingResponse.status)
  return _internal_status();
}
inline void PublicSettingResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.PublicSettingResponse.status)
}
inline ::message::Status* PublicSettingResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* PublicSettingResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSettingResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* PublicSettingResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* PublicSettingResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.PublicSettingResponse.status)
  return _msg;
}
inline void PublicSettingResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.PublicSettingResponse.status)
}

// .message.PublicSetting data = 2;
inline bool PublicSettingResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::message::PublicSetting& PublicSettingResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::PublicSetting* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::PublicSetting&>(::message::_PublicSetting_default_instance_);
}
inline const ::message::PublicSetting& PublicSettingResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSettingResponse.data)
  return _internal_data();
}
inline void PublicSettingResponse::unsafe_arena_set_allocated_data(::message::PublicSetting* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::PublicSetting*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.PublicSettingResponse.data)
}
inline ::message::PublicSetting* PublicSettingResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::PublicSetting* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::PublicSetting* PublicSettingResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSettingResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::PublicSetting* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::PublicSetting* PublicSettingResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::PublicSetting>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::PublicSetting*>(p);
  }
  return _impl_.data_;
}
inline ::message::PublicSetting* PublicSettingResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::PublicSetting* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.PublicSettingResponse.data)
  return _msg;
}
inline void PublicSettingResponse::set_allocated_data(::message::PublicSetting* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::message::PublicSetting*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.PublicSettingResponse.data)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ListenPortResponse

// .message.Status status = 1;
inline bool ListenPortResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ListenPortResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& ListenPortResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& ListenPortResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.ListenPortResponse.status)
  return _internal_status();
}
inline void ListenPortResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.ListenPortResponse.status)
}
inline ::message::Status* ListenPortResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* ListenPortResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.ListenPortResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* ListenPortResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* ListenPortResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.ListenPortResponse.status)
  return _msg;
}
inline void ListenPortResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.ListenPortResponse.status)
}

// repeated int32 ports = 2;
inline int ListenPortResponse::_internal_ports_size() const {
  return _internal_ports().size();
}
inline int ListenPortResponse::ports_size() const {
  return _internal_ports_size();
}
inline void ListenPortResponse::clear_ports() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ports_.Clear();
}
inline ::int32_t ListenPortResponse::ports(int index) const {
  // @@protoc_insertion_point(field_get:message.ListenPortResponse.ports)
  return _internal_ports().Get(index);
}
inline void ListenPortResponse::set_ports(int index, ::int32_t value) {
  _internal_mutable_ports()->Set(index, value);
  // @@protoc_insertion_point(field_set:message.ListenPortResponse.ports)
}
inline void ListenPortResponse::add_ports(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ports()->Add(value);
  // @@protoc_insertion_point(field_add:message.ListenPortResponse.ports)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ListenPortResponse::ports() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.ListenPortResponse.ports)
  return _internal_ports();
}
inline ::google::protobuf::RepeatedField<::int32_t>* ListenPortResponse::mutable_ports()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.ListenPortResponse.ports)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ports();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ListenPortResponse::_internal_ports() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ports_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* ListenPortResponse::_internal_mutable_ports() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ports_;
}

// -------------------------------------------------------------------

// PortInfoRequest

// int32 port = 1;
inline void PortInfoRequest::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t PortInfoRequest::port() const {
  // @@protoc_insertion_point(field_get:message.PortInfoRequest.port)
  return _internal_port();
}
inline void PortInfoRequest::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.PortInfoRequest.port)
}
inline ::int32_t PortInfoRequest::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void PortInfoRequest::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// PortInfoResponse

// .message.Status status = 1;
inline bool PortInfoResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void PortInfoResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& PortInfoResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& PortInfoResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortInfoResponse.status)
  return _internal_status();
}
inline void PortInfoResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.PortInfoResponse.status)
}
inline ::message::Status* PortInfoResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* PortInfoResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PortInfoResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* PortInfoResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* PortInfoResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.PortInfoResponse.status)
  return _msg;
}
inline void PortInfoResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.PortInfoResponse.status)
}

// .message.PortInfo data = 2;
inline bool PortInfoResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void PortInfoResponse::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::PortInfo& PortInfoResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::PortInfo* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::PortInfo&>(::message::_PortInfo_default_instance_);
}
inline const ::message::PortInfo& PortInfoResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortInfoResponse.data)
  return _internal_data();
}
inline void PortInfoResponse::unsafe_arena_set_allocated_data(::message::PortInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::PortInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.PortInfoResponse.data)
}
inline ::message::PortInfo* PortInfoResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::PortInfo* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::PortInfo* PortInfoResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PortInfoResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::PortInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::PortInfo* PortInfoResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::PortInfo>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::PortInfo*>(p);
  }
  return _impl_.data_;
}
inline ::message::PortInfo* PortInfoResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::PortInfo* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.PortInfoResponse.data)
  return _msg;
}
inline void PortInfoResponse::set_allocated_data(::message::PortInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::message::PortInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.PortInfoResponse.data)
}

// -------------------------------------------------------------------

// PortInfo

// .message.Asset asset = 1;
inline bool PortInfo::has_asset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.asset_ != nullptr);
  return value;
}
inline const ::message::Asset& PortInfo::_internal_asset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Asset* p = _impl_.asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Asset&>(::message::_Asset_default_instance_);
}
inline const ::message::Asset& PortInfo::asset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortInfo.asset)
  return _internal_asset();
}
inline void PortInfo::unsafe_arena_set_allocated_asset(::message::Asset* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asset_);
  }
  _impl_.asset_ = reinterpret_cast<::message::Asset*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.PortInfo.asset)
}
inline ::message::Asset* PortInfo::release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset* released = _impl_.asset_;
  _impl_.asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Asset* PortInfo::unsafe_arena_release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PortInfo.asset)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset* temp = _impl_.asset_;
  _impl_.asset_ = nullptr;
  return temp;
}
inline ::message::Asset* PortInfo::_internal_mutable_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Asset>(GetArena());
    _impl_.asset_ = reinterpret_cast<::message::Asset*>(p);
  }
  return _impl_.asset_;
}
inline ::message::Asset* PortInfo::mutable_asset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:message.PortInfo.asset)
  return _msg;
}
inline void PortInfo::set_allocated_asset(::message::Asset* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.asset_ = reinterpret_cast<::message::Asset*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.PortInfo.asset)
}

// repeated .message.Gateway gateways = 2;
inline int PortInfo::_internal_gateways_size() const {
  return _internal_gateways().size();
}
inline int PortInfo::gateways_size() const {
  return _internal_gateways_size();
}
inline ::message::Gateway* PortInfo::mutable_gateways(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.PortInfo.gateways)
  return _internal_mutable_gateways()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>* PortInfo::mutable_gateways()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.PortInfo.gateways)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_gateways();
}
inline const ::message::Gateway& PortInfo::gateways(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortInfo.gateways)
  return _internal_gateways().Get(index);
}
inline ::message::Gateway* PortInfo::add_gateways() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::Gateway* _add = _internal_mutable_gateways()->Add();
  // @@protoc_insertion_point(field_add:message.PortInfo.gateways)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>& PortInfo::gateways() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.PortInfo.gateways)
  return _internal_gateways();
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>&
PortInfo::_internal_gateways() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gateways_;
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>*
PortInfo::_internal_mutable_gateways() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.gateways_;
}

// -------------------------------------------------------------------

// PortFailure

// int32 port = 1;
inline void PortFailure::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t PortFailure::port() const {
  // @@protoc_insertion_point(field_get:message.PortFailure.port)
  return _internal_port();
}
inline void PortFailure::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.PortFailure.port)
}
inline ::int32_t PortFailure::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void PortFailure::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// string reason = 2;
inline void PortFailure::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& PortFailure::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortFailure.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortFailure::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PortFailure.reason)
}
inline std::string* PortFailure::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:message.PortFailure.reason)
  return _s;
}
inline const std::string& PortFailure::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void PortFailure::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* PortFailure::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* PortFailure::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PortFailure.reason)
  return _impl_.reason_.Release();
}
inline void PortFailure::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PortFailure.reason)
}

// -------------------------------------------------------------------

// PortFailureRequest

// repeated .message.PortFailure data = 1;
inline int PortFailureRequest::_internal_data_size() const {
  return _internal_data().size();
}
inline int PortFailureRequest::data_size() const {
  return _internal_data_size();
}
inline void PortFailureRequest::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::message::PortFailure* PortFailureRequest::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.PortFailureRequest.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::PortFailure>* PortFailureRequest::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.PortFailureRequest.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::message::PortFailure& PortFailureRequest::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PortFailureRequest.data)
  return _internal_data().Get(index);
}
inline ::message::PortFailure* PortFailureRequest::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::PortFailure* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:message.PortFailureRequest.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::PortFailure>& PortFailureRequest::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.PortFailureRequest.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::message::PortFailure>&
PortFailureRequest::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::message::PortFailure>*
PortFailureRequest::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// CookiesRequest

// repeated .message.Cookie cookies = 1;
inline int CookiesRequest::_internal_cookies_size() const {
  return _internal_cookies().size();
}
inline int CookiesRequest::cookies_size() const {
  return _internal_cookies_size();
}
inline ::message::Cookie* CookiesRequest::mutable_cookies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.CookiesRequest.cookies)
  return _internal_mutable_cookies()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::Cookie>* CookiesRequest::mutable_cookies()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.CookiesRequest.cookies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cookies();
}
inline const ::message::Cookie& CookiesRequest::cookies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CookiesRequest.cookies)
  return _internal_cookies().Get(index);
}
inline ::message::Cookie* CookiesRequest::add_cookies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::Cookie* _add = _internal_mutable_cookies()->Add();
  // @@protoc_insertion_point(field_add:message.CookiesRequest.cookies)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::Cookie>& CookiesRequest::cookies() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.CookiesRequest.cookies)
  return _internal_cookies();
}
inline const ::google::protobuf::RepeatedPtrField<::message::Cookie>&
CookiesRequest::_internal_cookies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cookies_;
}
inline ::google::protobuf::RepeatedPtrField<::message::Cookie>*
CookiesRequest::_internal_mutable_cookies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cookies_;
}

// -------------------------------------------------------------------

// UserResponse

// .message.Status status = 1;
inline bool UserResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void UserResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Status& UserResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Status&>(::message::_Status_default_instance_);
}
inline const ::message::Status& UserResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.UserResponse.status)
  return _internal_status();
}
inline void UserResponse::unsafe_arena_set_allocated_status(::message::Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.UserResponse.status)
}
inline ::message::Status* UserResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Status* UserResponse::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.UserResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::message::Status* UserResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::message::Status*>(p);
  }
  return _impl_.status_;
}
inline ::message::Status* UserResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:message.UserResponse.status)
  return _msg;
}
inline void UserResponse::set_allocated_status(::message::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::message::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.UserResponse.status)
}

// .message.User data = 2;
inline bool UserResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::message::User& UserResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::User* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::User&>(::message::_User_default_instance_);
}
inline const ::message::User& UserResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.UserResponse.data)
  return _internal_data();
}
inline void UserResponse::unsafe_arena_set_allocated_data(::message::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::message::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.UserResponse.data)
}
inline ::message::User* UserResponse::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::User* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::User* UserResponse::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.UserResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::User* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::message::User* UserResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::User>(GetArena());
    _impl_.data_ = reinterpret_cast<::message::User*>(p);
  }
  return _impl_.data_;
}
inline ::message::User* UserResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::User* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:message.UserResponse.data)
  return _msg;
}
inline void UserResponse::set_allocated_data(::message::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::message::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.UserResponse.data)
}

// -------------------------------------------------------------------

// SessionLifecycleLogRequest

// string session_id = 1;
inline void SessionLifecycleLogRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& SessionLifecycleLogRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionLifecycleLogRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionLifecycleLogRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SessionLifecycleLogRequest.session_id)
}
inline std::string* SessionLifecycleLogRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:message.SessionLifecycleLogRequest.session_id)
  return _s;
}
inline const std::string& SessionLifecycleLogRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void SessionLifecycleLogRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* SessionLifecycleLogRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* SessionLifecycleLogRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionLifecycleLogRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void SessionLifecycleLogRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SessionLifecycleLogRequest.session_id)
}

// .message.SessionLifecycleLogRequest.EventType event = 2;
inline void SessionLifecycleLogRequest::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_ = 0;
}
inline ::message::SessionLifecycleLogRequest_EventType SessionLifecycleLogRequest::event() const {
  // @@protoc_insertion_point(field_get:message.SessionLifecycleLogRequest.event)
  return _internal_event();
}
inline void SessionLifecycleLogRequest::set_event(::message::SessionLifecycleLogRequest_EventType value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:message.SessionLifecycleLogRequest.event)
}
inline ::message::SessionLifecycleLogRequest_EventType SessionLifecycleLogRequest::_internal_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::SessionLifecycleLogRequest_EventType>(_impl_.event_);
}
inline void SessionLifecycleLogRequest::_internal_set_event(::message::SessionLifecycleLogRequest_EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_ = value;
}

// string reason = 3;
inline void SessionLifecycleLogRequest::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& SessionLifecycleLogRequest::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionLifecycleLogRequest.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionLifecycleLogRequest::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SessionLifecycleLogRequest.reason)
}
inline std::string* SessionLifecycleLogRequest::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:message.SessionLifecycleLogRequest.reason)
  return _s;
}
inline const std::string& SessionLifecycleLogRequest::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void SessionLifecycleLogRequest::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* SessionLifecycleLogRequest::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* SessionLifecycleLogRequest::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionLifecycleLogRequest.reason)
  return _impl_.reason_.Release();
}
inline void SessionLifecycleLogRequest::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SessionLifecycleLogRequest.reason)
}

// string user = 4;
inline void SessionLifecycleLogRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& SessionLifecycleLogRequest::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SessionLifecycleLogRequest.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionLifecycleLogRequest::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SessionLifecycleLogRequest.user)
}
inline std::string* SessionLifecycleLogRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:message.SessionLifecycleLogRequest.user)
  return _s;
}
inline const std::string& SessionLifecycleLogRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void SessionLifecycleLogRequest::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* SessionLifecycleLogRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* SessionLifecycleLogRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.SessionLifecycleLogRequest.user)
  return _impl_.user_.Release();
}
inline void SessionLifecycleLogRequest::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SessionLifecycleLogRequest.user)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace message


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::message::TicketState_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::TicketState_State>() {
  return ::message::TicketState_State_descriptor();
}
template <>
struct is_proto_enum<::message::SessionLifecycleLogRequest_EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::SessionLifecycleLogRequest_EventType>() {
  return ::message::SessionLifecycleLogRequest_EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
