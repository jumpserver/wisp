// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2eproto;
namespace message {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class Asset;
struct AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class Asset_Specific;
struct Asset_SpecificDefaultTypeInternal;
extern Asset_SpecificDefaultTypeInternal _Asset_Specific_default_instance_;
class CommandACL;
struct CommandACLDefaultTypeInternal;
extern CommandACLDefaultTypeInternal _CommandACL_default_instance_;
class CommandGroup;
struct CommandGroupDefaultTypeInternal;
extern CommandGroupDefaultTypeInternal _CommandGroup_default_instance_;
class ComponentSetting;
struct ComponentSettingDefaultTypeInternal;
extern ComponentSettingDefaultTypeInternal _ComponentSetting_default_instance_;
class Cookie;
struct CookieDefaultTypeInternal;
extern CookieDefaultTypeInternal _Cookie_default_instance_;
class ExpireInfo;
struct ExpireInfoDefaultTypeInternal;
extern ExpireInfoDefaultTypeInternal _ExpireInfo_default_instance_;
class Forward;
struct ForwardDefaultTypeInternal;
extern ForwardDefaultTypeInternal _Forward_default_instance_;
class Gateway;
struct GatewayDefaultTypeInternal;
extern GatewayDefaultTypeInternal _Gateway_default_instance_;
class LabelValue;
struct LabelValueDefaultTypeInternal;
extern LabelValueDefaultTypeInternal _LabelValue_default_instance_;
class LifecycleLogData;
struct LifecycleLogDataDefaultTypeInternal;
extern LifecycleLogDataDefaultTypeInternal _LifecycleLogData_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class Platform;
struct PlatformDefaultTypeInternal;
extern PlatformDefaultTypeInternal _Platform_default_instance_;
class PlatformProtocol;
struct PlatformProtocolDefaultTypeInternal;
extern PlatformProtocolDefaultTypeInternal _PlatformProtocol_default_instance_;
class PlatformProtocol_SettingsEntry_DoNotUse;
struct PlatformProtocol_SettingsEntry_DoNotUseDefaultTypeInternal;
extern PlatformProtocol_SettingsEntry_DoNotUseDefaultTypeInternal _PlatformProtocol_SettingsEntry_DoNotUse_default_instance_;
class Protocol;
struct ProtocolDefaultTypeInternal;
extern ProtocolDefaultTypeInternal _Protocol_default_instance_;
class PublicSetting;
struct PublicSettingDefaultTypeInternal;
extern PublicSettingDefaultTypeInternal _PublicSetting_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class TerminalTask;
struct TerminalTaskDefaultTypeInternal;
extern TerminalTaskDefaultTypeInternal _TerminalTask_default_instance_;
class TokenAuthInfo;
struct TokenAuthInfoDefaultTypeInternal;
extern TokenAuthInfoDefaultTypeInternal _TokenAuthInfo_default_instance_;
class TokenStatus;
struct TokenStatusDefaultTypeInternal;
extern TokenStatusDefaultTypeInternal _TokenStatus_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace message
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace message {
enum CommandACL_Action : int {
  CommandACL_Action_Reject = 0,
  CommandACL_Action_Accept = 1,
  CommandACL_Action_Review = 2,
  CommandACL_Action_Warning = 3,
  CommandACL_Action_NotifyWarning = 4,
  CommandACL_Action_Unknown = 5,
  CommandACL_Action_CommandACL_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandACL_Action_CommandACL_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommandACL_Action_IsValid(int value);
extern const uint32_t CommandACL_Action_internal_data_[];
constexpr CommandACL_Action CommandACL_Action_Action_MIN = static_cast<CommandACL_Action>(0);
constexpr CommandACL_Action CommandACL_Action_Action_MAX = static_cast<CommandACL_Action>(5);
constexpr int CommandACL_Action_Action_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
CommandACL_Action_descriptor();
template <typename T>
const std::string& CommandACL_Action_Name(T value) {
  static_assert(std::is_same<T, CommandACL_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return CommandACL_Action_Name(static_cast<CommandACL_Action>(value));
}
template <>
inline const std::string& CommandACL_Action_Name(CommandACL_Action value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommandACL_Action_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool CommandACL_Action_Parse(absl::string_view name, CommandACL_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandACL_Action>(
      CommandACL_Action_descriptor(), name, value);
}
enum Session_LoginFrom : int {
  Session_LoginFrom_WT = 0,
  Session_LoginFrom_ST = 1,
  Session_LoginFrom_RT = 2,
  Session_LoginFrom_DT = 3,
  Session_LoginFrom_Session_LoginFrom_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Session_LoginFrom_Session_LoginFrom_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Session_LoginFrom_IsValid(int value);
extern const uint32_t Session_LoginFrom_internal_data_[];
constexpr Session_LoginFrom Session_LoginFrom_LoginFrom_MIN = static_cast<Session_LoginFrom>(0);
constexpr Session_LoginFrom Session_LoginFrom_LoginFrom_MAX = static_cast<Session_LoginFrom>(3);
constexpr int Session_LoginFrom_LoginFrom_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Session_LoginFrom_descriptor();
template <typename T>
const std::string& Session_LoginFrom_Name(T value) {
  static_assert(std::is_same<T, Session_LoginFrom>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoginFrom_Name().");
  return Session_LoginFrom_Name(static_cast<Session_LoginFrom>(value));
}
template <>
inline const std::string& Session_LoginFrom_Name(Session_LoginFrom value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Session_LoginFrom_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Session_LoginFrom_Parse(absl::string_view name, Session_LoginFrom* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Session_LoginFrom>(
      Session_LoginFrom_descriptor(), name, value);
}
enum LifecycleLogData_event_type : int {
  LifecycleLogData_event_type_AssetConnectSuccess = 0,
  LifecycleLogData_event_type_AssetConnectFinished = 1,
  LifecycleLogData_event_type_CreateShareLink = 2,
  LifecycleLogData_event_type_UserJoinSession = 3,
  LifecycleLogData_event_type_UserLeaveSession = 4,
  LifecycleLogData_event_type_AdminJoinMonitor = 5,
  LifecycleLogData_event_type_AdminExitMonitor = 6,
  LifecycleLogData_event_type_ReplayConvertStart = 7,
  LifecycleLogData_event_type_ReplayConvertSuccess = 8,
  LifecycleLogData_event_type_ReplayConvertFailure = 9,
  LifecycleLogData_event_type_ReplayUploadStart = 10,
  LifecycleLogData_event_type_ReplayUploadSuccess = 11,
  LifecycleLogData_event_type_ReplayUploadFailure = 12,
  LifecycleLogData_event_type_LifecycleLogData_event_type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LifecycleLogData_event_type_LifecycleLogData_event_type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LifecycleLogData_event_type_IsValid(int value);
extern const uint32_t LifecycleLogData_event_type_internal_data_[];
constexpr LifecycleLogData_event_type LifecycleLogData_event_type_event_type_MIN = static_cast<LifecycleLogData_event_type>(0);
constexpr LifecycleLogData_event_type LifecycleLogData_event_type_event_type_MAX = static_cast<LifecycleLogData_event_type>(12);
constexpr int LifecycleLogData_event_type_event_type_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
LifecycleLogData_event_type_descriptor();
template <typename T>
const std::string& LifecycleLogData_event_type_Name(T value) {
  static_assert(std::is_same<T, LifecycleLogData_event_type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to event_type_Name().");
  return LifecycleLogData_event_type_Name(static_cast<LifecycleLogData_event_type>(value));
}
template <>
inline const std::string& LifecycleLogData_event_type_Name(LifecycleLogData_event_type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LifecycleLogData_event_type_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool LifecycleLogData_event_type_Parse(absl::string_view name, LifecycleLogData_event_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LifecycleLogData_event_type>(
      LifecycleLogData_event_type_descriptor(), name, value);
}
enum TaskAction : int {
  KillSession = 0,
  LockSession = 1,
  UnlockSession = 2,
  TokenPermExpired = 3,
  TokenPermValid = 4,
  TaskAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskAction_IsValid(int value);
extern const uint32_t TaskAction_internal_data_[];
constexpr TaskAction TaskAction_MIN = static_cast<TaskAction>(0);
constexpr TaskAction TaskAction_MAX = static_cast<TaskAction>(4);
constexpr int TaskAction_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
TaskAction_descriptor();
template <typename T>
const std::string& TaskAction_Name(T value) {
  static_assert(std::is_same<T, TaskAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskAction_Name().");
  return TaskAction_Name(static_cast<TaskAction>(value));
}
template <>
inline const std::string& TaskAction_Name(TaskAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskAction_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TaskAction_Parse(absl::string_view name, TaskAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskAction>(
      TaskAction_descriptor(), name, value);
}
enum RiskLevel : int {
  Normal = 0,
  Warning = 1,
  Reject = 2,
  ReviewReject = 3,
  ReviewAccept = 4,
  ReviewCancel = 5,
  RiskLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RiskLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RiskLevel_IsValid(int value);
extern const uint32_t RiskLevel_internal_data_[];
constexpr RiskLevel RiskLevel_MIN = static_cast<RiskLevel>(0);
constexpr RiskLevel RiskLevel_MAX = static_cast<RiskLevel>(5);
constexpr int RiskLevel_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
RiskLevel_descriptor();
template <typename T>
const std::string& RiskLevel_Name(T value) {
  static_assert(std::is_same<T, RiskLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RiskLevel_Name().");
  return RiskLevel_Name(static_cast<RiskLevel>(value));
}
template <>
inline const std::string& RiskLevel_Name(RiskLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RiskLevel_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool RiskLevel_Parse(absl::string_view name, RiskLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RiskLevel>(
      RiskLevel_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class User final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR User(
      ::google::protobuf::internal::ConstantInitialized);

  inline User(const User& from) : User(nullptr, from) {}
  inline User(User&& from) noexcept
      : User(nullptr, std::move(from)) {}
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
        &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(User& a, User& b) { a.Swap(&b); }
  inline void Swap(User* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<User>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const User& from) { User::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(User* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.User"; }

 protected:
  explicit User(::google::protobuf::Arena* arena);
  User(::google::protobuf::Arena* arena, const User& from);
  User(::google::protobuf::Arena* arena, User&& from) noexcept
      : User(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kRoleFieldNumber = 4,
    kIsValidFieldNumber = 5,
    kIsActiveFieldNumber = 6,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string username = 3;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string role = 4;
  void clear_role() ;
  const std::string& role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* value);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // bool is_valid = 5;
  void clear_is_valid() ;
  bool is_valid() const;
  void set_is_valid(bool value);

  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);

  public:
  // bool is_active = 6;
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.User)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_User_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const User& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr role_;
    bool is_valid_;
    bool is_active_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TokenStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TokenStatus) */ {
 public:
  inline TokenStatus() : TokenStatus(nullptr) {}
  ~TokenStatus() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TokenStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline TokenStatus(const TokenStatus& from) : TokenStatus(nullptr, from) {}
  inline TokenStatus(TokenStatus&& from) noexcept
      : TokenStatus(nullptr, std::move(from)) {}
  inline TokenStatus& operator=(const TokenStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenStatus& operator=(TokenStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenStatus* internal_default_instance() {
    return reinterpret_cast<const TokenStatus*>(
        &_TokenStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TokenStatus& a, TokenStatus& b) { a.Swap(&b); }
  inline void Swap(TokenStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TokenStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TokenStatus& from) { TokenStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TokenStatus"; }

 protected:
  explicit TokenStatus(::google::protobuf::Arena* arena);
  TokenStatus(::google::protobuf::Arena* arena, const TokenStatus& from);
  TokenStatus(::google::protobuf::Arena* arena, TokenStatus&& from) noexcept
      : TokenStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCodeFieldNumber = 1,
    kDetailFieldNumber = 2,
    kIsExpiredFieldNumber = 3,
  };
  // string code = 1;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // string detail = 2;
  void clear_detail() ;
  const std::string& detail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_detail(Arg_&& arg, Args_... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* value);

  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(
      const std::string& value);
  std::string* _internal_mutable_detail();

  public:
  // bool is_expired = 3;
  void clear_is_expired() ;
  bool is_expired() const;
  void set_is_expired(bool value);

  private:
  bool _internal_is_expired() const;
  void _internal_set_is_expired(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.TokenStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TokenStatus_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TokenStatus& from_msg);
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr detail_;
    bool is_expired_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Session final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Session(
      ::google::protobuf::internal::ConstantInitialized);

  inline Session(const Session& from) : Session(nullptr, from) {}
  inline Session(Session&& from) noexcept
      : Session(nullptr, std::move(from)) {}
  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
        &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Session& a, Session& b) { a.Swap(&b); }
  inline void Swap(Session* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Session>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Session& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Session& from) { Session::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Session* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Session"; }

 protected:
  explicit Session(::google::protobuf::Arena* arena);
  Session(::google::protobuf::Arena* arena, const Session& from);
  Session(::google::protobuf::Arena* arena, Session&& from) noexcept
      : Session(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LoginFrom = Session_LoginFrom;
  static constexpr LoginFrom WT = Session_LoginFrom_WT;
  static constexpr LoginFrom ST = Session_LoginFrom_ST;
  static constexpr LoginFrom RT = Session_LoginFrom_RT;
  static constexpr LoginFrom DT = Session_LoginFrom_DT;
  static inline bool LoginFrom_IsValid(int value) {
    return Session_LoginFrom_IsValid(value);
  }
  static constexpr LoginFrom LoginFrom_MIN = Session_LoginFrom_LoginFrom_MIN;
  static constexpr LoginFrom LoginFrom_MAX = Session_LoginFrom_LoginFrom_MAX;
  static constexpr int LoginFrom_ARRAYSIZE = Session_LoginFrom_LoginFrom_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LoginFrom_descriptor() {
    return Session_LoginFrom_descriptor();
  }
  template <typename T>
  static inline const std::string& LoginFrom_Name(T value) {
    return Session_LoginFrom_Name(value);
  }
  static inline bool LoginFrom_Parse(absl::string_view name, LoginFrom* value) {
    return Session_LoginFrom_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kUserFieldNumber = 2,
    kAssetFieldNumber = 3,
    kAccountFieldNumber = 4,
    kRemoteAddrFieldNumber = 6,
    kProtocolFieldNumber = 7,
    kOrgIdFieldNumber = 9,
    kUserIdFieldNumber = 10,
    kAssetIdFieldNumber = 11,
    kAccountIdFieldNumber = 12,
    kTokenIdFieldNumber = 13,
    kDateStartFieldNumber = 8,
    kLoginFromFieldNumber = 5,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string asset = 3;
  void clear_asset() ;
  const std::string& asset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asset(Arg_&& arg, Args_... args);
  std::string* mutable_asset();
  PROTOBUF_NODISCARD std::string* release_asset();
  void set_allocated_asset(std::string* value);

  private:
  const std::string& _internal_asset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset(
      const std::string& value);
  std::string* _internal_mutable_asset();

  public:
  // string account = 4;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // string remote_addr = 6;
  void clear_remote_addr() ;
  const std::string& remote_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_addr(Arg_&& arg, Args_... args);
  std::string* mutable_remote_addr();
  PROTOBUF_NODISCARD std::string* release_remote_addr();
  void set_allocated_remote_addr(std::string* value);

  private:
  const std::string& _internal_remote_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_addr(
      const std::string& value);
  std::string* _internal_mutable_remote_addr();

  public:
  // string protocol = 7;
  void clear_protocol() ;
  const std::string& protocol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol(Arg_&& arg, Args_... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* value);

  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(
      const std::string& value);
  std::string* _internal_mutable_protocol();

  public:
  // string org_id = 9;
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* value);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string user_id = 10;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string asset_id = 11;
  void clear_asset_id() ;
  const std::string& asset_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_asset_id(Arg_&& arg, Args_... args);
  std::string* mutable_asset_id();
  PROTOBUF_NODISCARD std::string* release_asset_id();
  void set_allocated_asset_id(std::string* value);

  private:
  const std::string& _internal_asset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_id(
      const std::string& value);
  std::string* _internal_mutable_asset_id();

  public:
  // string account_id = 12;
  void clear_account_id() ;
  const std::string& account_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_id(Arg_&& arg, Args_... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* value);

  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(
      const std::string& value);
  std::string* _internal_mutable_account_id();

  public:
  // string token_id = 13;
  void clear_token_id() ;
  const std::string& token_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token_id(Arg_&& arg, Args_... args);
  std::string* mutable_token_id();
  PROTOBUF_NODISCARD std::string* release_token_id();
  void set_allocated_token_id(std::string* value);

  private:
  const std::string& _internal_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_id(
      const std::string& value);
  std::string* _internal_mutable_token_id();

  public:
  // int64 date_start = 8;
  void clear_date_start() ;
  ::int64_t date_start() const;
  void set_date_start(::int64_t value);

  private:
  ::int64_t _internal_date_start() const;
  void _internal_set_date_start(::int64_t value);

  public:
  // .message.Session.LoginFrom login_from = 5;
  void clear_login_from() ;
  ::message::Session_LoginFrom login_from() const;
  void set_login_from(::message::Session_LoginFrom value);

  private:
  ::message::Session_LoginFrom _internal_login_from() const;
  void _internal_set_login_from(::message::Session_LoginFrom value);

  public:
  // @@protoc_insertion_point(class_scope:message.Session)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      108, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Session_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Session& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr asset_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr remote_addr_;
    ::google::protobuf::internal::ArenaStringPtr protocol_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr asset_id_;
    ::google::protobuf::internal::ArenaStringPtr account_id_;
    ::google::protobuf::internal::ArenaStringPtr token_id_;
    ::int64_t date_start_;
    int login_from_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PublicSetting final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PublicSetting) */ {
 public:
  inline PublicSetting() : PublicSetting(nullptr) {}
  ~PublicSetting() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PublicSetting(
      ::google::protobuf::internal::ConstantInitialized);

  inline PublicSetting(const PublicSetting& from) : PublicSetting(nullptr, from) {}
  inline PublicSetting(PublicSetting&& from) noexcept
      : PublicSetting(nullptr, std::move(from)) {}
  inline PublicSetting& operator=(const PublicSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicSetting& operator=(PublicSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicSetting* internal_default_instance() {
    return reinterpret_cast<const PublicSetting*>(
        &_PublicSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(PublicSetting& a, PublicSetting& b) { a.Swap(&b); }
  inline void Swap(PublicSetting* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicSetting* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicSetting* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PublicSetting>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicSetting& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PublicSetting& from) { PublicSetting::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicSetting* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PublicSetting"; }

 protected:
  explicit PublicSetting(::google::protobuf::Arena* arena);
  PublicSetting(::google::protobuf::Arena* arena, const PublicSetting& from);
  PublicSetting(::google::protobuf::Arena* arena, PublicSetting&& from) noexcept
      : PublicSetting(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGptBaseUrlFieldNumber = 3,
    kGptApiKeyFieldNumber = 4,
    kGptProxyFieldNumber = 5,
    kGptModelFieldNumber = 6,
    kLicenseContentFieldNumber = 7,
    kXpackEnabledFieldNumber = 1,
    kValidLicenseFieldNumber = 2,
  };
  // string gpt_base_url = 3;
  void clear_gpt_base_url() ;
  const std::string& gpt_base_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gpt_base_url(Arg_&& arg, Args_... args);
  std::string* mutable_gpt_base_url();
  PROTOBUF_NODISCARD std::string* release_gpt_base_url();
  void set_allocated_gpt_base_url(std::string* value);

  private:
  const std::string& _internal_gpt_base_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpt_base_url(
      const std::string& value);
  std::string* _internal_mutable_gpt_base_url();

  public:
  // string gpt_api_key = 4;
  void clear_gpt_api_key() ;
  const std::string& gpt_api_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gpt_api_key(Arg_&& arg, Args_... args);
  std::string* mutable_gpt_api_key();
  PROTOBUF_NODISCARD std::string* release_gpt_api_key();
  void set_allocated_gpt_api_key(std::string* value);

  private:
  const std::string& _internal_gpt_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpt_api_key(
      const std::string& value);
  std::string* _internal_mutable_gpt_api_key();

  public:
  // string gpt_proxy = 5;
  void clear_gpt_proxy() ;
  const std::string& gpt_proxy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gpt_proxy(Arg_&& arg, Args_... args);
  std::string* mutable_gpt_proxy();
  PROTOBUF_NODISCARD std::string* release_gpt_proxy();
  void set_allocated_gpt_proxy(std::string* value);

  private:
  const std::string& _internal_gpt_proxy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpt_proxy(
      const std::string& value);
  std::string* _internal_mutable_gpt_proxy();

  public:
  // string gpt_model = 6;
  void clear_gpt_model() ;
  const std::string& gpt_model() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gpt_model(Arg_&& arg, Args_... args);
  std::string* mutable_gpt_model();
  PROTOBUF_NODISCARD std::string* release_gpt_model();
  void set_allocated_gpt_model(std::string* value);

  private:
  const std::string& _internal_gpt_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpt_model(
      const std::string& value);
  std::string* _internal_mutable_gpt_model();

  public:
  // string license_content = 7;
  void clear_license_content() ;
  const std::string& license_content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_license_content(Arg_&& arg, Args_... args);
  std::string* mutable_license_content();
  PROTOBUF_NODISCARD std::string* release_license_content();
  void set_allocated_license_content(std::string* value);

  private:
  const std::string& _internal_license_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_content(
      const std::string& value);
  std::string* _internal_mutable_license_content();

  public:
  // bool xpack_enabled = 1;
  void clear_xpack_enabled() ;
  bool xpack_enabled() const;
  void set_xpack_enabled(bool value);

  private:
  bool _internal_xpack_enabled() const;
  void _internal_set_xpack_enabled(bool value);

  public:
  // bool valid_license = 2;
  void clear_valid_license() ;
  bool valid_license() const;
  void set_valid_license(bool value);

  private:
  bool _internal_valid_license() const;
  void _internal_set_valid_license(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.PublicSetting)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      86, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PublicSetting_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PublicSetting& from_msg);
    ::google::protobuf::internal::ArenaStringPtr gpt_base_url_;
    ::google::protobuf::internal::ArenaStringPtr gpt_api_key_;
    ::google::protobuf::internal::ArenaStringPtr gpt_proxy_;
    ::google::protobuf::internal::ArenaStringPtr gpt_model_;
    ::google::protobuf::internal::ArenaStringPtr license_content_;
    bool xpack_enabled_;
    bool valid_license_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Protocol final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Protocol) */ {
 public:
  inline Protocol() : Protocol(nullptr) {}
  ~Protocol() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Protocol(
      ::google::protobuf::internal::ConstantInitialized);

  inline Protocol(const Protocol& from) : Protocol(nullptr, from) {}
  inline Protocol(Protocol&& from) noexcept
      : Protocol(nullptr, std::move(from)) {}
  inline Protocol& operator=(const Protocol& from) {
    CopyFrom(from);
    return *this;
  }
  inline Protocol& operator=(Protocol&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Protocol& default_instance() {
    return *internal_default_instance();
  }
  static inline const Protocol* internal_default_instance() {
    return reinterpret_cast<const Protocol*>(
        &_Protocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Protocol& a, Protocol& b) { a.Swap(&b); }
  inline void Swap(Protocol* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Protocol* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Protocol* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Protocol>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Protocol& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Protocol& from) { Protocol::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Protocol* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Protocol"; }

 protected:
  explicit Protocol(::google::protobuf::Arena* arena);
  Protocol(::google::protobuf::Arena* arena, const Protocol& from);
  Protocol(::google::protobuf::Arena* arena, Protocol&& from) noexcept
      : Protocol(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 port = 3;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.Protocol)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      29, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Protocol_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Protocol& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t id_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PlatformProtocol_SettingsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          PlatformProtocol_SettingsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      PlatformProtocol_SettingsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PlatformProtocol_SettingsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlatformProtocol_SettingsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PlatformProtocol_SettingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PlatformProtocol_SettingsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PlatformProtocol_SettingsEntry_DoNotUse*>(
        &_PlatformProtocol_SettingsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Permission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Permission(
      ::google::protobuf::internal::ConstantInitialized);

  inline Permission(const Permission& from) : Permission(nullptr, from) {}
  inline Permission(Permission&& from) noexcept
      : Permission(nullptr, std::move(from)) {}
  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
        &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Permission& a, Permission& b) { a.Swap(&b); }
  inline void Swap(Permission* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Permission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Permission& from) { Permission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Permission* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Permission"; }

 protected:
  explicit Permission(::google::protobuf::Arena* arena);
  Permission(::google::protobuf::Arena* arena, const Permission& from);
  Permission(::google::protobuf::Arena* arena, Permission&& from) noexcept
      : Permission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnableConnectFieldNumber = 1,
    kEnableDownloadFieldNumber = 2,
    kEnableUploadFieldNumber = 3,
    kEnableCopyFieldNumber = 4,
    kEnablePasteFieldNumber = 5,
  };
  // bool enable_connect = 1;
  void clear_enable_connect() ;
  bool enable_connect() const;
  void set_enable_connect(bool value);

  private:
  bool _internal_enable_connect() const;
  void _internal_set_enable_connect(bool value);

  public:
  // bool enable_download = 2;
  void clear_enable_download() ;
  bool enable_download() const;
  void set_enable_download(bool value);

  private:
  bool _internal_enable_download() const;
  void _internal_set_enable_download(bool value);

  public:
  // bool enable_upload = 3;
  void clear_enable_upload() ;
  bool enable_upload() const;
  void set_enable_upload(bool value);

  private:
  bool _internal_enable_upload() const;
  void _internal_set_enable_upload(bool value);

  public:
  // bool enable_copy = 4;
  void clear_enable_copy() ;
  bool enable_copy() const;
  void set_enable_copy(bool value);

  private:
  bool _internal_enable_copy() const;
  void _internal_set_enable_copy(bool value);

  public:
  // bool enable_paste = 5;
  void clear_enable_paste() ;
  bool enable_paste() const;
  void set_enable_paste(bool value);

  private:
  bool _internal_enable_paste() const;
  void _internal_set_enable_paste(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.Permission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Permission_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Permission& from_msg);
    bool enable_connect_;
    bool enable_download_;
    bool enable_upload_;
    bool enable_copy_;
    bool enable_paste_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class LifecycleLogData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.LifecycleLogData) */ {
 public:
  inline LifecycleLogData() : LifecycleLogData(nullptr) {}
  ~LifecycleLogData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LifecycleLogData(
      ::google::protobuf::internal::ConstantInitialized);

  inline LifecycleLogData(const LifecycleLogData& from) : LifecycleLogData(nullptr, from) {}
  inline LifecycleLogData(LifecycleLogData&& from) noexcept
      : LifecycleLogData(nullptr, std::move(from)) {}
  inline LifecycleLogData& operator=(const LifecycleLogData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LifecycleLogData& operator=(LifecycleLogData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LifecycleLogData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LifecycleLogData* internal_default_instance() {
    return reinterpret_cast<const LifecycleLogData*>(
        &_LifecycleLogData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(LifecycleLogData& a, LifecycleLogData& b) { a.Swap(&b); }
  inline void Swap(LifecycleLogData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LifecycleLogData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LifecycleLogData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LifecycleLogData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LifecycleLogData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LifecycleLogData& from) { LifecycleLogData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LifecycleLogData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.LifecycleLogData"; }

 protected:
  explicit LifecycleLogData(::google::protobuf::Arena* arena);
  LifecycleLogData(::google::protobuf::Arena* arena, const LifecycleLogData& from);
  LifecycleLogData(::google::protobuf::Arena* arena, LifecycleLogData&& from) noexcept
      : LifecycleLogData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using event_type = LifecycleLogData_event_type;
  static constexpr event_type AssetConnectSuccess = LifecycleLogData_event_type_AssetConnectSuccess;
  static constexpr event_type AssetConnectFinished = LifecycleLogData_event_type_AssetConnectFinished;
  static constexpr event_type CreateShareLink = LifecycleLogData_event_type_CreateShareLink;
  static constexpr event_type UserJoinSession = LifecycleLogData_event_type_UserJoinSession;
  static constexpr event_type UserLeaveSession = LifecycleLogData_event_type_UserLeaveSession;
  static constexpr event_type AdminJoinMonitor = LifecycleLogData_event_type_AdminJoinMonitor;
  static constexpr event_type AdminExitMonitor = LifecycleLogData_event_type_AdminExitMonitor;
  static constexpr event_type ReplayConvertStart = LifecycleLogData_event_type_ReplayConvertStart;
  static constexpr event_type ReplayConvertSuccess = LifecycleLogData_event_type_ReplayConvertSuccess;
  static constexpr event_type ReplayConvertFailure = LifecycleLogData_event_type_ReplayConvertFailure;
  static constexpr event_type ReplayUploadStart = LifecycleLogData_event_type_ReplayUploadStart;
  static constexpr event_type ReplayUploadSuccess = LifecycleLogData_event_type_ReplayUploadSuccess;
  static constexpr event_type ReplayUploadFailure = LifecycleLogData_event_type_ReplayUploadFailure;
  static inline bool event_type_IsValid(int value) {
    return LifecycleLogData_event_type_IsValid(value);
  }
  static constexpr event_type event_type_MIN = LifecycleLogData_event_type_event_type_MIN;
  static constexpr event_type event_type_MAX = LifecycleLogData_event_type_event_type_MAX;
  static constexpr int event_type_ARRAYSIZE = LifecycleLogData_event_type_event_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* event_type_descriptor() {
    return LifecycleLogData_event_type_descriptor();
  }
  template <typename T>
  static inline const std::string& event_type_Name(T value) {
    return LifecycleLogData_event_type_Name(value);
  }
  static inline bool event_type_Parse(absl::string_view name, event_type* value) {
    return LifecycleLogData_event_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 2,
    kUserFieldNumber = 3,
    kEventFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string user = 3;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // .message.LifecycleLogData.event_type event = 1;
  void clear_event() ;
  ::message::LifecycleLogData_event_type event() const;
  void set_event(::message::LifecycleLogData_event_type value);

  private:
  ::message::LifecycleLogData_event_type _internal_event() const;
  void _internal_set_event(::message::LifecycleLogData_event_type value);

  public:
  // @@protoc_insertion_point(class_scope:message.LifecycleLogData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LifecycleLogData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LifecycleLogData& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    int event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class LabelValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.LabelValue) */ {
 public:
  inline LabelValue() : LabelValue(nullptr) {}
  ~LabelValue() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LabelValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline LabelValue(const LabelValue& from) : LabelValue(nullptr, from) {}
  inline LabelValue(LabelValue&& from) noexcept
      : LabelValue(nullptr, std::move(from)) {}
  inline LabelValue& operator=(const LabelValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelValue& operator=(LabelValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelValue* internal_default_instance() {
    return reinterpret_cast<const LabelValue*>(
        &_LabelValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LabelValue& a, LabelValue& b) { a.Swap(&b); }
  inline void Swap(LabelValue* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LabelValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LabelValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LabelValue& from) { LabelValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LabelValue* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.LabelValue"; }

 protected:
  explicit LabelValue(::google::protobuf::Arena* arena);
  LabelValue(::google::protobuf::Arena* arena, const LabelValue& from);
  LabelValue(::google::protobuf::Arena* arena, LabelValue&& from) noexcept
      : LabelValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLabelFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string label = 1;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:message.LabelValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_LabelValue_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LabelValue& from_msg);
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Gateway final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Gateway) */ {
 public:
  inline Gateway() : Gateway(nullptr) {}
  ~Gateway() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Gateway(
      ::google::protobuf::internal::ConstantInitialized);

  inline Gateway(const Gateway& from) : Gateway(nullptr, from) {}
  inline Gateway(Gateway&& from) noexcept
      : Gateway(nullptr, std::move(from)) {}
  inline Gateway& operator=(const Gateway& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gateway& operator=(Gateway&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gateway& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gateway* internal_default_instance() {
    return reinterpret_cast<const Gateway*>(
        &_Gateway_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Gateway& a, Gateway& b) { a.Swap(&b); }
  inline void Swap(Gateway* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gateway* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gateway* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Gateway>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Gateway& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Gateway& from) { Gateway::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Gateway* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Gateway"; }

 protected:
  explicit Gateway(::google::protobuf::Arena* arena);
  Gateway(::google::protobuf::Arena* arena, const Gateway& from);
  Gateway(::google::protobuf::Arena* arena, Gateway&& from) noexcept
      : Gateway(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kIpFieldNumber = 3,
    kProtocolFieldNumber = 5,
    kUsernameFieldNumber = 6,
    kPasswordFieldNumber = 7,
    kPrivateKeyFieldNumber = 8,
    kPortFieldNumber = 4,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string ip = 3;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string protocol = 5;
  void clear_protocol() ;
  const std::string& protocol() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol(Arg_&& arg, Args_... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* value);

  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(
      const std::string& value);
  std::string* _internal_mutable_protocol();

  public:
  // string username = 6;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 7;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string private_key = 8;
  void clear_private_key() ;
  const std::string& private_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_private_key(Arg_&& arg, Args_... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* value);

  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(
      const std::string& value);
  std::string* _internal_mutable_private_key();

  public:
  // int32 port = 4;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.Gateway)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      75, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Gateway_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Gateway& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr protocol_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr private_key_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Forward final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Forward) */ {
 public:
  inline Forward() : Forward(nullptr) {}
  ~Forward() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Forward(
      ::google::protobuf::internal::ConstantInitialized);

  inline Forward(const Forward& from) : Forward(nullptr, from) {}
  inline Forward(Forward&& from) noexcept
      : Forward(nullptr, std::move(from)) {}
  inline Forward& operator=(const Forward& from) {
    CopyFrom(from);
    return *this;
  }
  inline Forward& operator=(Forward&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Forward& default_instance() {
    return *internal_default_instance();
  }
  static inline const Forward* internal_default_instance() {
    return reinterpret_cast<const Forward*>(
        &_Forward_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Forward& a, Forward& b) { a.Swap(&b); }
  inline void Swap(Forward* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Forward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Forward* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Forward>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Forward& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Forward& from) { Forward::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Forward* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Forward"; }

 protected:
  explicit Forward(::google::protobuf::Arena* arena);
  Forward(::google::protobuf::Arena* arena, const Forward& from);
  Forward(::google::protobuf::Arena* arena, Forward&& from) noexcept
      : Forward(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kHostFieldNumber = 2,
    kPortFieldNumber = 3,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string Host = 2;
  void clear_host() ;
  const std::string& host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* value);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // int32 port = 3;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.Forward)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      30, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Forward_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Forward& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ExpireInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ExpireInfo) */ {
 public:
  inline ExpireInfo() : ExpireInfo(nullptr) {}
  ~ExpireInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpireInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpireInfo(const ExpireInfo& from) : ExpireInfo(nullptr, from) {}
  inline ExpireInfo(ExpireInfo&& from) noexcept
      : ExpireInfo(nullptr, std::move(from)) {}
  inline ExpireInfo& operator=(const ExpireInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpireInfo& operator=(ExpireInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpireInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpireInfo* internal_default_instance() {
    return reinterpret_cast<const ExpireInfo*>(
        &_ExpireInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ExpireInfo& a, ExpireInfo& b) { a.Swap(&b); }
  inline void Swap(ExpireInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpireInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpireInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExpireInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpireInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpireInfo& from) { ExpireInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExpireInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ExpireInfo"; }

 protected:
  explicit ExpireInfo(::google::protobuf::Arena* arena);
  ExpireInfo(::google::protobuf::Arena* arena, const ExpireInfo& from);
  ExpireInfo(::google::protobuf::Arena* arena, ExpireInfo&& from) noexcept
      : ExpireInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpireAtFieldNumber = 1,
  };
  // int64 expire_at = 1;
  void clear_expire_at() ;
  ::int64_t expire_at() const;
  void set_expire_at(::int64_t value);

  private:
  ::int64_t _internal_expire_at() const;
  void _internal_set_expire_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.ExpireInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ExpireInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpireInfo& from_msg);
    ::int64_t expire_at_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Cookie final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Cookie) */ {
 public:
  inline Cookie() : Cookie(nullptr) {}
  ~Cookie() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Cookie(
      ::google::protobuf::internal::ConstantInitialized);

  inline Cookie(const Cookie& from) : Cookie(nullptr, from) {}
  inline Cookie(Cookie&& from) noexcept
      : Cookie(nullptr, std::move(from)) {}
  inline Cookie& operator=(const Cookie& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cookie& operator=(Cookie&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cookie& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cookie* internal_default_instance() {
    return reinterpret_cast<const Cookie*>(
        &_Cookie_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(Cookie& a, Cookie& b) { a.Swap(&b); }
  inline void Swap(Cookie* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cookie* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cookie* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Cookie>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Cookie& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Cookie& from) { Cookie::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Cookie* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Cookie"; }

 protected:
  explicit Cookie(::google::protobuf::Arena* arena);
  Cookie(::google::protobuf::Arena* arena, const Cookie& from);
  Cookie(::google::protobuf::Arena* arena, Cookie&& from) noexcept
      : Cookie(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:message.Cookie)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      32, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Cookie_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Cookie& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ComponentSetting final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.ComponentSetting) */ {
 public:
  inline ComponentSetting() : ComponentSetting(nullptr) {}
  ~ComponentSetting() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ComponentSetting(
      ::google::protobuf::internal::ConstantInitialized);

  inline ComponentSetting(const ComponentSetting& from) : ComponentSetting(nullptr, from) {}
  inline ComponentSetting(ComponentSetting&& from) noexcept
      : ComponentSetting(nullptr, std::move(from)) {}
  inline ComponentSetting& operator=(const ComponentSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentSetting& operator=(ComponentSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComponentSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComponentSetting* internal_default_instance() {
    return reinterpret_cast<const ComponentSetting*>(
        &_ComponentSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ComponentSetting& a, ComponentSetting& b) { a.Swap(&b); }
  inline void Swap(ComponentSetting* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComponentSetting* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComponentSetting* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ComponentSetting>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComponentSetting& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ComponentSetting& from) { ComponentSetting::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComponentSetting* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.ComponentSetting"; }

 protected:
  explicit ComponentSetting(::google::protobuf::Arena* arena);
  ComponentSetting(::google::protobuf::Arena* arena, const ComponentSetting& from);
  ComponentSetting(::google::protobuf::Arena* arena, ComponentSetting&& from) noexcept
      : ComponentSetting(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxIdleTimeFieldNumber = 1,
    kMaxSessionTimeFieldNumber = 2,
  };
  // int32 max_idle_time = 1;
  void clear_max_idle_time() ;
  ::int32_t max_idle_time() const;
  void set_max_idle_time(::int32_t value);

  private:
  ::int32_t _internal_max_idle_time() const;
  void _internal_set_max_idle_time(::int32_t value);

  public:
  // int32 max_session_time = 2;
  void clear_max_session_time() ;
  ::int32_t max_session_time() const;
  void set_max_session_time(::int32_t value);

  private:
  ::int32_t _internal_max_session_time() const;
  void _internal_set_max_session_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.ComponentSetting)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ComponentSetting_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ComponentSetting& from_msg);
    ::int32_t max_idle_time_;
    ::int32_t max_session_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CommandGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandGroup) */ {
 public:
  inline CommandGroup() : CommandGroup(nullptr) {}
  ~CommandGroup() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGroup(const CommandGroup& from) : CommandGroup(nullptr, from) {}
  inline CommandGroup(CommandGroup&& from) noexcept
      : CommandGroup(nullptr, std::move(from)) {}
  inline CommandGroup& operator=(const CommandGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGroup& operator=(CommandGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGroup* internal_default_instance() {
    return reinterpret_cast<const CommandGroup*>(
        &_CommandGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CommandGroup& a, CommandGroup& b) { a.Swap(&b); }
  inline void Swap(CommandGroup* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGroup& from) { CommandGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGroup* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandGroup"; }

 protected:
  explicit CommandGroup(::google::protobuf::Arena* arena);
  CommandGroup(::google::protobuf::Arena* arena, const CommandGroup& from);
  CommandGroup(::google::protobuf::Arena* arena, CommandGroup&& from) noexcept
      : CommandGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kContentFieldNumber = 3,
    kTypeFieldNumber = 4,
    kPatternFieldNumber = 5,
    kIgnoreCaseFieldNumber = 6,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string content = 3;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // string Type = 4;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string pattern = 5;
  void clear_pattern() ;
  const std::string& pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* value);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // bool ignore_case = 6;
  void clear_ignore_case() ;
  bool ignore_case() const;
  void set_ignore_case(bool value);

  private:
  bool _internal_ignore_case() const;
  void _internal_set_ignore_case(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.CommandGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      53, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandGroup_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGroup& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    bool ignore_case_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Asset_Specific final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Asset.Specific) */ {
 public:
  inline Asset_Specific() : Asset_Specific(nullptr) {}
  ~Asset_Specific() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Asset_Specific(
      ::google::protobuf::internal::ConstantInitialized);

  inline Asset_Specific(const Asset_Specific& from) : Asset_Specific(nullptr, from) {}
  inline Asset_Specific(Asset_Specific&& from) noexcept
      : Asset_Specific(nullptr, std::move(from)) {}
  inline Asset_Specific& operator=(const Asset_Specific& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset_Specific& operator=(Asset_Specific&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset_Specific& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset_Specific* internal_default_instance() {
    return reinterpret_cast<const Asset_Specific*>(
        &_Asset_Specific_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Asset_Specific& a, Asset_Specific& b) { a.Swap(&b); }
  inline void Swap(Asset_Specific* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset_Specific* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset_Specific* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Asset_Specific>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Asset_Specific& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Asset_Specific& from) { Asset_Specific::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Asset_Specific* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Asset.Specific"; }

 protected:
  explicit Asset_Specific(::google::protobuf::Arena* arena);
  Asset_Specific(::google::protobuf::Arena* arena, const Asset_Specific& from);
  Asset_Specific(::google::protobuf::Arena* arena, Asset_Specific&& from) noexcept
      : Asset_Specific(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDbNameFieldNumber = 1,
    kCaCertFieldNumber = 3,
    kClientCertFieldNumber = 4,
    kClientKeyFieldNumber = 5,
    kAutoFillFieldNumber = 7,
    kUsernameSelectorFieldNumber = 8,
    kPasswordSelectorFieldNumber = 9,
    kSubmitSelectorFieldNumber = 10,
    kScriptFieldNumber = 11,
    kHttpProxyFieldNumber = 12,
    kPgSslModeFieldNumber = 13,
    kUseSslFieldNumber = 2,
    kAllowInvalidCertFieldNumber = 6,
  };
  // string db_name = 1;
  void clear_db_name() ;
  const std::string& db_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_name(Arg_&& arg, Args_... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* value);

  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(
      const std::string& value);
  std::string* _internal_mutable_db_name();

  public:
  // string ca_cert = 3;
  void clear_ca_cert() ;
  const std::string& ca_cert() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ca_cert(Arg_&& arg, Args_... args);
  std::string* mutable_ca_cert();
  PROTOBUF_NODISCARD std::string* release_ca_cert();
  void set_allocated_ca_cert(std::string* value);

  private:
  const std::string& _internal_ca_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ca_cert(
      const std::string& value);
  std::string* _internal_mutable_ca_cert();

  public:
  // string client_cert = 4;
  void clear_client_cert() ;
  const std::string& client_cert() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_cert(Arg_&& arg, Args_... args);
  std::string* mutable_client_cert();
  PROTOBUF_NODISCARD std::string* release_client_cert();
  void set_allocated_client_cert(std::string* value);

  private:
  const std::string& _internal_client_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_cert(
      const std::string& value);
  std::string* _internal_mutable_client_cert();

  public:
  // string client_key = 5;
  void clear_client_key() ;
  const std::string& client_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_key(Arg_&& arg, Args_... args);
  std::string* mutable_client_key();
  PROTOBUF_NODISCARD std::string* release_client_key();
  void set_allocated_client_key(std::string* value);

  private:
  const std::string& _internal_client_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_key(
      const std::string& value);
  std::string* _internal_mutable_client_key();

  public:
  // string auto_fill = 7;
  void clear_auto_fill() ;
  const std::string& auto_fill() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auto_fill(Arg_&& arg, Args_... args);
  std::string* mutable_auto_fill();
  PROTOBUF_NODISCARD std::string* release_auto_fill();
  void set_allocated_auto_fill(std::string* value);

  private:
  const std::string& _internal_auto_fill() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auto_fill(
      const std::string& value);
  std::string* _internal_mutable_auto_fill();

  public:
  // string username_selector = 8;
  void clear_username_selector() ;
  const std::string& username_selector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username_selector(Arg_&& arg, Args_... args);
  std::string* mutable_username_selector();
  PROTOBUF_NODISCARD std::string* release_username_selector();
  void set_allocated_username_selector(std::string* value);

  private:
  const std::string& _internal_username_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username_selector(
      const std::string& value);
  std::string* _internal_mutable_username_selector();

  public:
  // string password_selector = 9;
  void clear_password_selector() ;
  const std::string& password_selector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password_selector(Arg_&& arg, Args_... args);
  std::string* mutable_password_selector();
  PROTOBUF_NODISCARD std::string* release_password_selector();
  void set_allocated_password_selector(std::string* value);

  private:
  const std::string& _internal_password_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password_selector(
      const std::string& value);
  std::string* _internal_mutable_password_selector();

  public:
  // string submit_selector = 10;
  void clear_submit_selector() ;
  const std::string& submit_selector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_submit_selector(Arg_&& arg, Args_... args);
  std::string* mutable_submit_selector();
  PROTOBUF_NODISCARD std::string* release_submit_selector();
  void set_allocated_submit_selector(std::string* value);

  private:
  const std::string& _internal_submit_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_submit_selector(
      const std::string& value);
  std::string* _internal_mutable_submit_selector();

  public:
  // string script = 11;
  void clear_script() ;
  const std::string& script() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_script(Arg_&& arg, Args_... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* value);

  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(
      const std::string& value);
  std::string* _internal_mutable_script();

  public:
  // string http_proxy = 12;
  void clear_http_proxy() ;
  const std::string& http_proxy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_http_proxy(Arg_&& arg, Args_... args);
  std::string* mutable_http_proxy();
  PROTOBUF_NODISCARD std::string* release_http_proxy();
  void set_allocated_http_proxy(std::string* value);

  private:
  const std::string& _internal_http_proxy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_http_proxy(
      const std::string& value);
  std::string* _internal_mutable_http_proxy();

  public:
  // string pg_ssl_mode = 13;
  void clear_pg_ssl_mode() ;
  const std::string& pg_ssl_mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pg_ssl_mode(Arg_&& arg, Args_... args);
  std::string* mutable_pg_ssl_mode();
  PROTOBUF_NODISCARD std::string* release_pg_ssl_mode();
  void set_allocated_pg_ssl_mode(std::string* value);

  private:
  const std::string& _internal_pg_ssl_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pg_ssl_mode(
      const std::string& value);
  std::string* _internal_mutable_pg_ssl_mode();

  public:
  // bool use_ssl = 2;
  void clear_use_ssl() ;
  bool use_ssl() const;
  void set_use_ssl(bool value);

  private:
  bool _internal_use_ssl() const;
  void _internal_set_use_ssl(bool value);

  public:
  // bool allow_invalid_cert = 6;
  void clear_allow_invalid_cert() ;
  bool allow_invalid_cert() const;
  void set_allow_invalid_cert(bool value);

  private:
  bool _internal_allow_invalid_cert() const;
  void _internal_set_allow_invalid_cert(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.Asset.Specific)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      159, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Asset_Specific_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Asset_Specific& from_msg);
    ::google::protobuf::internal::ArenaStringPtr db_name_;
    ::google::protobuf::internal::ArenaStringPtr ca_cert_;
    ::google::protobuf::internal::ArenaStringPtr client_cert_;
    ::google::protobuf::internal::ArenaStringPtr client_key_;
    ::google::protobuf::internal::ArenaStringPtr auto_fill_;
    ::google::protobuf::internal::ArenaStringPtr username_selector_;
    ::google::protobuf::internal::ArenaStringPtr password_selector_;
    ::google::protobuf::internal::ArenaStringPtr submit_selector_;
    ::google::protobuf::internal::ArenaStringPtr script_;
    ::google::protobuf::internal::ArenaStringPtr http_proxy_;
    ::google::protobuf::internal::ArenaStringPtr pg_ssl_mode_;
    bool use_ssl_;
    bool allow_invalid_cert_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TerminalTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TerminalTask) */ {
 public:
  inline TerminalTask() : TerminalTask(nullptr) {}
  ~TerminalTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TerminalTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline TerminalTask(const TerminalTask& from) : TerminalTask(nullptr, from) {}
  inline TerminalTask(TerminalTask&& from) noexcept
      : TerminalTask(nullptr, std::move(from)) {}
  inline TerminalTask& operator=(const TerminalTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminalTask& operator=(TerminalTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TerminalTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const TerminalTask* internal_default_instance() {
    return reinterpret_cast<const TerminalTask*>(
        &_TerminalTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TerminalTask& a, TerminalTask& b) { a.Swap(&b); }
  inline void Swap(TerminalTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminalTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TerminalTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TerminalTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TerminalTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TerminalTask& from) { TerminalTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TerminalTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TerminalTask"; }

 protected:
  explicit TerminalTask(::google::protobuf::Arena* arena);
  TerminalTask(::google::protobuf::Arena* arena, const TerminalTask& from);
  TerminalTask(::google::protobuf::Arena* arena, TerminalTask&& from) noexcept
      : TerminalTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kTerminatedByFieldNumber = 4,
    kCreatedByFieldNumber = 5,
    kTokenStatusFieldNumber = 6,
    kActionFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string session_id = 3;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string terminated_by = 4;
  void clear_terminated_by() ;
  const std::string& terminated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_terminated_by(Arg_&& arg, Args_... args);
  std::string* mutable_terminated_by();
  PROTOBUF_NODISCARD std::string* release_terminated_by();
  void set_allocated_terminated_by(std::string* value);

  private:
  const std::string& _internal_terminated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terminated_by(
      const std::string& value);
  std::string* _internal_mutable_terminated_by();

  public:
  // string created_by = 5;
  void clear_created_by() ;
  const std::string& created_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_by(Arg_&& arg, Args_... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* value);

  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(
      const std::string& value);
  std::string* _internal_mutable_created_by();

  public:
  // .message.TokenStatus token_status = 6;
  bool has_token_status() const;
  void clear_token_status() ;
  const ::message::TokenStatus& token_status() const;
  PROTOBUF_NODISCARD ::message::TokenStatus* release_token_status();
  ::message::TokenStatus* mutable_token_status();
  void set_allocated_token_status(::message::TokenStatus* value);
  void unsafe_arena_set_allocated_token_status(::message::TokenStatus* value);
  ::message::TokenStatus* unsafe_arena_release_token_status();

  private:
  const ::message::TokenStatus& _internal_token_status() const;
  ::message::TokenStatus* _internal_mutable_token_status();

  public:
  // .message.TaskAction action = 2;
  void clear_action() ;
  ::message::TaskAction action() const;
  void set_action(::message::TaskAction value);

  private:
  ::message::TaskAction _internal_action() const;
  void _internal_set_action(::message::TaskAction value);

  public:
  // @@protoc_insertion_point(class_scope:message.TerminalTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      64, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TerminalTask_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TerminalTask& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr terminated_by_;
    ::google::protobuf::internal::ArenaStringPtr created_by_;
    ::message::TokenStatus* token_status_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PlatformProtocol final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.PlatformProtocol) */ {
 public:
  inline PlatformProtocol() : PlatformProtocol(nullptr) {}
  ~PlatformProtocol() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlatformProtocol(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlatformProtocol(const PlatformProtocol& from) : PlatformProtocol(nullptr, from) {}
  inline PlatformProtocol(PlatformProtocol&& from) noexcept
      : PlatformProtocol(nullptr, std::move(from)) {}
  inline PlatformProtocol& operator=(const PlatformProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatformProtocol& operator=(PlatformProtocol&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatformProtocol& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatformProtocol* internal_default_instance() {
    return reinterpret_cast<const PlatformProtocol*>(
        &_PlatformProtocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(PlatformProtocol& a, PlatformProtocol& b) { a.Swap(&b); }
  inline void Swap(PlatformProtocol* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatformProtocol* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatformProtocol* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlatformProtocol>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlatformProtocol& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlatformProtocol& from) { PlatformProtocol::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlatformProtocol* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.PlatformProtocol"; }

 protected:
  explicit PlatformProtocol(::google::protobuf::Arena* arena);
  PlatformProtocol(::google::protobuf::Arena* arena, const PlatformProtocol& from);
  PlatformProtocol(::google::protobuf::Arena* arena, PlatformProtocol&& from) noexcept
      : PlatformProtocol(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSettingsFieldNumber = 4,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // map<string, string> settings = 4;
  int settings_size() const;
  private:
  int _internal_settings_size() const;

  public:
  void clear_settings() ;
  const ::google::protobuf::Map<std::string, std::string>& settings() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_settings();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_settings() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_settings();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 port = 3;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.PlatformProtocol)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlatformProtocol_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlatformProtocol& from_msg);
    ::google::protobuf::internal::MapField<PlatformProtocol_SettingsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        settings_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t id_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CommandACL final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.CommandACL) */ {
 public:
  inline CommandACL() : CommandACL(nullptr) {}
  ~CommandACL() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandACL(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandACL(const CommandACL& from) : CommandACL(nullptr, from) {}
  inline CommandACL(CommandACL&& from) noexcept
      : CommandACL(nullptr, std::move(from)) {}
  inline CommandACL& operator=(const CommandACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandACL& operator=(CommandACL&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandACL& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandACL* internal_default_instance() {
    return reinterpret_cast<const CommandACL*>(
        &_CommandACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CommandACL& a, CommandACL& b) { a.Swap(&b); }
  inline void Swap(CommandACL* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandACL* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandACL* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CommandACL>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandACL& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandACL& from) { CommandACL::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandACL* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.CommandACL"; }

 protected:
  explicit CommandACL(::google::protobuf::Arena* arena);
  CommandACL(::google::protobuf::Arena* arena, const CommandACL& from);
  CommandACL(::google::protobuf::Arena* arena, CommandACL&& from) noexcept
      : CommandACL(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Action = CommandACL_Action;
  static constexpr Action Reject = CommandACL_Action_Reject;
  static constexpr Action Accept = CommandACL_Action_Accept;
  static constexpr Action Review = CommandACL_Action_Review;
  static constexpr Action Warning = CommandACL_Action_Warning;
  static constexpr Action NotifyWarning = CommandACL_Action_NotifyWarning;
  static constexpr Action Unknown = CommandACL_Action_Unknown;
  static inline bool Action_IsValid(int value) {
    return CommandACL_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = CommandACL_Action_Action_MIN;
  static constexpr Action Action_MAX = CommandACL_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = CommandACL_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Action_descriptor() {
    return CommandACL_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return CommandACL_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return CommandACL_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCommandGroupsFieldNumber = 7,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kPriorityFieldNumber = 3,
    kActionFieldNumber = 5,
    kIsActiveFieldNumber = 6,
  };
  // repeated .message.CommandGroup command_groups = 7;
  int command_groups_size() const;
  private:
  int _internal_command_groups_size() const;

  public:
  void clear_command_groups() ;
  ::message::CommandGroup* mutable_command_groups(int index);
  ::google::protobuf::RepeatedPtrField<::message::CommandGroup>* mutable_command_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::CommandGroup>& _internal_command_groups() const;
  ::google::protobuf::RepeatedPtrField<::message::CommandGroup>* _internal_mutable_command_groups();
  public:
  const ::message::CommandGroup& command_groups(int index) const;
  ::message::CommandGroup* add_command_groups();
  const ::google::protobuf::RepeatedPtrField<::message::CommandGroup>& command_groups() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 priority = 3;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // .message.CommandACL.Action action = 5;
  void clear_action() ;
  ::message::CommandACL_Action action() const;
  void set_action(::message::CommandACL_Action value);

  private:
  ::message::CommandACL_Action _internal_action() const;
  void _internal_set_action(::message::CommandACL_Action value);

  public:
  // bool is_active = 6;
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:message.CommandACL)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CommandACL_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandACL& from_msg);
    ::google::protobuf::RepeatedPtrField< ::message::CommandGroup > command_groups_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t priority_;
    int action_;
    bool is_active_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Asset final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Asset) */ {
 public:
  inline Asset() : Asset(nullptr) {}
  ~Asset() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Asset(
      ::google::protobuf::internal::ConstantInitialized);

  inline Asset(const Asset& from) : Asset(nullptr, from) {}
  inline Asset(Asset&& from) noexcept
      : Asset(nullptr, std::move(from)) {}
  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
        &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Asset& a, Asset& b) { a.Swap(&b); }
  inline void Swap(Asset* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Asset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Asset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Asset& from) { Asset::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Asset* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Asset"; }

 protected:
  explicit Asset(::google::protobuf::Arena* arena);
  Asset(::google::protobuf::Arena* arena, const Asset& from);
  Asset(::google::protobuf::Arena* arena, Asset&& from) noexcept
      : Asset(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Specific = Asset_Specific;

  // accessors -------------------------------------------------------
  enum : int {
    kProtocolsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kAddressFieldNumber = 3,
    kOrgIdFieldNumber = 4,
    kOrgNameFieldNumber = 5,
    kSpecificFieldNumber = 7,
  };
  // repeated .message.Protocol protocols = 6;
  int protocols_size() const;
  private:
  int _internal_protocols_size() const;

  public:
  void clear_protocols() ;
  ::message::Protocol* mutable_protocols(int index);
  ::google::protobuf::RepeatedPtrField<::message::Protocol>* mutable_protocols();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::Protocol>& _internal_protocols() const;
  ::google::protobuf::RepeatedPtrField<::message::Protocol>* _internal_mutable_protocols();
  public:
  const ::message::Protocol& protocols(int index) const;
  ::message::Protocol* add_protocols();
  const ::google::protobuf::RepeatedPtrField<::message::Protocol>& protocols() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 3;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string org_id = 4;
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* value);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string org_name = 5;
  void clear_org_name() ;
  const std::string& org_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_name(Arg_&& arg, Args_... args);
  std::string* mutable_org_name();
  PROTOBUF_NODISCARD std::string* release_org_name();
  void set_allocated_org_name(std::string* value);

  private:
  const std::string& _internal_org_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_name(
      const std::string& value);
  std::string* _internal_mutable_org_name();

  public:
  // .message.Asset.Specific specific = 7;
  bool has_specific() const;
  void clear_specific() ;
  const ::message::Asset_Specific& specific() const;
  PROTOBUF_NODISCARD ::message::Asset_Specific* release_specific();
  ::message::Asset_Specific* mutable_specific();
  void set_allocated_specific(::message::Asset_Specific* value);
  void unsafe_arena_set_allocated_specific(::message::Asset_Specific* value);
  ::message::Asset_Specific* unsafe_arena_release_specific();

  private:
  const ::message::Asset_Specific& _internal_specific() const;
  ::message::Asset_Specific* _internal_mutable_specific();

  public:
  // @@protoc_insertion_point(class_scope:message.Asset)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Asset_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Asset& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::message::Protocol > protocols_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr org_name_;
    ::message::Asset_Specific* specific_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Account final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Account(
      ::google::protobuf::internal::ConstantInitialized);

  inline Account(const Account& from) : Account(nullptr, from) {}
  inline Account(Account&& from) noexcept
      : Account(nullptr, std::move(from)) {}
  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
        &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Account& a, Account& b) { a.Swap(&b); }
  inline void Swap(Account* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Account>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Account& from) { Account::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Account* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Account"; }

 protected:
  explicit Account(::google::protobuf::Arena* arena);
  Account(::google::protobuf::Arena* arena, const Account& from);
  Account(::google::protobuf::Arena* arena, Account&& from) noexcept
      : Account(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kSecretFieldNumber = 5,
    kSecretTypeFieldNumber = 6,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string username = 4;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string secret = 5;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .message.LabelValue secretType = 6;
  bool has_secrettype() const;
  void clear_secrettype() ;
  const ::message::LabelValue& secrettype() const;
  PROTOBUF_NODISCARD ::message::LabelValue* release_secrettype();
  ::message::LabelValue* mutable_secrettype();
  void set_allocated_secrettype(::message::LabelValue* value);
  void unsafe_arena_set_allocated_secrettype(::message::LabelValue* value);
  ::message::LabelValue* unsafe_arena_release_secrettype();

  private:
  const ::message::LabelValue& _internal_secrettype() const;
  ::message::LabelValue* _internal_mutable_secrettype();

  public:
  // @@protoc_insertion_point(class_scope:message.Account)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Account_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Account& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::message::LabelValue* secrettype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Platform final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.Platform) */ {
 public:
  inline Platform() : Platform(nullptr) {}
  ~Platform() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Platform(
      ::google::protobuf::internal::ConstantInitialized);

  inline Platform(const Platform& from) : Platform(nullptr, from) {}
  inline Platform(Platform&& from) noexcept
      : Platform(nullptr, std::move(from)) {}
  inline Platform& operator=(const Platform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Platform& operator=(Platform&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Platform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Platform* internal_default_instance() {
    return reinterpret_cast<const Platform*>(
        &_Platform_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Platform& a, Platform& b) { a.Swap(&b); }
  inline void Swap(Platform* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Platform* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Platform* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Platform>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Platform& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Platform& from) { Platform::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Platform* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.Platform"; }

 protected:
  explicit Platform(::google::protobuf::Arena* arena);
  Platform(::google::protobuf::Arena* arena, const Platform& from);
  Platform(::google::protobuf::Arena* arena, Platform&& from) noexcept
      : Platform(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProtocolsFieldNumber = 6,
    kNameFieldNumber = 2,
    kCategoryFieldNumber = 3,
    kCharsetFieldNumber = 4,
    kTypeFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // repeated .message.PlatformProtocol protocols = 6;
  int protocols_size() const;
  private:
  int _internal_protocols_size() const;

  public:
  void clear_protocols() ;
  ::message::PlatformProtocol* mutable_protocols(int index);
  ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>* mutable_protocols();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>& _internal_protocols() const;
  ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>* _internal_mutable_protocols();
  public:
  const ::message::PlatformProtocol& protocols(int index) const;
  ::message::PlatformProtocol* add_protocols();
  const ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>& protocols() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string category = 3;
  void clear_category() ;
  const std::string& category() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category(Arg_&& arg, Args_... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* value);

  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(
      const std::string& value);
  std::string* _internal_mutable_category();

  public:
  // string charset = 4;
  void clear_charset() ;
  const std::string& charset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_charset(Arg_&& arg, Args_... args);
  std::string* mutable_charset();
  PROTOBUF_NODISCARD std::string* release_charset();
  void set_allocated_charset(std::string* value);

  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(
      const std::string& value);
  std::string* _internal_mutable_charset();

  public:
  // string type = 5;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.Platform)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      48, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Platform_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Platform& from_msg);
    ::google::protobuf::RepeatedPtrField< ::message::PlatformProtocol > protocols_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr category_;
    ::google::protobuf::internal::ArenaStringPtr charset_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TokenAuthInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:message.TokenAuthInfo) */ {
 public:
  inline TokenAuthInfo() : TokenAuthInfo(nullptr) {}
  ~TokenAuthInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TokenAuthInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TokenAuthInfo(const TokenAuthInfo& from) : TokenAuthInfo(nullptr, from) {}
  inline TokenAuthInfo(TokenAuthInfo&& from) noexcept
      : TokenAuthInfo(nullptr, std::move(from)) {}
  inline TokenAuthInfo& operator=(const TokenAuthInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenAuthInfo& operator=(TokenAuthInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenAuthInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenAuthInfo* internal_default_instance() {
    return reinterpret_cast<const TokenAuthInfo*>(
        &_TokenAuthInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TokenAuthInfo& a, TokenAuthInfo& b) { a.Swap(&b); }
  inline void Swap(TokenAuthInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenAuthInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenAuthInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TokenAuthInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TokenAuthInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TokenAuthInfo& from) { TokenAuthInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TokenAuthInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "message.TokenAuthInfo"; }

 protected:
  explicit TokenAuthInfo(::google::protobuf::Arena* arena);
  TokenAuthInfo(::google::protobuf::Arena* arena, const TokenAuthInfo& from);
  TokenAuthInfo(::google::protobuf::Arena* arena, TokenAuthInfo&& from) noexcept
      : TokenAuthInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterRulesFieldNumber = 8,
    kGatewaysFieldNumber = 9,
    kKeyIdFieldNumber = 1,
    kSecreteIdFieldNumber = 2,
    kFaceMonitorTokenFieldNumber = 12,
    kAssetFieldNumber = 3,
    kUserFieldNumber = 4,
    kAccountFieldNumber = 5,
    kPermissionFieldNumber = 6,
    kExpireInfoFieldNumber = 7,
    kSettingFieldNumber = 10,
    kPlatformFieldNumber = 11,
  };
  // repeated .message.CommandACL filter_rules = 8;
  int filter_rules_size() const;
  private:
  int _internal_filter_rules_size() const;

  public:
  void clear_filter_rules() ;
  ::message::CommandACL* mutable_filter_rules(int index);
  ::google::protobuf::RepeatedPtrField<::message::CommandACL>* mutable_filter_rules();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::CommandACL>& _internal_filter_rules() const;
  ::google::protobuf::RepeatedPtrField<::message::CommandACL>* _internal_mutable_filter_rules();
  public:
  const ::message::CommandACL& filter_rules(int index) const;
  ::message::CommandACL* add_filter_rules();
  const ::google::protobuf::RepeatedPtrField<::message::CommandACL>& filter_rules() const;
  // repeated .message.Gateway gateways = 9;
  int gateways_size() const;
  private:
  int _internal_gateways_size() const;

  public:
  void clear_gateways() ;
  ::message::Gateway* mutable_gateways(int index);
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* mutable_gateways();

  private:
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& _internal_gateways() const;
  ::google::protobuf::RepeatedPtrField<::message::Gateway>* _internal_mutable_gateways();
  public:
  const ::message::Gateway& gateways(int index) const;
  ::message::Gateway* add_gateways();
  const ::google::protobuf::RepeatedPtrField<::message::Gateway>& gateways() const;
  // string key_id = 1;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // string secrete_id = 2;
  void clear_secrete_id() ;
  const std::string& secrete_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secrete_id(Arg_&& arg, Args_... args);
  std::string* mutable_secrete_id();
  PROTOBUF_NODISCARD std::string* release_secrete_id();
  void set_allocated_secrete_id(std::string* value);

  private:
  const std::string& _internal_secrete_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secrete_id(
      const std::string& value);
  std::string* _internal_mutable_secrete_id();

  public:
  // string FaceMonitorToken = 12;
  void clear_facemonitortoken() ;
  const std::string& facemonitortoken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_facemonitortoken(Arg_&& arg, Args_... args);
  std::string* mutable_facemonitortoken();
  PROTOBUF_NODISCARD std::string* release_facemonitortoken();
  void set_allocated_facemonitortoken(std::string* value);

  private:
  const std::string& _internal_facemonitortoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_facemonitortoken(
      const std::string& value);
  std::string* _internal_mutable_facemonitortoken();

  public:
  // .message.Asset asset = 3;
  bool has_asset() const;
  void clear_asset() ;
  const ::message::Asset& asset() const;
  PROTOBUF_NODISCARD ::message::Asset* release_asset();
  ::message::Asset* mutable_asset();
  void set_allocated_asset(::message::Asset* value);
  void unsafe_arena_set_allocated_asset(::message::Asset* value);
  ::message::Asset* unsafe_arena_release_asset();

  private:
  const ::message::Asset& _internal_asset() const;
  ::message::Asset* _internal_mutable_asset();

  public:
  // .message.User user = 4;
  bool has_user() const;
  void clear_user() ;
  const ::message::User& user() const;
  PROTOBUF_NODISCARD ::message::User* release_user();
  ::message::User* mutable_user();
  void set_allocated_user(::message::User* value);
  void unsafe_arena_set_allocated_user(::message::User* value);
  ::message::User* unsafe_arena_release_user();

  private:
  const ::message::User& _internal_user() const;
  ::message::User* _internal_mutable_user();

  public:
  // .message.Account account = 5;
  bool has_account() const;
  void clear_account() ;
  const ::message::Account& account() const;
  PROTOBUF_NODISCARD ::message::Account* release_account();
  ::message::Account* mutable_account();
  void set_allocated_account(::message::Account* value);
  void unsafe_arena_set_allocated_account(::message::Account* value);
  ::message::Account* unsafe_arena_release_account();

  private:
  const ::message::Account& _internal_account() const;
  ::message::Account* _internal_mutable_account();

  public:
  // .message.Permission permission = 6;
  bool has_permission() const;
  void clear_permission() ;
  const ::message::Permission& permission() const;
  PROTOBUF_NODISCARD ::message::Permission* release_permission();
  ::message::Permission* mutable_permission();
  void set_allocated_permission(::message::Permission* value);
  void unsafe_arena_set_allocated_permission(::message::Permission* value);
  ::message::Permission* unsafe_arena_release_permission();

  private:
  const ::message::Permission& _internal_permission() const;
  ::message::Permission* _internal_mutable_permission();

  public:
  // .message.ExpireInfo expire_info = 7;
  bool has_expire_info() const;
  void clear_expire_info() ;
  const ::message::ExpireInfo& expire_info() const;
  PROTOBUF_NODISCARD ::message::ExpireInfo* release_expire_info();
  ::message::ExpireInfo* mutable_expire_info();
  void set_allocated_expire_info(::message::ExpireInfo* value);
  void unsafe_arena_set_allocated_expire_info(::message::ExpireInfo* value);
  ::message::ExpireInfo* unsafe_arena_release_expire_info();

  private:
  const ::message::ExpireInfo& _internal_expire_info() const;
  ::message::ExpireInfo* _internal_mutable_expire_info();

  public:
  // .message.ComponentSetting setting = 10;
  bool has_setting() const;
  void clear_setting() ;
  const ::message::ComponentSetting& setting() const;
  PROTOBUF_NODISCARD ::message::ComponentSetting* release_setting();
  ::message::ComponentSetting* mutable_setting();
  void set_allocated_setting(::message::ComponentSetting* value);
  void unsafe_arena_set_allocated_setting(::message::ComponentSetting* value);
  ::message::ComponentSetting* unsafe_arena_release_setting();

  private:
  const ::message::ComponentSetting& _internal_setting() const;
  ::message::ComponentSetting* _internal_mutable_setting();

  public:
  // .message.Platform platform = 11;
  bool has_platform() const;
  void clear_platform() ;
  const ::message::Platform& platform() const;
  PROTOBUF_NODISCARD ::message::Platform* release_platform();
  ::message::Platform* mutable_platform();
  void set_allocated_platform(::message::Platform* value);
  void unsafe_arena_set_allocated_platform(::message::Platform* value);
  ::message::Platform* unsafe_arena_release_platform();

  private:
  const ::message::Platform& _internal_platform() const;
  ::message::Platform* _internal_mutable_platform();

  public:
  // @@protoc_insertion_point(class_scope:message.TokenAuthInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 9,
      70, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TokenAuthInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TokenAuthInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::message::CommandACL > filter_rules_;
    ::google::protobuf::RepeatedPtrField< ::message::Gateway > gateways_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr secrete_id_;
    ::google::protobuf::internal::ArenaStringPtr facemonitortoken_;
    ::message::Asset* asset_;
    ::message::User* user_;
    ::message::Account* account_;
    ::message::Permission* permission_;
    ::message::ExpireInfo* expire_info_;
    ::message::ComponentSetting* setting_;
    ::message::Platform* platform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.User.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.User.id)
}
inline std::string* User::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* User::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.User.id)
}

// string name = 2;
inline void User::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& User::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.User.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.User.name)
}
inline std::string* User::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* User::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.User.name)
  return _impl_.name_.Release();
}
inline void User::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.User.name)
}

// string username = 3;
inline void User::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.User.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.User.username)
}
inline std::string* User::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:message.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* User::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.User.username)
}

// string role = 4;
inline void User::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.ClearToEmpty();
}
inline const std::string& User::role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.User.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void User::set_role(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.User.role)
}
inline std::string* User::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:message.User.role)
  return _s;
}
inline const std::string& User::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_.Get();
}
inline void User::_internal_set_role(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.Set(value, GetArena());
}
inline std::string* User::_internal_mutable_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.role_.Mutable( GetArena());
}
inline std::string* User::release_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.User.role)
  return _impl_.role_.Release();
}
inline void User::set_allocated_role(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.User.role)
}

// bool is_valid = 5;
inline void User::clear_is_valid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_valid_ = false;
}
inline bool User::is_valid() const {
  // @@protoc_insertion_point(field_get:message.User.is_valid)
  return _internal_is_valid();
}
inline void User::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  // @@protoc_insertion_point(field_set:message.User.is_valid)
}
inline bool User::_internal_is_valid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_valid_;
}
inline void User::_internal_set_is_valid(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_valid_ = value;
}

// bool is_active = 6;
inline void User::clear_is_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_active_ = false;
}
inline bool User::is_active() const {
  // @@protoc_insertion_point(field_get:message.User.is_active)
  return _internal_is_active();
}
inline void User::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:message.User.is_active)
}
inline bool User::_internal_is_active() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_active_;
}
inline void User::_internal_set_is_active(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_active_ = value;
}

// -------------------------------------------------------------------

// Account

// string id = 1;
inline void Account::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Account::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Account.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Account.id)
}
inline std::string* Account::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.Account.id)
  return _s;
}
inline const std::string& Account::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Account::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Account::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Account.id)
  return _impl_.id_.Release();
}
inline void Account::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Account.id)
}

// string name = 2;
inline void Account::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Account::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Account.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Account.name)
}
inline std::string* Account::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Account.name)
  return _s;
}
inline const std::string& Account::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Account::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Account::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Account.name)
  return _impl_.name_.Release();
}
inline void Account::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Account.name)
}

// string username = 4;
inline void Account::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Account::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Account.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Account.username)
}
inline std::string* Account::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:message.Account.username)
  return _s;
}
inline const std::string& Account::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void Account::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* Account::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Account.username)
  return _impl_.username_.Release();
}
inline void Account::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Account.username)
}

// string secret = 5;
inline void Account::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& Account::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Account.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Account::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Account.secret)
}
inline std::string* Account::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:message.Account.secret)
  return _s;
}
inline const std::string& Account::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void Account::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* Account::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* Account::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Account.secret)
  return _impl_.secret_.Release();
}
inline void Account::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Account.secret)
}

// .message.LabelValue secretType = 6;
inline bool Account::has_secrettype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secrettype_ != nullptr);
  return value;
}
inline void Account::clear_secrettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secrettype_ != nullptr) _impl_.secrettype_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::LabelValue& Account::_internal_secrettype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::LabelValue* p = _impl_.secrettype_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::LabelValue&>(::message::_LabelValue_default_instance_);
}
inline const ::message::LabelValue& Account::secrettype() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Account.secretType)
  return _internal_secrettype();
}
inline void Account::unsafe_arena_set_allocated_secrettype(::message::LabelValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secrettype_);
  }
  _impl_.secrettype_ = reinterpret_cast<::message::LabelValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.Account.secretType)
}
inline ::message::LabelValue* Account::release_secrettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::LabelValue* released = _impl_.secrettype_;
  _impl_.secrettype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::LabelValue* Account::unsafe_arena_release_secrettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Account.secretType)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::LabelValue* temp = _impl_.secrettype_;
  _impl_.secrettype_ = nullptr;
  return temp;
}
inline ::message::LabelValue* Account::_internal_mutable_secrettype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secrettype_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::LabelValue>(GetArena());
    _impl_.secrettype_ = reinterpret_cast<::message::LabelValue*>(p);
  }
  return _impl_.secrettype_;
}
inline ::message::LabelValue* Account::mutable_secrettype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::LabelValue* _msg = _internal_mutable_secrettype();
  // @@protoc_insertion_point(field_mutable:message.Account.secretType)
  return _msg;
}
inline void Account::set_allocated_secrettype(::message::LabelValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.secrettype_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.secrettype_ = reinterpret_cast<::message::LabelValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.Account.secretType)
}

// -------------------------------------------------------------------

// LabelValue

// string label = 1;
inline void LabelValue::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
}
inline const std::string& LabelValue::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.LabelValue.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LabelValue::set_label(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.LabelValue.label)
}
inline std::string* LabelValue::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:message.LabelValue.label)
  return _s;
}
inline const std::string& LabelValue::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void LabelValue::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(value, GetArena());
}
inline std::string* LabelValue::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* LabelValue::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.LabelValue.label)
  return _impl_.label_.Release();
}
inline void LabelValue::set_allocated_label(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.LabelValue.label)
}

// string value = 2;
inline void LabelValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& LabelValue::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.LabelValue.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LabelValue::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.LabelValue.value)
}
inline std::string* LabelValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:message.LabelValue.value)
  return _s;
}
inline const std::string& LabelValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void LabelValue::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* LabelValue::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* LabelValue::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.LabelValue.value)
  return _impl_.value_.Release();
}
inline void LabelValue::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.LabelValue.value)
}

// -------------------------------------------------------------------

// Asset_Specific

// string db_name = 1;
inline void Asset_Specific::clear_db_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& Asset_Specific::db_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.db_name)
  return _internal_db_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_db_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.db_name)
}
inline std::string* Asset_Specific::mutable_db_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.db_name)
  return _s;
}
inline const std::string& Asset_Specific::_internal_db_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_name_.Get();
}
inline void Asset_Specific::_internal_set_db_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_name_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_db_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.db_name_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_db_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.db_name)
  return _impl_.db_name_.Release();
}
inline void Asset_Specific::set_allocated_db_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.db_name_.IsDefault()) {
          _impl_.db_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.db_name)
}

// bool use_ssl = 2;
inline void Asset_Specific::clear_use_ssl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_ssl_ = false;
}
inline bool Asset_Specific::use_ssl() const {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.use_ssl)
  return _internal_use_ssl();
}
inline void Asset_Specific::set_use_ssl(bool value) {
  _internal_set_use_ssl(value);
  // @@protoc_insertion_point(field_set:message.Asset.Specific.use_ssl)
}
inline bool Asset_Specific::_internal_use_ssl() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_ssl_;
}
inline void Asset_Specific::_internal_set_use_ssl(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_ssl_ = value;
}

// string ca_cert = 3;
inline void Asset_Specific::clear_ca_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ca_cert_.ClearToEmpty();
}
inline const std::string& Asset_Specific::ca_cert() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.ca_cert)
  return _internal_ca_cert();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_ca_cert(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ca_cert_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.ca_cert)
}
inline std::string* Asset_Specific::mutable_ca_cert() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ca_cert();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.ca_cert)
  return _s;
}
inline const std::string& Asset_Specific::_internal_ca_cert() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ca_cert_.Get();
}
inline void Asset_Specific::_internal_set_ca_cert(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ca_cert_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_ca_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ca_cert_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_ca_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.ca_cert)
  return _impl_.ca_cert_.Release();
}
inline void Asset_Specific::set_allocated_ca_cert(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ca_cert_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ca_cert_.IsDefault()) {
          _impl_.ca_cert_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.ca_cert)
}

// string client_cert = 4;
inline void Asset_Specific::clear_client_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_cert_.ClearToEmpty();
}
inline const std::string& Asset_Specific::client_cert() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.client_cert)
  return _internal_client_cert();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_client_cert(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_cert_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.client_cert)
}
inline std::string* Asset_Specific::mutable_client_cert() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_cert();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.client_cert)
  return _s;
}
inline const std::string& Asset_Specific::_internal_client_cert() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_cert_.Get();
}
inline void Asset_Specific::_internal_set_client_cert(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_cert_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_client_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_cert_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_client_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.client_cert)
  return _impl_.client_cert_.Release();
}
inline void Asset_Specific::set_allocated_client_cert(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_cert_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_cert_.IsDefault()) {
          _impl_.client_cert_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.client_cert)
}

// string client_key = 5;
inline void Asset_Specific::clear_client_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_key_.ClearToEmpty();
}
inline const std::string& Asset_Specific::client_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.client_key)
  return _internal_client_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_client_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.client_key)
}
inline std::string* Asset_Specific::mutable_client_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_key();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.client_key)
  return _s;
}
inline const std::string& Asset_Specific::_internal_client_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_key_.Get();
}
inline void Asset_Specific::_internal_set_client_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_key_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_client_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.client_key_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_client_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.client_key)
  return _impl_.client_key_.Release();
}
inline void Asset_Specific::set_allocated_client_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_key_.IsDefault()) {
          _impl_.client_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.client_key)
}

// bool allow_invalid_cert = 6;
inline void Asset_Specific::clear_allow_invalid_cert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_invalid_cert_ = false;
}
inline bool Asset_Specific::allow_invalid_cert() const {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.allow_invalid_cert)
  return _internal_allow_invalid_cert();
}
inline void Asset_Specific::set_allow_invalid_cert(bool value) {
  _internal_set_allow_invalid_cert(value);
  // @@protoc_insertion_point(field_set:message.Asset.Specific.allow_invalid_cert)
}
inline bool Asset_Specific::_internal_allow_invalid_cert() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allow_invalid_cert_;
}
inline void Asset_Specific::_internal_set_allow_invalid_cert(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_invalid_cert_ = value;
}

// string auto_fill = 7;
inline void Asset_Specific::clear_auto_fill() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_fill_.ClearToEmpty();
}
inline const std::string& Asset_Specific::auto_fill() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.auto_fill)
  return _internal_auto_fill();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_auto_fill(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_fill_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.auto_fill)
}
inline std::string* Asset_Specific::mutable_auto_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auto_fill();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.auto_fill)
  return _s;
}
inline const std::string& Asset_Specific::_internal_auto_fill() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_fill_.Get();
}
inline void Asset_Specific::_internal_set_auto_fill(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_fill_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_auto_fill() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.auto_fill_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_auto_fill() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.auto_fill)
  return _impl_.auto_fill_.Release();
}
inline void Asset_Specific::set_allocated_auto_fill(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_fill_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auto_fill_.IsDefault()) {
          _impl_.auto_fill_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.auto_fill)
}

// string username_selector = 8;
inline void Asset_Specific::clear_username_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_selector_.ClearToEmpty();
}
inline const std::string& Asset_Specific::username_selector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.username_selector)
  return _internal_username_selector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_username_selector(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_selector_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.username_selector)
}
inline std::string* Asset_Specific::mutable_username_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username_selector();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.username_selector)
  return _s;
}
inline const std::string& Asset_Specific::_internal_username_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_selector_.Get();
}
inline void Asset_Specific::_internal_set_username_selector(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_selector_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_username_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_selector_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_username_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.username_selector)
  return _impl_.username_selector_.Release();
}
inline void Asset_Specific::set_allocated_username_selector(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_selector_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_selector_.IsDefault()) {
          _impl_.username_selector_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.username_selector)
}

// string password_selector = 9;
inline void Asset_Specific::clear_password_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_selector_.ClearToEmpty();
}
inline const std::string& Asset_Specific::password_selector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.password_selector)
  return _internal_password_selector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_password_selector(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_selector_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.password_selector)
}
inline std::string* Asset_Specific::mutable_password_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password_selector();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.password_selector)
  return _s;
}
inline const std::string& Asset_Specific::_internal_password_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_selector_.Get();
}
inline void Asset_Specific::_internal_set_password_selector(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_selector_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_password_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_selector_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_password_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.password_selector)
  return _impl_.password_selector_.Release();
}
inline void Asset_Specific::set_allocated_password_selector(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_selector_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_selector_.IsDefault()) {
          _impl_.password_selector_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.password_selector)
}

// string submit_selector = 10;
inline void Asset_Specific::clear_submit_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.submit_selector_.ClearToEmpty();
}
inline const std::string& Asset_Specific::submit_selector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.submit_selector)
  return _internal_submit_selector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_submit_selector(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.submit_selector_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.submit_selector)
}
inline std::string* Asset_Specific::mutable_submit_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_submit_selector();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.submit_selector)
  return _s;
}
inline const std::string& Asset_Specific::_internal_submit_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.submit_selector_.Get();
}
inline void Asset_Specific::_internal_set_submit_selector(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.submit_selector_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_submit_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.submit_selector_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_submit_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.submit_selector)
  return _impl_.submit_selector_.Release();
}
inline void Asset_Specific::set_allocated_submit_selector(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.submit_selector_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.submit_selector_.IsDefault()) {
          _impl_.submit_selector_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.submit_selector)
}

// string script = 11;
inline void Asset_Specific::clear_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_.ClearToEmpty();
}
inline const std::string& Asset_Specific::script() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.script)
  return _internal_script();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_script(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.script)
}
inline std::string* Asset_Specific::mutable_script() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.script)
  return _s;
}
inline const std::string& Asset_Specific::_internal_script() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.script_.Get();
}
inline void Asset_Specific::_internal_set_script(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.script_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.script)
  return _impl_.script_.Release();
}
inline void Asset_Specific::set_allocated_script(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.script_.IsDefault()) {
          _impl_.script_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.script)
}

// string http_proxy = 12;
inline void Asset_Specific::clear_http_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_proxy_.ClearToEmpty();
}
inline const std::string& Asset_Specific::http_proxy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.http_proxy)
  return _internal_http_proxy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_http_proxy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_proxy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.http_proxy)
}
inline std::string* Asset_Specific::mutable_http_proxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_http_proxy();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.http_proxy)
  return _s;
}
inline const std::string& Asset_Specific::_internal_http_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_proxy_.Get();
}
inline void Asset_Specific::_internal_set_http_proxy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_proxy_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_http_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.http_proxy_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_http_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.http_proxy)
  return _impl_.http_proxy_.Release();
}
inline void Asset_Specific::set_allocated_http_proxy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_proxy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.http_proxy_.IsDefault()) {
          _impl_.http_proxy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.http_proxy)
}

// string pg_ssl_mode = 13;
inline void Asset_Specific::clear_pg_ssl_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pg_ssl_mode_.ClearToEmpty();
}
inline const std::string& Asset_Specific::pg_ssl_mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.Specific.pg_ssl_mode)
  return _internal_pg_ssl_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset_Specific::set_pg_ssl_mode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pg_ssl_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.Specific.pg_ssl_mode)
}
inline std::string* Asset_Specific::mutable_pg_ssl_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pg_ssl_mode();
  // @@protoc_insertion_point(field_mutable:message.Asset.Specific.pg_ssl_mode)
  return _s;
}
inline const std::string& Asset_Specific::_internal_pg_ssl_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pg_ssl_mode_.Get();
}
inline void Asset_Specific::_internal_set_pg_ssl_mode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pg_ssl_mode_.Set(value, GetArena());
}
inline std::string* Asset_Specific::_internal_mutable_pg_ssl_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pg_ssl_mode_.Mutable( GetArena());
}
inline std::string* Asset_Specific::release_pg_ssl_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.Specific.pg_ssl_mode)
  return _impl_.pg_ssl_mode_.Release();
}
inline void Asset_Specific::set_allocated_pg_ssl_mode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pg_ssl_mode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pg_ssl_mode_.IsDefault()) {
          _impl_.pg_ssl_mode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.Specific.pg_ssl_mode)
}

// -------------------------------------------------------------------

// Asset

// string id = 1;
inline void Asset::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Asset::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.id)
}
inline std::string* Asset::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.Asset.id)
  return _s;
}
inline const std::string& Asset::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Asset::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Asset::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Asset::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.id)
  return _impl_.id_.Release();
}
inline void Asset::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.id)
}

// string name = 2;
inline void Asset::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Asset::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.name)
}
inline std::string* Asset::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Asset.name)
  return _s;
}
inline const std::string& Asset::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Asset::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Asset::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Asset::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.name)
  return _impl_.name_.Release();
}
inline void Asset::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.name)
}

// string address = 3;
inline void Asset::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Asset::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset::set_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.address)
}
inline std::string* Asset::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:message.Asset.address)
  return _s;
}
inline const std::string& Asset::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void Asset::_internal_set_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Asset::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Asset::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.address)
  return _impl_.address_.Release();
}
inline void Asset::set_allocated_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.address)
}

// string org_id = 4;
inline void Asset::clear_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Asset::org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.org_id)
}
inline std::string* Asset::mutable_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:message.Asset.org_id)
  return _s;
}
inline const std::string& Asset::_internal_org_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_id_.Get();
}
inline void Asset::_internal_set_org_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(value, GetArena());
}
inline std::string* Asset::_internal_mutable_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_id_.Mutable( GetArena());
}
inline std::string* Asset::release_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.org_id)
  return _impl_.org_id_.Release();
}
inline void Asset::set_allocated_org_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.org_id)
}

// string org_name = 5;
inline void Asset::clear_org_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_name_.ClearToEmpty();
}
inline const std::string& Asset::org_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.org_name)
  return _internal_org_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Asset::set_org_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Asset.org_name)
}
inline std::string* Asset::mutable_org_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_name();
  // @@protoc_insertion_point(field_mutable:message.Asset.org_name)
  return _s;
}
inline const std::string& Asset::_internal_org_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_name_.Get();
}
inline void Asset::_internal_set_org_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_name_.Set(value, GetArena());
}
inline std::string* Asset::_internal_mutable_org_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_name_.Mutable( GetArena());
}
inline std::string* Asset::release_org_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.org_name)
  return _impl_.org_name_.Release();
}
inline void Asset::set_allocated_org_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_name_.IsDefault()) {
          _impl_.org_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Asset.org_name)
}

// repeated .message.Protocol protocols = 6;
inline int Asset::_internal_protocols_size() const {
  return _internal_protocols().size();
}
inline int Asset::protocols_size() const {
  return _internal_protocols_size();
}
inline void Asset::clear_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.Clear();
}
inline ::message::Protocol* Asset::mutable_protocols(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.Asset.protocols)
  return _internal_mutable_protocols()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::Protocol>* Asset::mutable_protocols()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.Asset.protocols)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_protocols();
}
inline const ::message::Protocol& Asset::protocols(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.protocols)
  return _internal_protocols().Get(index);
}
inline ::message::Protocol* Asset::add_protocols() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::Protocol* _add = _internal_mutable_protocols()->Add();
  // @@protoc_insertion_point(field_add:message.Asset.protocols)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::Protocol>& Asset::protocols() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.Asset.protocols)
  return _internal_protocols();
}
inline const ::google::protobuf::RepeatedPtrField<::message::Protocol>&
Asset::_internal_protocols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocols_;
}
inline ::google::protobuf::RepeatedPtrField<::message::Protocol>*
Asset::_internal_mutable_protocols() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.protocols_;
}

// .message.Asset.Specific specific = 7;
inline bool Asset::has_specific() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specific_ != nullptr);
  return value;
}
inline void Asset::clear_specific() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_ != nullptr) _impl_.specific_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Asset_Specific& Asset::_internal_specific() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Asset_Specific* p = _impl_.specific_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Asset_Specific&>(::message::_Asset_Specific_default_instance_);
}
inline const ::message::Asset_Specific& Asset::specific() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Asset.specific)
  return _internal_specific();
}
inline void Asset::unsafe_arena_set_allocated_specific(::message::Asset_Specific* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specific_);
  }
  _impl_.specific_ = reinterpret_cast<::message::Asset_Specific*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.Asset.specific)
}
inline ::message::Asset_Specific* Asset::release_specific() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset_Specific* released = _impl_.specific_;
  _impl_.specific_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Asset_Specific* Asset::unsafe_arena_release_specific() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Asset.specific)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset_Specific* temp = _impl_.specific_;
  _impl_.specific_ = nullptr;
  return temp;
}
inline ::message::Asset_Specific* Asset::_internal_mutable_specific() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Asset_Specific>(GetArena());
    _impl_.specific_ = reinterpret_cast<::message::Asset_Specific*>(p);
  }
  return _impl_.specific_;
}
inline ::message::Asset_Specific* Asset::mutable_specific() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Asset_Specific* _msg = _internal_mutable_specific();
  // @@protoc_insertion_point(field_mutable:message.Asset.specific)
  return _msg;
}
inline void Asset::set_allocated_specific(::message::Asset_Specific* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.specific_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.specific_ = reinterpret_cast<::message::Asset_Specific*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.Asset.specific)
}

// -------------------------------------------------------------------

// Protocol

// string name = 2;
inline void Protocol::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Protocol::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Protocol.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Protocol::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Protocol.name)
}
inline std::string* Protocol::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Protocol.name)
  return _s;
}
inline const std::string& Protocol::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Protocol::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Protocol::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Protocol::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Protocol.name)
  return _impl_.name_.Release();
}
inline void Protocol::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Protocol.name)
}

// int32 id = 1;
inline void Protocol::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Protocol::id() const {
  // @@protoc_insertion_point(field_get:message.Protocol.id)
  return _internal_id();
}
inline void Protocol::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.Protocol.id)
}
inline ::int32_t Protocol::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Protocol::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// int32 port = 3;
inline void Protocol::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t Protocol::port() const {
  // @@protoc_insertion_point(field_get:message.Protocol.port)
  return _internal_port();
}
inline void Protocol::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.Protocol.port)
}
inline ::int32_t Protocol::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void Protocol::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// Gateway

// string id = 1;
inline void Gateway::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Gateway::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.id)
}
inline std::string* Gateway::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.Gateway.id)
  return _s;
}
inline const std::string& Gateway::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Gateway::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Gateway::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.id)
  return _impl_.id_.Release();
}
inline void Gateway::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.id)
}

// string name = 2;
inline void Gateway::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Gateway::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.name)
}
inline std::string* Gateway::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Gateway.name)
  return _s;
}
inline const std::string& Gateway::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Gateway::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Gateway::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.name)
  return _impl_.name_.Release();
}
inline void Gateway::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.name)
}

// string ip = 3;
inline void Gateway::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Gateway::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.ip)
}
inline std::string* Gateway::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:message.Gateway.ip)
  return _s;
}
inline const std::string& Gateway::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_.Get();
}
inline void Gateway::_internal_set_ip(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* Gateway::release_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.ip)
  return _impl_.ip_.Release();
}
inline void Gateway::set_allocated_ip(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.ip)
}

// int32 port = 4;
inline void Gateway::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t Gateway::port() const {
  // @@protoc_insertion_point(field_get:message.Gateway.port)
  return _internal_port();
}
inline void Gateway::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.Gateway.port)
}
inline ::int32_t Gateway::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void Gateway::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// string protocol = 5;
inline void Gateway::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& Gateway::protocol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.protocol)
  return _internal_protocol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_protocol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.protocol)
}
inline std::string* Gateway::mutable_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:message.Gateway.protocol)
  return _s;
}
inline const std::string& Gateway::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_.Get();
}
inline void Gateway::_internal_set_protocol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocol_.Mutable( GetArena());
}
inline std::string* Gateway::release_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.protocol)
  return _impl_.protocol_.Release();
}
inline void Gateway::set_allocated_protocol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.protocol_.IsDefault()) {
          _impl_.protocol_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.protocol)
}

// string username = 6;
inline void Gateway::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Gateway::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.username)
}
inline std::string* Gateway::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:message.Gateway.username)
  return _s;
}
inline const std::string& Gateway::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void Gateway::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* Gateway::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.username)
  return _impl_.username_.Release();
}
inline void Gateway::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.username)
}

// string password = 7;
inline void Gateway::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Gateway::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.password)
}
inline std::string* Gateway::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:message.Gateway.password)
  return _s;
}
inline const std::string& Gateway::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void Gateway::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* Gateway::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.password)
  return _impl_.password_.Release();
}
inline void Gateway::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.password)
}

// string private_key = 8;
inline void Gateway::clear_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.ClearToEmpty();
}
inline const std::string& Gateway::private_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Gateway.private_key)
  return _internal_private_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Gateway::set_private_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Gateway.private_key)
}
inline std::string* Gateway::mutable_private_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:message.Gateway.private_key)
  return _s;
}
inline const std::string& Gateway::_internal_private_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.private_key_.Get();
}
inline void Gateway::_internal_set_private_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.Set(value, GetArena());
}
inline std::string* Gateway::_internal_mutable_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.private_key_.Mutable( GetArena());
}
inline std::string* Gateway::release_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Gateway.private_key)
  return _impl_.private_key_.Release();
}
inline void Gateway::set_allocated_private_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.private_key_.IsDefault()) {
          _impl_.private_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Gateway.private_key)
}

// -------------------------------------------------------------------

// Permission

// bool enable_connect = 1;
inline void Permission::clear_enable_connect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_connect_ = false;
}
inline bool Permission::enable_connect() const {
  // @@protoc_insertion_point(field_get:message.Permission.enable_connect)
  return _internal_enable_connect();
}
inline void Permission::set_enable_connect(bool value) {
  _internal_set_enable_connect(value);
  // @@protoc_insertion_point(field_set:message.Permission.enable_connect)
}
inline bool Permission::_internal_enable_connect() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_connect_;
}
inline void Permission::_internal_set_enable_connect(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_connect_ = value;
}

// bool enable_download = 2;
inline void Permission::clear_enable_download() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_download_ = false;
}
inline bool Permission::enable_download() const {
  // @@protoc_insertion_point(field_get:message.Permission.enable_download)
  return _internal_enable_download();
}
inline void Permission::set_enable_download(bool value) {
  _internal_set_enable_download(value);
  // @@protoc_insertion_point(field_set:message.Permission.enable_download)
}
inline bool Permission::_internal_enable_download() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_download_;
}
inline void Permission::_internal_set_enable_download(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_download_ = value;
}

// bool enable_upload = 3;
inline void Permission::clear_enable_upload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_upload_ = false;
}
inline bool Permission::enable_upload() const {
  // @@protoc_insertion_point(field_get:message.Permission.enable_upload)
  return _internal_enable_upload();
}
inline void Permission::set_enable_upload(bool value) {
  _internal_set_enable_upload(value);
  // @@protoc_insertion_point(field_set:message.Permission.enable_upload)
}
inline bool Permission::_internal_enable_upload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_upload_;
}
inline void Permission::_internal_set_enable_upload(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_upload_ = value;
}

// bool enable_copy = 4;
inline void Permission::clear_enable_copy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_copy_ = false;
}
inline bool Permission::enable_copy() const {
  // @@protoc_insertion_point(field_get:message.Permission.enable_copy)
  return _internal_enable_copy();
}
inline void Permission::set_enable_copy(bool value) {
  _internal_set_enable_copy(value);
  // @@protoc_insertion_point(field_set:message.Permission.enable_copy)
}
inline bool Permission::_internal_enable_copy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_copy_;
}
inline void Permission::_internal_set_enable_copy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_copy_ = value;
}

// bool enable_paste = 5;
inline void Permission::clear_enable_paste() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_paste_ = false;
}
inline bool Permission::enable_paste() const {
  // @@protoc_insertion_point(field_get:message.Permission.enable_paste)
  return _internal_enable_paste();
}
inline void Permission::set_enable_paste(bool value) {
  _internal_set_enable_paste(value);
  // @@protoc_insertion_point(field_set:message.Permission.enable_paste)
}
inline bool Permission::_internal_enable_paste() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_paste_;
}
inline void Permission::_internal_set_enable_paste(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_paste_ = value;
}

// -------------------------------------------------------------------

// CommandACL

// string id = 1;
inline void CommandACL::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CommandACL::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandACL.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandACL::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandACL.id)
}
inline std::string* CommandACL::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.CommandACL.id)
  return _s;
}
inline const std::string& CommandACL::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CommandACL::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CommandACL::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CommandACL::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandACL.id)
  return _impl_.id_.Release();
}
inline void CommandACL::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandACL.id)
}

// string name = 2;
inline void CommandACL::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CommandACL::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandACL.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandACL::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandACL.name)
}
inline std::string* CommandACL::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.CommandACL.name)
  return _s;
}
inline const std::string& CommandACL::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CommandACL::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CommandACL::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CommandACL::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandACL.name)
  return _impl_.name_.Release();
}
inline void CommandACL::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandACL.name)
}

// int32 priority = 3;
inline void CommandACL::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t CommandACL::priority() const {
  // @@protoc_insertion_point(field_get:message.CommandACL.priority)
  return _internal_priority();
}
inline void CommandACL::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:message.CommandACL.priority)
}
inline ::int32_t CommandACL::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void CommandACL::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// .message.CommandACL.Action action = 5;
inline void CommandACL::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::message::CommandACL_Action CommandACL::action() const {
  // @@protoc_insertion_point(field_get:message.CommandACL.action)
  return _internal_action();
}
inline void CommandACL::set_action(::message::CommandACL_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:message.CommandACL.action)
}
inline ::message::CommandACL_Action CommandACL::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::CommandACL_Action>(_impl_.action_);
}
inline void CommandACL::_internal_set_action(::message::CommandACL_Action value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// bool is_active = 6;
inline void CommandACL::clear_is_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_active_ = false;
}
inline bool CommandACL::is_active() const {
  // @@protoc_insertion_point(field_get:message.CommandACL.is_active)
  return _internal_is_active();
}
inline void CommandACL::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:message.CommandACL.is_active)
}
inline bool CommandACL::_internal_is_active() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_active_;
}
inline void CommandACL::_internal_set_is_active(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_active_ = value;
}

// repeated .message.CommandGroup command_groups = 7;
inline int CommandACL::_internal_command_groups_size() const {
  return _internal_command_groups().size();
}
inline int CommandACL::command_groups_size() const {
  return _internal_command_groups_size();
}
inline void CommandACL::clear_command_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_groups_.Clear();
}
inline ::message::CommandGroup* CommandACL::mutable_command_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.CommandACL.command_groups)
  return _internal_mutable_command_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::CommandGroup>* CommandACL::mutable_command_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.CommandACL.command_groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_command_groups();
}
inline const ::message::CommandGroup& CommandACL::command_groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandACL.command_groups)
  return _internal_command_groups().Get(index);
}
inline ::message::CommandGroup* CommandACL::add_command_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::CommandGroup* _add = _internal_mutable_command_groups()->Add();
  // @@protoc_insertion_point(field_add:message.CommandACL.command_groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::CommandGroup>& CommandACL::command_groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.CommandACL.command_groups)
  return _internal_command_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::message::CommandGroup>&
CommandACL::_internal_command_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.command_groups_;
}
inline ::google::protobuf::RepeatedPtrField<::message::CommandGroup>*
CommandACL::_internal_mutable_command_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.command_groups_;
}

// -------------------------------------------------------------------

// CommandGroup

// string id = 1;
inline void CommandGroup::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CommandGroup::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandGroup.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGroup::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandGroup.id)
}
inline std::string* CommandGroup::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.CommandGroup.id)
  return _s;
}
inline const std::string& CommandGroup::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CommandGroup::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CommandGroup::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CommandGroup::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandGroup.id)
  return _impl_.id_.Release();
}
inline void CommandGroup::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandGroup.id)
}

// string name = 2;
inline void CommandGroup::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CommandGroup::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandGroup.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGroup::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandGroup.name)
}
inline std::string* CommandGroup::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.CommandGroup.name)
  return _s;
}
inline const std::string& CommandGroup::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CommandGroup::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CommandGroup::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CommandGroup::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandGroup.name)
  return _impl_.name_.Release();
}
inline void CommandGroup::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandGroup.name)
}

// string content = 3;
inline void CommandGroup::clear_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& CommandGroup::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandGroup.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGroup::set_content(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandGroup.content)
}
inline std::string* CommandGroup::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:message.CommandGroup.content)
  return _s;
}
inline const std::string& CommandGroup::_internal_content() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.content_.Get();
}
inline void CommandGroup::_internal_set_content(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.Set(value, GetArena());
}
inline std::string* CommandGroup::_internal_mutable_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* CommandGroup::release_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandGroup.content)
  return _impl_.content_.Release();
}
inline void CommandGroup::set_allocated_content(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandGroup.content)
}

// string Type = 4;
inline void CommandGroup::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& CommandGroup::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandGroup.Type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGroup::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandGroup.Type)
}
inline std::string* CommandGroup::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:message.CommandGroup.Type)
  return _s;
}
inline const std::string& CommandGroup::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void CommandGroup::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* CommandGroup::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* CommandGroup::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandGroup.Type)
  return _impl_.type_.Release();
}
inline void CommandGroup::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandGroup.Type)
}

// string pattern = 5;
inline void CommandGroup::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.ClearToEmpty();
}
inline const std::string& CommandGroup::pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.CommandGroup.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGroup::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.CommandGroup.pattern)
}
inline std::string* CommandGroup::mutable_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:message.CommandGroup.pattern)
  return _s;
}
inline const std::string& CommandGroup::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pattern_.Get();
}
inline void CommandGroup::_internal_set_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.Set(value, GetArena());
}
inline std::string* CommandGroup::_internal_mutable_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pattern_.Mutable( GetArena());
}
inline std::string* CommandGroup::release_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.CommandGroup.pattern)
  return _impl_.pattern_.Release();
}
inline void CommandGroup::set_allocated_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.CommandGroup.pattern)
}

// bool ignore_case = 6;
inline void CommandGroup::clear_ignore_case() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_case_ = false;
}
inline bool CommandGroup::ignore_case() const {
  // @@protoc_insertion_point(field_get:message.CommandGroup.ignore_case)
  return _internal_ignore_case();
}
inline void CommandGroup::set_ignore_case(bool value) {
  _internal_set_ignore_case(value);
  // @@protoc_insertion_point(field_set:message.CommandGroup.ignore_case)
}
inline bool CommandGroup::_internal_ignore_case() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_case_;
}
inline void CommandGroup::_internal_set_ignore_case(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_case_ = value;
}

// -------------------------------------------------------------------

// ExpireInfo

// int64 expire_at = 1;
inline void ExpireInfo::clear_expire_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expire_at_ = ::int64_t{0};
}
inline ::int64_t ExpireInfo::expire_at() const {
  // @@protoc_insertion_point(field_get:message.ExpireInfo.expire_at)
  return _internal_expire_at();
}
inline void ExpireInfo::set_expire_at(::int64_t value) {
  _internal_set_expire_at(value);
  // @@protoc_insertion_point(field_set:message.ExpireInfo.expire_at)
}
inline ::int64_t ExpireInfo::_internal_expire_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expire_at_;
}
inline void ExpireInfo::_internal_set_expire_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expire_at_ = value;
}

// -------------------------------------------------------------------

// Session

// string id = 1;
inline void Session::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Session::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.id)
}
inline std::string* Session::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.Session.id)
  return _s;
}
inline const std::string& Session::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Session::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Session::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.id)
  return _impl_.id_.Release();
}
inline void Session::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.id)
}

// string user = 2;
inline void Session::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& Session::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.user)
}
inline std::string* Session::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:message.Session.user)
  return _s;
}
inline const std::string& Session::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void Session::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* Session::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.user)
  return _impl_.user_.Release();
}
inline void Session::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.user)
}

// string asset = 3;
inline void Session::clear_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.ClearToEmpty();
}
inline const std::string& Session::asset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.asset)
  return _internal_asset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_asset(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.asset)
}
inline std::string* Session::mutable_asset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:message.Session.asset)
  return _s;
}
inline const std::string& Session::_internal_asset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_.Get();
}
inline void Session::_internal_set_asset(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.asset_.Mutable( GetArena());
}
inline std::string* Session::release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.asset)
  return _impl_.asset_.Release();
}
inline void Session::set_allocated_asset(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.asset_.IsDefault()) {
          _impl_.asset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.asset)
}

// string account = 4;
inline void Session::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& Session::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.account)
}
inline std::string* Session::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:message.Session.account)
  return _s;
}
inline const std::string& Session::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void Session::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* Session::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.account)
  return _impl_.account_.Release();
}
inline void Session::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.account)
}

// .message.Session.LoginFrom login_from = 5;
inline void Session::clear_login_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_from_ = 0;
}
inline ::message::Session_LoginFrom Session::login_from() const {
  // @@protoc_insertion_point(field_get:message.Session.login_from)
  return _internal_login_from();
}
inline void Session::set_login_from(::message::Session_LoginFrom value) {
  _internal_set_login_from(value);
  // @@protoc_insertion_point(field_set:message.Session.login_from)
}
inline ::message::Session_LoginFrom Session::_internal_login_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::Session_LoginFrom>(_impl_.login_from_);
}
inline void Session::_internal_set_login_from(::message::Session_LoginFrom value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.login_from_ = value;
}

// string remote_addr = 6;
inline void Session::clear_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_addr_.ClearToEmpty();
}
inline const std::string& Session::remote_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.remote_addr)
  return _internal_remote_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_remote_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.remote_addr)
}
inline std::string* Session::mutable_remote_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_addr();
  // @@protoc_insertion_point(field_mutable:message.Session.remote_addr)
  return _s;
}
inline const std::string& Session::_internal_remote_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_addr_.Get();
}
inline void Session::_internal_set_remote_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_addr_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_addr_.Mutable( GetArena());
}
inline std::string* Session::release_remote_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.remote_addr)
  return _impl_.remote_addr_.Release();
}
inline void Session::set_allocated_remote_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.remote_addr_.IsDefault()) {
          _impl_.remote_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.remote_addr)
}

// string protocol = 7;
inline void Session::clear_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& Session::protocol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.protocol)
  return _internal_protocol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_protocol(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.protocol)
}
inline std::string* Session::mutable_protocol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:message.Session.protocol)
  return _s;
}
inline const std::string& Session::_internal_protocol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_.Get();
}
inline void Session::_internal_set_protocol(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocol_.Mutable( GetArena());
}
inline std::string* Session::release_protocol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.protocol)
  return _impl_.protocol_.Release();
}
inline void Session::set_allocated_protocol(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.protocol_.IsDefault()) {
          _impl_.protocol_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.protocol)
}

// int64 date_start = 8;
inline void Session::clear_date_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_start_ = ::int64_t{0};
}
inline ::int64_t Session::date_start() const {
  // @@protoc_insertion_point(field_get:message.Session.date_start)
  return _internal_date_start();
}
inline void Session::set_date_start(::int64_t value) {
  _internal_set_date_start(value);
  // @@protoc_insertion_point(field_set:message.Session.date_start)
}
inline ::int64_t Session::_internal_date_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.date_start_;
}
inline void Session::_internal_set_date_start(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.date_start_ = value;
}

// string org_id = 9;
inline void Session::clear_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Session::org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.org_id)
}
inline std::string* Session::mutable_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:message.Session.org_id)
  return _s;
}
inline const std::string& Session::_internal_org_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_id_.Get();
}
inline void Session::_internal_set_org_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_id_.Mutable( GetArena());
}
inline std::string* Session::release_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.org_id)
  return _impl_.org_id_.Release();
}
inline void Session::set_allocated_org_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.org_id)
}

// string user_id = 10;
inline void Session::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Session::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.user_id)
}
inline std::string* Session::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:message.Session.user_id)
  return _s;
}
inline const std::string& Session::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void Session::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* Session::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.user_id)
  return _impl_.user_id_.Release();
}
inline void Session::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.user_id)
}

// string asset_id = 11;
inline void Session::clear_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.ClearToEmpty();
}
inline const std::string& Session::asset_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.asset_id)
  return _internal_asset_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_asset_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.asset_id)
}
inline std::string* Session::mutable_asset_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_asset_id();
  // @@protoc_insertion_point(field_mutable:message.Session.asset_id)
  return _s;
}
inline const std::string& Session::_internal_asset_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.asset_id_.Get();
}
inline void Session::_internal_set_asset_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.asset_id_.Mutable( GetArena());
}
inline std::string* Session::release_asset_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.asset_id)
  return _impl_.asset_id_.Release();
}
inline void Session::set_allocated_asset_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.asset_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.asset_id_.IsDefault()) {
          _impl_.asset_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.asset_id)
}

// string account_id = 12;
inline void Session::clear_account_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& Session::account_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.account_id)
  return _internal_account_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_account_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.account_id)
}
inline std::string* Session::mutable_account_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:message.Session.account_id)
  return _s;
}
inline const std::string& Session::_internal_account_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_id_.Get();
}
inline void Session::_internal_set_account_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_account_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_id_.Mutable( GetArena());
}
inline std::string* Session::release_account_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.account_id)
  return _impl_.account_id_.Release();
}
inline void Session::set_allocated_account_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_id_.IsDefault()) {
          _impl_.account_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.account_id)
}

// string token_id = 13;
inline void Session::clear_token_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_id_.ClearToEmpty();
}
inline const std::string& Session::token_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Session.token_id)
  return _internal_token_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Session::set_token_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Session.token_id)
}
inline std::string* Session::mutable_token_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token_id();
  // @@protoc_insertion_point(field_mutable:message.Session.token_id)
  return _s;
}
inline const std::string& Session::_internal_token_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_id_.Get();
}
inline void Session::_internal_set_token_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_id_.Set(value, GetArena());
}
inline std::string* Session::_internal_mutable_token_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_id_.Mutable( GetArena());
}
inline std::string* Session::release_token_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Session.token_id)
  return _impl_.token_id_.Release();
}
inline void Session::set_allocated_token_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_id_.IsDefault()) {
          _impl_.token_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Session.token_id)
}

// -------------------------------------------------------------------

// TokenStatus

// string code = 1;
inline void TokenStatus::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
}
inline const std::string& TokenStatus::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenStatus.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenStatus::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenStatus.code)
}
inline std::string* TokenStatus::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:message.TokenStatus.code)
  return _s;
}
inline const std::string& TokenStatus::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void TokenStatus::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(value, GetArena());
}
inline std::string* TokenStatus::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* TokenStatus::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenStatus.code)
  return _impl_.code_.Release();
}
inline void TokenStatus::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenStatus.code)
}

// string detail = 2;
inline void TokenStatus::clear_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& TokenStatus::detail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenStatus.detail)
  return _internal_detail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenStatus::set_detail(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenStatus.detail)
}
inline std::string* TokenStatus::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:message.TokenStatus.detail)
  return _s;
}
inline const std::string& TokenStatus::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detail_.Get();
}
inline void TokenStatus::_internal_set_detail(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_.Set(value, GetArena());
}
inline std::string* TokenStatus::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.detail_.Mutable( GetArena());
}
inline std::string* TokenStatus::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenStatus.detail)
  return _impl_.detail_.Release();
}
inline void TokenStatus::set_allocated_detail(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detail_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.detail_.IsDefault()) {
          _impl_.detail_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenStatus.detail)
}

// bool is_expired = 3;
inline void TokenStatus::clear_is_expired() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_expired_ = false;
}
inline bool TokenStatus::is_expired() const {
  // @@protoc_insertion_point(field_get:message.TokenStatus.is_expired)
  return _internal_is_expired();
}
inline void TokenStatus::set_is_expired(bool value) {
  _internal_set_is_expired(value);
  // @@protoc_insertion_point(field_set:message.TokenStatus.is_expired)
}
inline bool TokenStatus::_internal_is_expired() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_expired_;
}
inline void TokenStatus::_internal_set_is_expired(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_expired_ = value;
}

// -------------------------------------------------------------------

// TerminalTask

// string id = 1;
inline void TerminalTask::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TerminalTask::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TerminalTask.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TerminalTask::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TerminalTask.id)
}
inline std::string* TerminalTask::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.TerminalTask.id)
  return _s;
}
inline const std::string& TerminalTask::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void TerminalTask::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* TerminalTask::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* TerminalTask::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TerminalTask.id)
  return _impl_.id_.Release();
}
inline void TerminalTask::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TerminalTask.id)
}

// .message.TaskAction action = 2;
inline void TerminalTask::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::message::TaskAction TerminalTask::action() const {
  // @@protoc_insertion_point(field_get:message.TerminalTask.action)
  return _internal_action();
}
inline void TerminalTask::set_action(::message::TaskAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:message.TerminalTask.action)
}
inline ::message::TaskAction TerminalTask::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::TaskAction>(_impl_.action_);
}
inline void TerminalTask::_internal_set_action(::message::TaskAction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// string session_id = 3;
inline void TerminalTask::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TerminalTask::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TerminalTask.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TerminalTask::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TerminalTask.session_id)
}
inline std::string* TerminalTask::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:message.TerminalTask.session_id)
  return _s;
}
inline const std::string& TerminalTask::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void TerminalTask::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* TerminalTask::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* TerminalTask::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TerminalTask.session_id)
  return _impl_.session_id_.Release();
}
inline void TerminalTask::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TerminalTask.session_id)
}

// string terminated_by = 4;
inline void TerminalTask::clear_terminated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminated_by_.ClearToEmpty();
}
inline const std::string& TerminalTask::terminated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TerminalTask.terminated_by)
  return _internal_terminated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TerminalTask::set_terminated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TerminalTask.terminated_by)
}
inline std::string* TerminalTask::mutable_terminated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_terminated_by();
  // @@protoc_insertion_point(field_mutable:message.TerminalTask.terminated_by)
  return _s;
}
inline const std::string& TerminalTask::_internal_terminated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.terminated_by_.Get();
}
inline void TerminalTask::_internal_set_terminated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminated_by_.Set(value, GetArena());
}
inline std::string* TerminalTask::_internal_mutable_terminated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.terminated_by_.Mutable( GetArena());
}
inline std::string* TerminalTask::release_terminated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TerminalTask.terminated_by)
  return _impl_.terminated_by_.Release();
}
inline void TerminalTask::set_allocated_terminated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terminated_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.terminated_by_.IsDefault()) {
          _impl_.terminated_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TerminalTask.terminated_by)
}

// string created_by = 5;
inline void TerminalTask::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& TerminalTask::created_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TerminalTask.created_by)
  return _internal_created_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TerminalTask::set_created_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TerminalTask.created_by)
}
inline std::string* TerminalTask::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:message.TerminalTask.created_by)
  return _s;
}
inline const std::string& TerminalTask::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_by_.Get();
}
inline void TerminalTask::_internal_set_created_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(value, GetArena());
}
inline std::string* TerminalTask::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_by_.Mutable( GetArena());
}
inline std::string* TerminalTask::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TerminalTask.created_by)
  return _impl_.created_by_.Release();
}
inline void TerminalTask::set_allocated_created_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.created_by_.IsDefault()) {
          _impl_.created_by_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TerminalTask.created_by)
}

// .message.TokenStatus token_status = 6;
inline bool TerminalTask::has_token_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_status_ != nullptr);
  return value;
}
inline void TerminalTask::clear_token_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.token_status_ != nullptr) _impl_.token_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::TokenStatus& TerminalTask::_internal_token_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::TokenStatus* p = _impl_.token_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::TokenStatus&>(::message::_TokenStatus_default_instance_);
}
inline const ::message::TokenStatus& TerminalTask::token_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TerminalTask.token_status)
  return _internal_token_status();
}
inline void TerminalTask::unsafe_arena_set_allocated_token_status(::message::TokenStatus* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.token_status_);
  }
  _impl_.token_status_ = reinterpret_cast<::message::TokenStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TerminalTask.token_status)
}
inline ::message::TokenStatus* TerminalTask::release_token_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TokenStatus* released = _impl_.token_status_;
  _impl_.token_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::TokenStatus* TerminalTask::unsafe_arena_release_token_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TerminalTask.token_status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::TokenStatus* temp = _impl_.token_status_;
  _impl_.token_status_ = nullptr;
  return temp;
}
inline ::message::TokenStatus* TerminalTask::_internal_mutable_token_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.token_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::TokenStatus>(GetArena());
    _impl_.token_status_ = reinterpret_cast<::message::TokenStatus*>(p);
  }
  return _impl_.token_status_;
}
inline ::message::TokenStatus* TerminalTask::mutable_token_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::TokenStatus* _msg = _internal_mutable_token_status();
  // @@protoc_insertion_point(field_mutable:message.TerminalTask.token_status)
  return _msg;
}
inline void TerminalTask::set_allocated_token_status(::message::TokenStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.token_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.token_status_ = reinterpret_cast<::message::TokenStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TerminalTask.token_status)
}

// -------------------------------------------------------------------

// TokenAuthInfo

// string key_id = 1;
inline void TokenAuthInfo::clear_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& TokenAuthInfo::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenAuthInfo::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenAuthInfo.key_id)
}
inline std::string* TokenAuthInfo::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.key_id)
  return _s;
}
inline const std::string& TokenAuthInfo::_internal_key_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_id_.Get();
}
inline void TokenAuthInfo::_internal_set_key_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* TokenAuthInfo::_internal_mutable_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* TokenAuthInfo::release_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.key_id)
  return _impl_.key_id_.Release();
}
inline void TokenAuthInfo::set_allocated_key_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_id_.IsDefault()) {
          _impl_.key_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.key_id)
}

// string secrete_id = 2;
inline void TokenAuthInfo::clear_secrete_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secrete_id_.ClearToEmpty();
}
inline const std::string& TokenAuthInfo::secrete_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.secrete_id)
  return _internal_secrete_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenAuthInfo::set_secrete_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secrete_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenAuthInfo.secrete_id)
}
inline std::string* TokenAuthInfo::mutable_secrete_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secrete_id();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.secrete_id)
  return _s;
}
inline const std::string& TokenAuthInfo::_internal_secrete_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secrete_id_.Get();
}
inline void TokenAuthInfo::_internal_set_secrete_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secrete_id_.Set(value, GetArena());
}
inline std::string* TokenAuthInfo::_internal_mutable_secrete_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secrete_id_.Mutable( GetArena());
}
inline std::string* TokenAuthInfo::release_secrete_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.secrete_id)
  return _impl_.secrete_id_.Release();
}
inline void TokenAuthInfo::set_allocated_secrete_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secrete_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secrete_id_.IsDefault()) {
          _impl_.secrete_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.secrete_id)
}

// .message.Asset asset = 3;
inline bool TokenAuthInfo::has_asset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.asset_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asset_ != nullptr) _impl_.asset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::message::Asset& TokenAuthInfo::_internal_asset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Asset* p = _impl_.asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Asset&>(::message::_Asset_default_instance_);
}
inline const ::message::Asset& TokenAuthInfo::asset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.asset)
  return _internal_asset();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_asset(::message::Asset* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asset_);
  }
  _impl_.asset_ = reinterpret_cast<::message::Asset*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.asset)
}
inline ::message::Asset* TokenAuthInfo::release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset* released = _impl_.asset_;
  _impl_.asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Asset* TokenAuthInfo::unsafe_arena_release_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.asset)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::message::Asset* temp = _impl_.asset_;
  _impl_.asset_ = nullptr;
  return temp;
}
inline ::message::Asset* TokenAuthInfo::_internal_mutable_asset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Asset>(GetArena());
    _impl_.asset_ = reinterpret_cast<::message::Asset*>(p);
  }
  return _impl_.asset_;
}
inline ::message::Asset* TokenAuthInfo::mutable_asset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::message::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.asset)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_asset(::message::Asset* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.asset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.asset_ = reinterpret_cast<::message::Asset*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.asset)
}

// .message.User user = 4;
inline bool TokenAuthInfo::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::message::User& TokenAuthInfo::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::User&>(::message::_User_default_instance_);
}
inline const ::message::User& TokenAuthInfo::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.user)
  return _internal_user();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_user(::message::User* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::message::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.user)
}
inline ::message::User* TokenAuthInfo::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::User* released = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::User* TokenAuthInfo::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::message::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::message::User* TokenAuthInfo::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::User>(GetArena());
    _impl_.user_ = reinterpret_cast<::message::User*>(p);
  }
  return _impl_.user_;
}
inline ::message::User* TokenAuthInfo::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::message::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.user)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_user(::message::User* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::message::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.user)
}

// .message.Account account = 5;
inline bool TokenAuthInfo::has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.account_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.account_ != nullptr) _impl_.account_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::message::Account& TokenAuthInfo::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Account* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Account&>(::message::_Account_default_instance_);
}
inline const ::message::Account& TokenAuthInfo::account() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.account)
  return _internal_account();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_account(::message::Account* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = reinterpret_cast<::message::Account*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.account)
}
inline ::message::Account* TokenAuthInfo::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::message::Account* released = _impl_.account_;
  _impl_.account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Account* TokenAuthInfo::unsafe_arena_release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.account)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::message::Account* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::message::Account* TokenAuthInfo::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.account_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Account>(GetArena());
    _impl_.account_ = reinterpret_cast<::message::Account*>(p);
  }
  return _impl_.account_;
}
inline ::message::Account* TokenAuthInfo::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::message::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.account)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_account(::message::Account* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.account_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.account_ = reinterpret_cast<::message::Account*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.account)
}

// .message.Permission permission = 6;
inline bool TokenAuthInfo::has_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.permission_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.permission_ != nullptr) _impl_.permission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::message::Permission& TokenAuthInfo::_internal_permission() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Permission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Permission&>(::message::_Permission_default_instance_);
}
inline const ::message::Permission& TokenAuthInfo::permission() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.permission)
  return _internal_permission();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_permission(::message::Permission* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = reinterpret_cast<::message::Permission*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.permission)
}
inline ::message::Permission* TokenAuthInfo::release_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::message::Permission* released = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Permission* TokenAuthInfo::unsafe_arena_release_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.permission)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::message::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::message::Permission* TokenAuthInfo::_internal_mutable_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.permission_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Permission>(GetArena());
    _impl_.permission_ = reinterpret_cast<::message::Permission*>(p);
  }
  return _impl_.permission_;
}
inline ::message::Permission* TokenAuthInfo::mutable_permission() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::message::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.permission)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_permission(::message::Permission* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.permission_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.permission_ = reinterpret_cast<::message::Permission*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.permission)
}

// .message.ExpireInfo expire_info = 7;
inline bool TokenAuthInfo::has_expire_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expire_info_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_expire_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expire_info_ != nullptr) _impl_.expire_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::message::ExpireInfo& TokenAuthInfo::_internal_expire_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::ExpireInfo* p = _impl_.expire_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ExpireInfo&>(::message::_ExpireInfo_default_instance_);
}
inline const ::message::ExpireInfo& TokenAuthInfo::expire_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.expire_info)
  return _internal_expire_info();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_expire_info(::message::ExpireInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expire_info_);
  }
  _impl_.expire_info_ = reinterpret_cast<::message::ExpireInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.expire_info)
}
inline ::message::ExpireInfo* TokenAuthInfo::release_expire_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::message::ExpireInfo* released = _impl_.expire_info_;
  _impl_.expire_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::ExpireInfo* TokenAuthInfo::unsafe_arena_release_expire_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.expire_info)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::message::ExpireInfo* temp = _impl_.expire_info_;
  _impl_.expire_info_ = nullptr;
  return temp;
}
inline ::message::ExpireInfo* TokenAuthInfo::_internal_mutable_expire_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expire_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::ExpireInfo>(GetArena());
    _impl_.expire_info_ = reinterpret_cast<::message::ExpireInfo*>(p);
  }
  return _impl_.expire_info_;
}
inline ::message::ExpireInfo* TokenAuthInfo::mutable_expire_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::message::ExpireInfo* _msg = _internal_mutable_expire_info();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.expire_info)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_expire_info(::message::ExpireInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expire_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.expire_info_ = reinterpret_cast<::message::ExpireInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.expire_info)
}

// repeated .message.CommandACL filter_rules = 8;
inline int TokenAuthInfo::_internal_filter_rules_size() const {
  return _internal_filter_rules().size();
}
inline int TokenAuthInfo::filter_rules_size() const {
  return _internal_filter_rules_size();
}
inline void TokenAuthInfo::clear_filter_rules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filter_rules_.Clear();
}
inline ::message::CommandACL* TokenAuthInfo::mutable_filter_rules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.filter_rules)
  return _internal_mutable_filter_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::CommandACL>* TokenAuthInfo::mutable_filter_rules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.TokenAuthInfo.filter_rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_filter_rules();
}
inline const ::message::CommandACL& TokenAuthInfo::filter_rules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.filter_rules)
  return _internal_filter_rules().Get(index);
}
inline ::message::CommandACL* TokenAuthInfo::add_filter_rules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::CommandACL* _add = _internal_mutable_filter_rules()->Add();
  // @@protoc_insertion_point(field_add:message.TokenAuthInfo.filter_rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::CommandACL>& TokenAuthInfo::filter_rules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.TokenAuthInfo.filter_rules)
  return _internal_filter_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::message::CommandACL>&
TokenAuthInfo::_internal_filter_rules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filter_rules_;
}
inline ::google::protobuf::RepeatedPtrField<::message::CommandACL>*
TokenAuthInfo::_internal_mutable_filter_rules() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.filter_rules_;
}

// repeated .message.Gateway gateways = 9;
inline int TokenAuthInfo::_internal_gateways_size() const {
  return _internal_gateways().size();
}
inline int TokenAuthInfo::gateways_size() const {
  return _internal_gateways_size();
}
inline void TokenAuthInfo::clear_gateways() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gateways_.Clear();
}
inline ::message::Gateway* TokenAuthInfo::mutable_gateways(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.gateways)
  return _internal_mutable_gateways()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>* TokenAuthInfo::mutable_gateways()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.TokenAuthInfo.gateways)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_gateways();
}
inline const ::message::Gateway& TokenAuthInfo::gateways(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.gateways)
  return _internal_gateways().Get(index);
}
inline ::message::Gateway* TokenAuthInfo::add_gateways() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::Gateway* _add = _internal_mutable_gateways()->Add();
  // @@protoc_insertion_point(field_add:message.TokenAuthInfo.gateways)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>& TokenAuthInfo::gateways() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.TokenAuthInfo.gateways)
  return _internal_gateways();
}
inline const ::google::protobuf::RepeatedPtrField<::message::Gateway>&
TokenAuthInfo::_internal_gateways() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gateways_;
}
inline ::google::protobuf::RepeatedPtrField<::message::Gateway>*
TokenAuthInfo::_internal_mutable_gateways() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.gateways_;
}

// .message.ComponentSetting setting = 10;
inline bool TokenAuthInfo::has_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.setting_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.setting_ != nullptr) _impl_.setting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::message::ComponentSetting& TokenAuthInfo::_internal_setting() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::ComponentSetting* p = _impl_.setting_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ComponentSetting&>(::message::_ComponentSetting_default_instance_);
}
inline const ::message::ComponentSetting& TokenAuthInfo::setting() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.setting)
  return _internal_setting();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_setting(::message::ComponentSetting* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.setting_);
  }
  _impl_.setting_ = reinterpret_cast<::message::ComponentSetting*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.setting)
}
inline ::message::ComponentSetting* TokenAuthInfo::release_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::message::ComponentSetting* released = _impl_.setting_;
  _impl_.setting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::ComponentSetting* TokenAuthInfo::unsafe_arena_release_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.setting)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::message::ComponentSetting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
  return temp;
}
inline ::message::ComponentSetting* TokenAuthInfo::_internal_mutable_setting() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.setting_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::ComponentSetting>(GetArena());
    _impl_.setting_ = reinterpret_cast<::message::ComponentSetting*>(p);
  }
  return _impl_.setting_;
}
inline ::message::ComponentSetting* TokenAuthInfo::mutable_setting() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::message::ComponentSetting* _msg = _internal_mutable_setting();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.setting)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_setting(::message::ComponentSetting* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.setting_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.setting_ = reinterpret_cast<::message::ComponentSetting*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.setting)
}

// .message.Platform platform = 11;
inline bool TokenAuthInfo::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.platform_ != nullptr);
  return value;
}
inline void TokenAuthInfo::clear_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_ != nullptr) _impl_.platform_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::message::Platform& TokenAuthInfo::_internal_platform() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::message::Platform* p = _impl_.platform_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::Platform&>(::message::_Platform_default_instance_);
}
inline const ::message::Platform& TokenAuthInfo::platform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.platform)
  return _internal_platform();
}
inline void TokenAuthInfo::unsafe_arena_set_allocated_platform(::message::Platform* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.platform_);
  }
  _impl_.platform_ = reinterpret_cast<::message::Platform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.TokenAuthInfo.platform)
}
inline ::message::Platform* TokenAuthInfo::release_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::message::Platform* released = _impl_.platform_;
  _impl_.platform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::message::Platform* TokenAuthInfo::unsafe_arena_release_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.platform)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::message::Platform* temp = _impl_.platform_;
  _impl_.platform_ = nullptr;
  return temp;
}
inline ::message::Platform* TokenAuthInfo::_internal_mutable_platform() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::message::Platform>(GetArena());
    _impl_.platform_ = reinterpret_cast<::message::Platform*>(p);
  }
  return _impl_.platform_;
}
inline ::message::Platform* TokenAuthInfo::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::message::Platform* _msg = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.platform)
  return _msg;
}
inline void TokenAuthInfo::set_allocated_platform(::message::Platform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.platform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.platform_ = reinterpret_cast<::message::Platform*>(value);
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.platform)
}

// string FaceMonitorToken = 12;
inline void TokenAuthInfo::clear_facemonitortoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.facemonitortoken_.ClearToEmpty();
}
inline const std::string& TokenAuthInfo::facemonitortoken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.TokenAuthInfo.FaceMonitorToken)
  return _internal_facemonitortoken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenAuthInfo::set_facemonitortoken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.facemonitortoken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.TokenAuthInfo.FaceMonitorToken)
}
inline std::string* TokenAuthInfo::mutable_facemonitortoken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_facemonitortoken();
  // @@protoc_insertion_point(field_mutable:message.TokenAuthInfo.FaceMonitorToken)
  return _s;
}
inline const std::string& TokenAuthInfo::_internal_facemonitortoken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.facemonitortoken_.Get();
}
inline void TokenAuthInfo::_internal_set_facemonitortoken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.facemonitortoken_.Set(value, GetArena());
}
inline std::string* TokenAuthInfo::_internal_mutable_facemonitortoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.facemonitortoken_.Mutable( GetArena());
}
inline std::string* TokenAuthInfo::release_facemonitortoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.TokenAuthInfo.FaceMonitorToken)
  return _impl_.facemonitortoken_.Release();
}
inline void TokenAuthInfo::set_allocated_facemonitortoken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.facemonitortoken_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.facemonitortoken_.IsDefault()) {
          _impl_.facemonitortoken_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.TokenAuthInfo.FaceMonitorToken)
}

// -------------------------------------------------------------------

// Platform

// int32 id = 1;
inline void Platform::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Platform::id() const {
  // @@protoc_insertion_point(field_get:message.Platform.id)
  return _internal_id();
}
inline void Platform::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.Platform.id)
}
inline ::int32_t Platform::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Platform::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string name = 2;
inline void Platform::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Platform::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Platform.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Platform::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Platform.name)
}
inline std::string* Platform::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Platform.name)
  return _s;
}
inline const std::string& Platform::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Platform::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Platform::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Platform::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Platform.name)
  return _impl_.name_.Release();
}
inline void Platform::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Platform.name)
}

// string category = 3;
inline void Platform::clear_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.ClearToEmpty();
}
inline const std::string& Platform::category() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Platform.category)
  return _internal_category();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Platform::set_category(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Platform.category)
}
inline std::string* Platform::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:message.Platform.category)
  return _s;
}
inline const std::string& Platform::_internal_category() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_.Get();
}
inline void Platform::_internal_set_category(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.Set(value, GetArena());
}
inline std::string* Platform::_internal_mutable_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.category_.Mutable( GetArena());
}
inline std::string* Platform::release_category() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Platform.category)
  return _impl_.category_.Release();
}
inline void Platform::set_allocated_category(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.category_.IsDefault()) {
          _impl_.category_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Platform.category)
}

// string charset = 4;
inline void Platform::clear_charset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charset_.ClearToEmpty();
}
inline const std::string& Platform::charset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Platform.charset)
  return _internal_charset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Platform::set_charset(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Platform.charset)
}
inline std::string* Platform::mutable_charset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:message.Platform.charset)
  return _s;
}
inline const std::string& Platform::_internal_charset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.charset_.Get();
}
inline void Platform::_internal_set_charset(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charset_.Set(value, GetArena());
}
inline std::string* Platform::_internal_mutable_charset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.charset_.Mutable( GetArena());
}
inline std::string* Platform::release_charset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Platform.charset)
  return _impl_.charset_.Release();
}
inline void Platform::set_allocated_charset(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.charset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.charset_.IsDefault()) {
          _impl_.charset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Platform.charset)
}

// string type = 5;
inline void Platform::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Platform::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Platform.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Platform::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Platform.type)
}
inline std::string* Platform::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:message.Platform.type)
  return _s;
}
inline const std::string& Platform::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Platform::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Platform::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Platform::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Platform.type)
  return _impl_.type_.Release();
}
inline void Platform::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Platform.type)
}

// repeated .message.PlatformProtocol protocols = 6;
inline int Platform::_internal_protocols_size() const {
  return _internal_protocols().size();
}
inline int Platform::protocols_size() const {
  return _internal_protocols_size();
}
inline void Platform::clear_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocols_.Clear();
}
inline ::message::PlatformProtocol* Platform::mutable_protocols(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:message.Platform.protocols)
  return _internal_mutable_protocols()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>* Platform::mutable_protocols()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:message.Platform.protocols)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_protocols();
}
inline const ::message::PlatformProtocol& Platform::protocols(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Platform.protocols)
  return _internal_protocols().Get(index);
}
inline ::message::PlatformProtocol* Platform::add_protocols() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::message::PlatformProtocol* _add = _internal_mutable_protocols()->Add();
  // @@protoc_insertion_point(field_add:message.Platform.protocols)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>& Platform::protocols() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:message.Platform.protocols)
  return _internal_protocols();
}
inline const ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>&
Platform::_internal_protocols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocols_;
}
inline ::google::protobuf::RepeatedPtrField<::message::PlatformProtocol>*
Platform::_internal_mutable_protocols() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.protocols_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlatformProtocol

// int32 id = 1;
inline void PlatformProtocol::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t PlatformProtocol::id() const {
  // @@protoc_insertion_point(field_get:message.PlatformProtocol.id)
  return _internal_id();
}
inline void PlatformProtocol::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.PlatformProtocol.id)
}
inline ::int32_t PlatformProtocol::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PlatformProtocol::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string name = 2;
inline void PlatformProtocol::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PlatformProtocol::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PlatformProtocol.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlatformProtocol::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PlatformProtocol.name)
}
inline std::string* PlatformProtocol::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.PlatformProtocol.name)
  return _s;
}
inline const std::string& PlatformProtocol::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PlatformProtocol::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PlatformProtocol::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PlatformProtocol::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PlatformProtocol.name)
  return _impl_.name_.Release();
}
inline void PlatformProtocol::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PlatformProtocol.name)
}

// int32 port = 3;
inline void PlatformProtocol::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t PlatformProtocol::port() const {
  // @@protoc_insertion_point(field_get:message.PlatformProtocol.port)
  return _internal_port();
}
inline void PlatformProtocol::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.PlatformProtocol.port)
}
inline ::int32_t PlatformProtocol::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void PlatformProtocol::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// map<string, string> settings = 4;
inline int PlatformProtocol::_internal_settings_size() const {
  return _internal_settings().size();
}
inline int PlatformProtocol::settings_size() const {
  return _internal_settings_size();
}
inline void PlatformProtocol::clear_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.settings_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PlatformProtocol::_internal_settings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.settings_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PlatformProtocol::settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:message.PlatformProtocol.settings)
  return _internal_settings();
}
inline ::google::protobuf::Map<std::string, std::string>* PlatformProtocol::_internal_mutable_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.settings_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PlatformProtocol::mutable_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:message.PlatformProtocol.settings)
  return _internal_mutable_settings();
}

// -------------------------------------------------------------------

// ComponentSetting

// int32 max_idle_time = 1;
inline void ComponentSetting::clear_max_idle_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_idle_time_ = 0;
}
inline ::int32_t ComponentSetting::max_idle_time() const {
  // @@protoc_insertion_point(field_get:message.ComponentSetting.max_idle_time)
  return _internal_max_idle_time();
}
inline void ComponentSetting::set_max_idle_time(::int32_t value) {
  _internal_set_max_idle_time(value);
  // @@protoc_insertion_point(field_set:message.ComponentSetting.max_idle_time)
}
inline ::int32_t ComponentSetting::_internal_max_idle_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_idle_time_;
}
inline void ComponentSetting::_internal_set_max_idle_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_idle_time_ = value;
}

// int32 max_session_time = 2;
inline void ComponentSetting::clear_max_session_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_session_time_ = 0;
}
inline ::int32_t ComponentSetting::max_session_time() const {
  // @@protoc_insertion_point(field_get:message.ComponentSetting.max_session_time)
  return _internal_max_session_time();
}
inline void ComponentSetting::set_max_session_time(::int32_t value) {
  _internal_set_max_session_time(value);
  // @@protoc_insertion_point(field_set:message.ComponentSetting.max_session_time)
}
inline ::int32_t ComponentSetting::_internal_max_session_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_session_time_;
}
inline void ComponentSetting::_internal_set_max_session_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_session_time_ = value;
}

// -------------------------------------------------------------------

// Forward

// string id = 1;
inline void Forward::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Forward::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Forward.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Forward::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Forward.id)
}
inline std::string* Forward::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:message.Forward.id)
  return _s;
}
inline const std::string& Forward::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Forward::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Forward::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Forward::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Forward.id)
  return _impl_.id_.Release();
}
inline void Forward::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Forward.id)
}

// string Host = 2;
inline void Forward::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Forward::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Forward.Host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Forward::set_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Forward.Host)
}
inline std::string* Forward::mutable_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:message.Forward.Host)
  return _s;
}
inline const std::string& Forward::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void Forward::_internal_set_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.Set(value, GetArena());
}
inline std::string* Forward::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.host_.Mutable( GetArena());
}
inline std::string* Forward::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Forward.Host)
  return _impl_.host_.Release();
}
inline void Forward::set_allocated_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Forward.Host)
}

// int32 port = 3;
inline void Forward::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0;
}
inline ::int32_t Forward::port() const {
  // @@protoc_insertion_point(field_get:message.Forward.port)
  return _internal_port();
}
inline void Forward::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:message.Forward.port)
}
inline ::int32_t Forward::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void Forward::_internal_set_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// PublicSetting

// bool xpack_enabled = 1;
inline void PublicSetting::clear_xpack_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpack_enabled_ = false;
}
inline bool PublicSetting::xpack_enabled() const {
  // @@protoc_insertion_point(field_get:message.PublicSetting.xpack_enabled)
  return _internal_xpack_enabled();
}
inline void PublicSetting::set_xpack_enabled(bool value) {
  _internal_set_xpack_enabled(value);
  // @@protoc_insertion_point(field_set:message.PublicSetting.xpack_enabled)
}
inline bool PublicSetting::_internal_xpack_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xpack_enabled_;
}
inline void PublicSetting::_internal_set_xpack_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpack_enabled_ = value;
}

// bool valid_license = 2;
inline void PublicSetting::clear_valid_license() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_license_ = false;
}
inline bool PublicSetting::valid_license() const {
  // @@protoc_insertion_point(field_get:message.PublicSetting.valid_license)
  return _internal_valid_license();
}
inline void PublicSetting::set_valid_license(bool value) {
  _internal_set_valid_license(value);
  // @@protoc_insertion_point(field_set:message.PublicSetting.valid_license)
}
inline bool PublicSetting::_internal_valid_license() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.valid_license_;
}
inline void PublicSetting::_internal_set_valid_license(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_license_ = value;
}

// string gpt_base_url = 3;
inline void PublicSetting::clear_gpt_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_base_url_.ClearToEmpty();
}
inline const std::string& PublicSetting::gpt_base_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSetting.gpt_base_url)
  return _internal_gpt_base_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicSetting::set_gpt_base_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_base_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PublicSetting.gpt_base_url)
}
inline std::string* PublicSetting::mutable_gpt_base_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gpt_base_url();
  // @@protoc_insertion_point(field_mutable:message.PublicSetting.gpt_base_url)
  return _s;
}
inline const std::string& PublicSetting::_internal_gpt_base_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gpt_base_url_.Get();
}
inline void PublicSetting::_internal_set_gpt_base_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_base_url_.Set(value, GetArena());
}
inline std::string* PublicSetting::_internal_mutable_gpt_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.gpt_base_url_.Mutable( GetArena());
}
inline std::string* PublicSetting::release_gpt_base_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSetting.gpt_base_url)
  return _impl_.gpt_base_url_.Release();
}
inline void PublicSetting::set_allocated_gpt_base_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_base_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gpt_base_url_.IsDefault()) {
          _impl_.gpt_base_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PublicSetting.gpt_base_url)
}

// string gpt_api_key = 4;
inline void PublicSetting::clear_gpt_api_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_api_key_.ClearToEmpty();
}
inline const std::string& PublicSetting::gpt_api_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSetting.gpt_api_key)
  return _internal_gpt_api_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicSetting::set_gpt_api_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_api_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PublicSetting.gpt_api_key)
}
inline std::string* PublicSetting::mutable_gpt_api_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gpt_api_key();
  // @@protoc_insertion_point(field_mutable:message.PublicSetting.gpt_api_key)
  return _s;
}
inline const std::string& PublicSetting::_internal_gpt_api_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gpt_api_key_.Get();
}
inline void PublicSetting::_internal_set_gpt_api_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_api_key_.Set(value, GetArena());
}
inline std::string* PublicSetting::_internal_mutable_gpt_api_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.gpt_api_key_.Mutable( GetArena());
}
inline std::string* PublicSetting::release_gpt_api_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSetting.gpt_api_key)
  return _impl_.gpt_api_key_.Release();
}
inline void PublicSetting::set_allocated_gpt_api_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_api_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gpt_api_key_.IsDefault()) {
          _impl_.gpt_api_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PublicSetting.gpt_api_key)
}

// string gpt_proxy = 5;
inline void PublicSetting::clear_gpt_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_proxy_.ClearToEmpty();
}
inline const std::string& PublicSetting::gpt_proxy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSetting.gpt_proxy)
  return _internal_gpt_proxy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicSetting::set_gpt_proxy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_proxy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PublicSetting.gpt_proxy)
}
inline std::string* PublicSetting::mutable_gpt_proxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gpt_proxy();
  // @@protoc_insertion_point(field_mutable:message.PublicSetting.gpt_proxy)
  return _s;
}
inline const std::string& PublicSetting::_internal_gpt_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gpt_proxy_.Get();
}
inline void PublicSetting::_internal_set_gpt_proxy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_proxy_.Set(value, GetArena());
}
inline std::string* PublicSetting::_internal_mutable_gpt_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.gpt_proxy_.Mutable( GetArena());
}
inline std::string* PublicSetting::release_gpt_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSetting.gpt_proxy)
  return _impl_.gpt_proxy_.Release();
}
inline void PublicSetting::set_allocated_gpt_proxy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_proxy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gpt_proxy_.IsDefault()) {
          _impl_.gpt_proxy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PublicSetting.gpt_proxy)
}

// string gpt_model = 6;
inline void PublicSetting::clear_gpt_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_model_.ClearToEmpty();
}
inline const std::string& PublicSetting::gpt_model() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSetting.gpt_model)
  return _internal_gpt_model();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicSetting::set_gpt_model(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_model_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PublicSetting.gpt_model)
}
inline std::string* PublicSetting::mutable_gpt_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gpt_model();
  // @@protoc_insertion_point(field_mutable:message.PublicSetting.gpt_model)
  return _s;
}
inline const std::string& PublicSetting::_internal_gpt_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gpt_model_.Get();
}
inline void PublicSetting::_internal_set_gpt_model(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_model_.Set(value, GetArena());
}
inline std::string* PublicSetting::_internal_mutable_gpt_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.gpt_model_.Mutable( GetArena());
}
inline std::string* PublicSetting::release_gpt_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSetting.gpt_model)
  return _impl_.gpt_model_.Release();
}
inline void PublicSetting::set_allocated_gpt_model(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gpt_model_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gpt_model_.IsDefault()) {
          _impl_.gpt_model_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PublicSetting.gpt_model)
}

// string license_content = 7;
inline void PublicSetting::clear_license_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.license_content_.ClearToEmpty();
}
inline const std::string& PublicSetting::license_content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.PublicSetting.license_content)
  return _internal_license_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicSetting::set_license_content(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.license_content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.PublicSetting.license_content)
}
inline std::string* PublicSetting::mutable_license_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_license_content();
  // @@protoc_insertion_point(field_mutable:message.PublicSetting.license_content)
  return _s;
}
inline const std::string& PublicSetting::_internal_license_content() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.license_content_.Get();
}
inline void PublicSetting::_internal_set_license_content(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.license_content_.Set(value, GetArena());
}
inline std::string* PublicSetting::_internal_mutable_license_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.license_content_.Mutable( GetArena());
}
inline std::string* PublicSetting::release_license_content() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.PublicSetting.license_content)
  return _impl_.license_content_.Release();
}
inline void PublicSetting::set_allocated_license_content(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.license_content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.license_content_.IsDefault()) {
          _impl_.license_content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PublicSetting.license_content)
}

// -------------------------------------------------------------------

// Cookie

// string name = 1;
inline void Cookie::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Cookie::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Cookie.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cookie::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Cookie.name)
}
inline std::string* Cookie::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:message.Cookie.name)
  return _s;
}
inline const std::string& Cookie::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Cookie::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Cookie::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Cookie::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Cookie.name)
  return _impl_.name_.Release();
}
inline void Cookie::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Cookie.name)
}

// string value = 2;
inline void Cookie::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Cookie::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.Cookie.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cookie::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.Cookie.value)
}
inline std::string* Cookie::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:message.Cookie.value)
  return _s;
}
inline const std::string& Cookie::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void Cookie::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Cookie::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Cookie::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.Cookie.value)
  return _impl_.value_.Release();
}
inline void Cookie::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.Cookie.value)
}

// -------------------------------------------------------------------

// LifecycleLogData

// .message.LifecycleLogData.event_type event = 1;
inline void LifecycleLogData::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_ = 0;
}
inline ::message::LifecycleLogData_event_type LifecycleLogData::event() const {
  // @@protoc_insertion_point(field_get:message.LifecycleLogData.event)
  return _internal_event();
}
inline void LifecycleLogData::set_event(::message::LifecycleLogData_event_type value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:message.LifecycleLogData.event)
}
inline ::message::LifecycleLogData_event_type LifecycleLogData::_internal_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::message::LifecycleLogData_event_type>(_impl_.event_);
}
inline void LifecycleLogData::_internal_set_event(::message::LifecycleLogData_event_type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_ = value;
}

// string reason = 2;
inline void LifecycleLogData::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& LifecycleLogData::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.LifecycleLogData.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LifecycleLogData::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.LifecycleLogData.reason)
}
inline std::string* LifecycleLogData::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:message.LifecycleLogData.reason)
  return _s;
}
inline const std::string& LifecycleLogData::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void LifecycleLogData::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* LifecycleLogData::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* LifecycleLogData::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.LifecycleLogData.reason)
  return _impl_.reason_.Release();
}
inline void LifecycleLogData::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.LifecycleLogData.reason)
}

// string user = 3;
inline void LifecycleLogData::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& LifecycleLogData::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.LifecycleLogData.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LifecycleLogData::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.LifecycleLogData.user)
}
inline std::string* LifecycleLogData::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:message.LifecycleLogData.user)
  return _s;
}
inline const std::string& LifecycleLogData::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void LifecycleLogData::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* LifecycleLogData::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* LifecycleLogData::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:message.LifecycleLogData.user)
  return _impl_.user_.Release();
}
inline void LifecycleLogData::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.LifecycleLogData.user)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace message


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::message::CommandACL_Action> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::CommandACL_Action>() {
  return ::message::CommandACL_Action_descriptor();
}
template <>
struct is_proto_enum<::message::Session_LoginFrom> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::Session_LoginFrom>() {
  return ::message::Session_LoginFrom_descriptor();
}
template <>
struct is_proto_enum<::message::LifecycleLogData_event_type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::LifecycleLogData_event_type>() {
  return ::message::LifecycleLogData_event_type_descriptor();
}
template <>
struct is_proto_enum<::message::TaskAction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::TaskAction>() {
  return ::message::TaskAction_descriptor();
}
template <>
struct is_proto_enum<::message::RiskLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::RiskLevel>() {
  return ::message::RiskLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
